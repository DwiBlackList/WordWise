var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { c as createLucideIcon, r as reactExports, R as React, b as ReactDOM, B as BrowserRouter } from "./chunk-K6AXKMTT-llj0GQDa.js";
import { R as ReportsComponent, B as Box, G as Grid2, S as Sidebar } from "./Sidebar-DkcFO_WZ.js";
import { g as getDefaultExportFromCjs } from "./_commonjsHelpers-DWwsNxpa.js";
import "./axios-Cl7A0Ixg.js";
var require_Dashboard_007 = __commonJS({
  "assets/Dashboard-BGbOcLhb.js"(exports, module) {
    var _a, _b;
    /**
     * @license lucide-react v0.464.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
    /**
     * @license lucide-react v0.464.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */
    const Copy = createLucideIcon("Copy", [
      ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
      ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
    ]);
    var Events = (
      /** @class */
      function() {
        function Events2(eventType, eventFunctions) {
          if (eventFunctions === void 0) {
            eventFunctions = [];
          }
          this._eventType = eventType;
          this._eventFunctions = eventFunctions;
        }
        Events2.prototype.init = function() {
          var _this = this;
          this._eventFunctions.forEach(function(eventFunction) {
            if (typeof window !== "undefined") {
              window.addEventListener(_this._eventType, eventFunction);
            }
          });
        };
        return Events2;
      }()
    );
    var Instances = (
      /** @class */
      function() {
        function Instances2() {
          this._instances = {
            Accordion: {},
            Carousel: {},
            Collapse: {},
            Dial: {},
            Dismiss: {},
            Drawer: {},
            Dropdown: {},
            Modal: {},
            Popover: {},
            Tabs: {},
            Tooltip: {},
            InputCounter: {},
            CopyClipboard: {},
            Datepicker: {}
          };
        }
        Instances2.prototype.addInstance = function(component, instance, id, override) {
          if (override === void 0) {
            override = false;
          }
          if (!this._instances[component]) {
            console.warn("Flowbite: Component ".concat(component, " does not exist."));
            return false;
          }
          if (this._instances[component][id] && !override) {
            console.warn("Flowbite: Instance with ID ".concat(id, " already exists."));
            return;
          }
          if (override && this._instances[component][id]) {
            this._instances[component][id].destroyAndRemoveInstance();
          }
          this._instances[component][id ? id : this._generateRandomId()] = instance;
        };
        Instances2.prototype.getAllInstances = function() {
          return this._instances;
        };
        Instances2.prototype.getInstances = function(component) {
          if (!this._instances[component]) {
            console.warn("Flowbite: Component ".concat(component, " does not exist."));
            return false;
          }
          return this._instances[component];
        };
        Instances2.prototype.getInstance = function(component, id) {
          if (!this._componentAndInstanceCheck(component, id)) {
            return;
          }
          if (!this._instances[component][id]) {
            console.warn("Flowbite: Instance with ID ".concat(id, " does not exist."));
            return;
          }
          return this._instances[component][id];
        };
        Instances2.prototype.destroyAndRemoveInstance = function(component, id) {
          if (!this._componentAndInstanceCheck(component, id)) {
            return;
          }
          this.destroyInstanceObject(component, id);
          this.removeInstance(component, id);
        };
        Instances2.prototype.removeInstance = function(component, id) {
          if (!this._componentAndInstanceCheck(component, id)) {
            return;
          }
          delete this._instances[component][id];
        };
        Instances2.prototype.destroyInstanceObject = function(component, id) {
          if (!this._componentAndInstanceCheck(component, id)) {
            return;
          }
          this._instances[component][id].destroy();
        };
        Instances2.prototype.instanceExists = function(component, id) {
          if (!this._instances[component]) {
            return false;
          }
          if (!this._instances[component][id]) {
            return false;
          }
          return true;
        };
        Instances2.prototype._generateRandomId = function() {
          return Math.random().toString(36).substr(2, 9);
        };
        Instances2.prototype._componentAndInstanceCheck = function(component, id) {
          if (!this._instances[component]) {
            console.warn("Flowbite: Component ".concat(component, " does not exist."));
            return false;
          }
          if (!this._instances[component][id]) {
            console.warn("Flowbite: Instance with ID ".concat(id, " does not exist."));
            return false;
          }
          return true;
        };
        return Instances2;
      }()
    );
    var instances$1 = new Instances();
    if (typeof window !== "undefined") {
      window.FlowbiteInstances = instances$1;
    }
    var __assign$d = function() {
      __assign$d = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$d.apply(this, arguments);
    };
    var Default$d = {
      alwaysOpen: false,
      activeClasses: "bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white",
      inactiveClasses: "text-gray-500 dark:text-gray-400",
      onOpen: function() {
      },
      onClose: function() {
      },
      onToggle: function() {
      }
    };
    var DefaultInstanceOptions$d = {
      id: null,
      override: true
    };
    var Accordion = (
      /** @class */
      function() {
        function Accordion2(accordionEl, items, options, instanceOptions) {
          if (accordionEl === void 0) {
            accordionEl = null;
          }
          if (items === void 0) {
            items = [];
          }
          if (options === void 0) {
            options = Default$d;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$d;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : accordionEl.id;
          this._accordionEl = accordionEl;
          this._items = items;
          this._options = __assign$d(__assign$d({}, Default$d), options);
          this._initialized = false;
          this.init();
          instances$1.addInstance("Accordion", this, this._instanceId, instanceOptions.override);
        }
        Accordion2.prototype.init = function() {
          var _this = this;
          if (this._items.length && !this._initialized) {
            this._items.forEach(function(item) {
              if (item.active) {
                _this.open(item.id);
              }
              var clickHandler = function() {
                _this.toggle(item.id);
              };
              item.triggerEl.addEventListener("click", clickHandler);
              item.clickHandler = clickHandler;
            });
            this._initialized = true;
          }
        };
        Accordion2.prototype.destroy = function() {
          if (this._items.length && this._initialized) {
            this._items.forEach(function(item) {
              item.triggerEl.removeEventListener("click", item.clickHandler);
              delete item.clickHandler;
            });
            this._initialized = false;
          }
        };
        Accordion2.prototype.removeInstance = function() {
          instances$1.removeInstance("Accordion", this._instanceId);
        };
        Accordion2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Accordion2.prototype.getItem = function(id) {
          return this._items.filter(function(item) {
            return item.id === id;
          })[0];
        };
        Accordion2.prototype.open = function(id) {
          var _a2, _b2;
          var _this = this;
          var item = this.getItem(id);
          if (!this._options.alwaysOpen) {
            this._items.map(function(i) {
              var _a3, _b3;
              if (i !== item) {
                (_a3 = i.triggerEl.classList).remove.apply(_a3, _this._options.activeClasses.split(" "));
                (_b3 = i.triggerEl.classList).add.apply(_b3, _this._options.inactiveClasses.split(" "));
                i.targetEl.classList.add("hidden");
                i.triggerEl.setAttribute("aria-expanded", "false");
                i.active = false;
                if (i.iconEl) {
                  i.iconEl.classList.add("rotate-180");
                }
              }
            });
          }
          (_a2 = item.triggerEl.classList).add.apply(_a2, this._options.activeClasses.split(" "));
          (_b2 = item.triggerEl.classList).remove.apply(_b2, this._options.inactiveClasses.split(" "));
          item.triggerEl.setAttribute("aria-expanded", "true");
          item.targetEl.classList.remove("hidden");
          item.active = true;
          if (item.iconEl) {
            item.iconEl.classList.remove("rotate-180");
          }
          this._options.onOpen(this, item);
        };
        Accordion2.prototype.toggle = function(id) {
          var item = this.getItem(id);
          if (item.active) {
            this.close(id);
          } else {
            this.open(id);
          }
          this._options.onToggle(this, item);
        };
        Accordion2.prototype.close = function(id) {
          var _a2, _b2;
          var item = this.getItem(id);
          (_a2 = item.triggerEl.classList).remove.apply(_a2, this._options.activeClasses.split(" "));
          (_b2 = item.triggerEl.classList).add.apply(_b2, this._options.inactiveClasses.split(" "));
          item.targetEl.classList.add("hidden");
          item.triggerEl.setAttribute("aria-expanded", "false");
          item.active = false;
          if (item.iconEl) {
            item.iconEl.classList.add("rotate-180");
          }
          this._options.onClose(this, item);
        };
        Accordion2.prototype.updateOnOpen = function(callback2) {
          this._options.onOpen = callback2;
        };
        Accordion2.prototype.updateOnClose = function(callback2) {
          this._options.onClose = callback2;
        };
        Accordion2.prototype.updateOnToggle = function(callback2) {
          this._options.onToggle = callback2;
        };
        return Accordion2;
      }()
    );
    function initAccordions() {
      document.querySelectorAll("[data-accordion]").forEach(function($accordionEl) {
        var alwaysOpen = $accordionEl.getAttribute("data-accordion");
        var activeClasses = $accordionEl.getAttribute("data-active-classes");
        var inactiveClasses = $accordionEl.getAttribute("data-inactive-classes");
        var items = [];
        $accordionEl.querySelectorAll("[data-accordion-target]").forEach(function($triggerEl) {
          if ($triggerEl.closest("[data-accordion]") === $accordionEl) {
            var item = {
              id: $triggerEl.getAttribute("data-accordion-target"),
              triggerEl: $triggerEl,
              targetEl: document.querySelector($triggerEl.getAttribute("data-accordion-target")),
              iconEl: $triggerEl.querySelector("[data-accordion-icon]"),
              active: $triggerEl.getAttribute("aria-expanded") === "true" ? true : false
            };
            items.push(item);
          }
        });
        new Accordion($accordionEl, items, {
          alwaysOpen: alwaysOpen === "open" ? true : false,
          activeClasses: activeClasses ? activeClasses : Default$d.activeClasses,
          inactiveClasses: inactiveClasses ? inactiveClasses : Default$d.inactiveClasses
        });
      });
    }
    if (typeof window !== "undefined") {
      window.Accordion = Accordion;
      window.initAccordions = initAccordions;
    }
    var __assign$c = function() {
      __assign$c = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$c.apply(this, arguments);
    };
    var Default$c = {
      onCollapse: function() {
      },
      onExpand: function() {
      },
      onToggle: function() {
      }
    };
    var DefaultInstanceOptions$c = {
      id: null,
      override: true
    };
    var Collapse = (
      /** @class */
      function() {
        function Collapse2(targetEl, triggerEl, options, instanceOptions) {
          if (targetEl === void 0) {
            targetEl = null;
          }
          if (triggerEl === void 0) {
            triggerEl = null;
          }
          if (options === void 0) {
            options = Default$c;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$c;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
          this._targetEl = targetEl;
          this._triggerEl = triggerEl;
          this._options = __assign$c(__assign$c({}, Default$c), options);
          this._visible = false;
          this._initialized = false;
          this.init();
          instances$1.addInstance("Collapse", this, this._instanceId, instanceOptions.override);
        }
        Collapse2.prototype.init = function() {
          var _this = this;
          if (this._triggerEl && this._targetEl && !this._initialized) {
            if (this._triggerEl.hasAttribute("aria-expanded")) {
              this._visible = this._triggerEl.getAttribute("aria-expanded") === "true";
            } else {
              this._visible = !this._targetEl.classList.contains("hidden");
            }
            this._clickHandler = function() {
              _this.toggle();
            };
            this._triggerEl.addEventListener("click", this._clickHandler);
            this._initialized = true;
          }
        };
        Collapse2.prototype.destroy = function() {
          if (this._triggerEl && this._initialized) {
            this._triggerEl.removeEventListener("click", this._clickHandler);
            this._initialized = false;
          }
        };
        Collapse2.prototype.removeInstance = function() {
          instances$1.removeInstance("Collapse", this._instanceId);
        };
        Collapse2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Collapse2.prototype.collapse = function() {
          this._targetEl.classList.add("hidden");
          if (this._triggerEl) {
            this._triggerEl.setAttribute("aria-expanded", "false");
          }
          this._visible = false;
          this._options.onCollapse(this);
        };
        Collapse2.prototype.expand = function() {
          this._targetEl.classList.remove("hidden");
          if (this._triggerEl) {
            this._triggerEl.setAttribute("aria-expanded", "true");
          }
          this._visible = true;
          this._options.onExpand(this);
        };
        Collapse2.prototype.toggle = function() {
          if (this._visible) {
            this.collapse();
          } else {
            this.expand();
          }
          this._options.onToggle(this);
        };
        Collapse2.prototype.updateOnCollapse = function(callback2) {
          this._options.onCollapse = callback2;
        };
        Collapse2.prototype.updateOnExpand = function(callback2) {
          this._options.onExpand = callback2;
        };
        Collapse2.prototype.updateOnToggle = function(callback2) {
          this._options.onToggle = callback2;
        };
        return Collapse2;
      }()
    );
    function initCollapses() {
      document.querySelectorAll("[data-collapse-toggle]").forEach(function($triggerEl) {
        var targetId = $triggerEl.getAttribute("data-collapse-toggle");
        var $targetEl = document.getElementById(targetId);
        if ($targetEl) {
          if (!instances$1.instanceExists("Collapse", $targetEl.getAttribute("id"))) {
            new Collapse($targetEl, $triggerEl);
          } else {
            new Collapse($targetEl, $triggerEl, {}, {
              id: $targetEl.getAttribute("id") + "_" + instances$1._generateRandomId()
            });
          }
        } else {
          console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-collapse-toggle attribute.'));
        }
      });
    }
    if (typeof window !== "undefined") {
      window.Collapse = Collapse;
      window.initCollapses = initCollapses;
    }
    var __assign$b = function() {
      __assign$b = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$b.apply(this, arguments);
    };
    var Default$b = {
      defaultPosition: 0,
      indicators: {
        items: [],
        activeClasses: "bg-white dark:bg-gray-800",
        inactiveClasses: "bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800"
      },
      interval: 3e3,
      onNext: function() {
      },
      onPrev: function() {
      },
      onChange: function() {
      }
    };
    var DefaultInstanceOptions$b = {
      id: null,
      override: true
    };
    var Carousel = (
      /** @class */
      function() {
        function Carousel2(carouselEl, items, options, instanceOptions) {
          if (carouselEl === void 0) {
            carouselEl = null;
          }
          if (items === void 0) {
            items = [];
          }
          if (options === void 0) {
            options = Default$b;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$b;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : carouselEl.id;
          this._carouselEl = carouselEl;
          this._items = items;
          this._options = __assign$b(__assign$b(__assign$b({}, Default$b), options), { indicators: __assign$b(__assign$b({}, Default$b.indicators), options.indicators) });
          this._activeItem = this.getItem(this._options.defaultPosition);
          this._indicators = this._options.indicators.items;
          this._intervalDuration = this._options.interval;
          this._intervalInstance = null;
          this._initialized = false;
          this.init();
          instances$1.addInstance("Carousel", this, this._instanceId, instanceOptions.override);
        }
        Carousel2.prototype.init = function() {
          var _this = this;
          if (this._items.length && !this._initialized) {
            this._items.map(function(item) {
              item.el.classList.add("absolute", "inset-0", "transition-transform", "transform");
            });
            if (this.getActiveItem()) {
              this.slideTo(this.getActiveItem().position);
            } else {
              this.slideTo(0);
            }
            this._indicators.map(function(indicator, position) {
              indicator.el.addEventListener("click", function() {
                _this.slideTo(position);
              });
            });
            this._initialized = true;
          }
        };
        Carousel2.prototype.destroy = function() {
          if (this._initialized) {
            this._initialized = false;
          }
        };
        Carousel2.prototype.removeInstance = function() {
          instances$1.removeInstance("Carousel", this._instanceId);
        };
        Carousel2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Carousel2.prototype.getItem = function(position) {
          return this._items[position];
        };
        Carousel2.prototype.slideTo = function(position) {
          var nextItem = this._items[position];
          var rotationItems = {
            left: nextItem.position === 0 ? this._items[this._items.length - 1] : this._items[nextItem.position - 1],
            middle: nextItem,
            right: nextItem.position === this._items.length - 1 ? this._items[0] : this._items[nextItem.position + 1]
          };
          this._rotate(rotationItems);
          this._setActiveItem(nextItem);
          if (this._intervalInstance) {
            this.pause();
            this.cycle();
          }
          this._options.onChange(this);
        };
        Carousel2.prototype.next = function() {
          var activeItem = this.getActiveItem();
          var nextItem = null;
          if (activeItem.position === this._items.length - 1) {
            nextItem = this._items[0];
          } else {
            nextItem = this._items[activeItem.position + 1];
          }
          this.slideTo(nextItem.position);
          this._options.onNext(this);
        };
        Carousel2.prototype.prev = function() {
          var activeItem = this.getActiveItem();
          var prevItem = null;
          if (activeItem.position === 0) {
            prevItem = this._items[this._items.length - 1];
          } else {
            prevItem = this._items[activeItem.position - 1];
          }
          this.slideTo(prevItem.position);
          this._options.onPrev(this);
        };
        Carousel2.prototype._rotate = function(rotationItems) {
          this._items.map(function(item) {
            item.el.classList.add("hidden");
          });
          if (this._items.length === 1) {
            rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
            rotationItems.middle.el.classList.add("translate-x-0", "z-20");
            return;
          }
          rotationItems.left.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-20");
          rotationItems.left.el.classList.add("-translate-x-full", "z-10");
          rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
          rotationItems.middle.el.classList.add("translate-x-0", "z-30");
          rotationItems.right.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-30");
          rotationItems.right.el.classList.add("translate-x-full", "z-20");
        };
        Carousel2.prototype.cycle = function() {
          var _this = this;
          if (typeof window !== "undefined") {
            this._intervalInstance = window.setInterval(function() {
              _this.next();
            }, this._intervalDuration);
          }
        };
        Carousel2.prototype.pause = function() {
          clearInterval(this._intervalInstance);
        };
        Carousel2.prototype.getActiveItem = function() {
          return this._activeItem;
        };
        Carousel2.prototype._setActiveItem = function(item) {
          var _a2, _b2;
          var _this = this;
          this._activeItem = item;
          var position = item.position;
          if (this._indicators.length) {
            this._indicators.map(function(indicator) {
              var _a3, _b3;
              indicator.el.setAttribute("aria-current", "false");
              (_a3 = indicator.el.classList).remove.apply(_a3, _this._options.indicators.activeClasses.split(" "));
              (_b3 = indicator.el.classList).add.apply(_b3, _this._options.indicators.inactiveClasses.split(" "));
            });
            (_a2 = this._indicators[position].el.classList).add.apply(_a2, this._options.indicators.activeClasses.split(" "));
            (_b2 = this._indicators[position].el.classList).remove.apply(_b2, this._options.indicators.inactiveClasses.split(" "));
            this._indicators[position].el.setAttribute("aria-current", "true");
          }
        };
        Carousel2.prototype.updateOnNext = function(callback2) {
          this._options.onNext = callback2;
        };
        Carousel2.prototype.updateOnPrev = function(callback2) {
          this._options.onPrev = callback2;
        };
        Carousel2.prototype.updateOnChange = function(callback2) {
          this._options.onChange = callback2;
        };
        return Carousel2;
      }()
    );
    function initCarousels() {
      document.querySelectorAll("[data-carousel]").forEach(function($carouselEl) {
        var interval = $carouselEl.getAttribute("data-carousel-interval");
        var slide = $carouselEl.getAttribute("data-carousel") === "slide" ? true : false;
        var items = [];
        var defaultPosition = 0;
        if ($carouselEl.querySelectorAll("[data-carousel-item]").length) {
          Array.from($carouselEl.querySelectorAll("[data-carousel-item]")).map(function($carouselItemEl, position) {
            items.push({
              position,
              el: $carouselItemEl
            });
            if ($carouselItemEl.getAttribute("data-carousel-item") === "active") {
              defaultPosition = position;
            }
          });
        }
        var indicators = [];
        if ($carouselEl.querySelectorAll("[data-carousel-slide-to]").length) {
          Array.from($carouselEl.querySelectorAll("[data-carousel-slide-to]")).map(function($indicatorEl) {
            indicators.push({
              position: parseInt($indicatorEl.getAttribute("data-carousel-slide-to")),
              el: $indicatorEl
            });
          });
        }
        var carousel = new Carousel($carouselEl, items, {
          defaultPosition,
          indicators: {
            items: indicators
          },
          interval: interval ? interval : Default$b.interval
        });
        if (slide) {
          carousel.cycle();
        }
        var carouselNextEl = $carouselEl.querySelector("[data-carousel-next]");
        var carouselPrevEl = $carouselEl.querySelector("[data-carousel-prev]");
        if (carouselNextEl) {
          carouselNextEl.addEventListener("click", function() {
            carousel.next();
          });
        }
        if (carouselPrevEl) {
          carouselPrevEl.addEventListener("click", function() {
            carousel.prev();
          });
        }
      });
    }
    if (typeof window !== "undefined") {
      window.Carousel = Carousel;
      window.initCarousels = initCarousels;
    }
    var __assign$a = function() {
      __assign$a = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$a.apply(this, arguments);
    };
    var Default$a = {
      transition: "transition-opacity",
      duration: 300,
      timing: "ease-out",
      onHide: function() {
      }
    };
    var DefaultInstanceOptions$a = {
      id: null,
      override: true
    };
    var Dismiss = (
      /** @class */
      function() {
        function Dismiss2(targetEl, triggerEl, options, instanceOptions) {
          if (targetEl === void 0) {
            targetEl = null;
          }
          if (triggerEl === void 0) {
            triggerEl = null;
          }
          if (options === void 0) {
            options = Default$a;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$a;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
          this._targetEl = targetEl;
          this._triggerEl = triggerEl;
          this._options = __assign$a(__assign$a({}, Default$a), options);
          this._initialized = false;
          this.init();
          instances$1.addInstance("Dismiss", this, this._instanceId, instanceOptions.override);
        }
        Dismiss2.prototype.init = function() {
          var _this = this;
          if (this._triggerEl && this._targetEl && !this._initialized) {
            this._clickHandler = function() {
              _this.hide();
            };
            this._triggerEl.addEventListener("click", this._clickHandler);
            this._initialized = true;
          }
        };
        Dismiss2.prototype.destroy = function() {
          if (this._triggerEl && this._initialized) {
            this._triggerEl.removeEventListener("click", this._clickHandler);
            this._initialized = false;
          }
        };
        Dismiss2.prototype.removeInstance = function() {
          instances$1.removeInstance("Dismiss", this._instanceId);
        };
        Dismiss2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Dismiss2.prototype.hide = function() {
          var _this = this;
          this._targetEl.classList.add(this._options.transition, "duration-".concat(this._options.duration), this._options.timing, "opacity-0");
          setTimeout(function() {
            _this._targetEl.classList.add("hidden");
          }, this._options.duration);
          this._options.onHide(this, this._targetEl);
        };
        Dismiss2.prototype.updateOnHide = function(callback2) {
          this._options.onHide = callback2;
        };
        return Dismiss2;
      }()
    );
    function initDismisses() {
      document.querySelectorAll("[data-dismiss-target]").forEach(function($triggerEl) {
        var targetId = $triggerEl.getAttribute("data-dismiss-target");
        var $dismissEl = document.querySelector(targetId);
        if ($dismissEl) {
          new Dismiss($dismissEl, $triggerEl);
        } else {
          console.error('The dismiss element with id "'.concat(targetId, '" does not exist. Please check the data-dismiss-target attribute.'));
        }
      });
    }
    if (typeof window !== "undefined") {
      window.Dismiss = Dismiss;
      window.initDismisses = initDismisses;
    }
    var top = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto = "auto";
    var basePlacements = [top, bottom, right, left];
    var start = "start";
    var end = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    function getNodeName(element) {
      return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getWindow(node) {
      if (node == null) {
        return window;
      }
      if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }
    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }
    function isShadowRoot(node) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function(name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name];
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name2) {
          var value = attributes[name2];
          if (value === false) {
            element.removeAttribute(name2);
          } else {
            element.setAttribute(name2, value === true ? "" : value);
          }
        });
      });
    }
    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state.elements).forEach(function(name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
          var style = styleProperties.reduce(function(style2, property) {
            style2[property] = "";
            return style2;
          }, {});
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    }
    const applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect: effect$2,
      requires: ["computeStyles"]
    };
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    var max$1 = Math.max;
    var min$1 = Math.min;
    var round$2 = Math.round;
    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function(item) {
          return item.brand + "/" + item.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round$2(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round$2(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width,
        height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x,
        y
      };
    }
    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element);
      var width = element.offsetWidth;
      var height = element.offsetHeight;
      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }
      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width,
        height
      };
    }
    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;
        do {
          if (next && parent.isSameNode(next)) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function isTableElement(element) {
      return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
    }
    function getDocumentElement(element) {
      return ((isElement(element) ? element.ownerDocument : (
        // $FlowFixMe[prop-missing]
        element.document
      )) || window.document).documentElement;
    }
    function getParentNode(element) {
      if (getNodeName(element) === "html") {
        return element;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element)
      );
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element)) {
        var elementCss = getComputedStyle$1(element);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode);
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      var window2 = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function within(min2, value, max2) {
      return max$1(min2, min$1(value, max2));
    }
    function withinMaxClamp(min2, value, max2) {
      var v = within(min2, value, max2);
      return v > max2 ? max2 : v;
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys2) {
      return keys2.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    var toPaddingObject = function toPaddingObject2(padding, state) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    function arrow(_ref) {
      var _state$modifiersData$;
      var state = _ref.state, name = _ref.name, options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? "height" : "width";
      if (!arrowElement || !popperOffsets2) {
        return;
      }
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === "y" ? top : left;
      var maxProp = axis === "y" ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
      var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min2 = paddingObject[minProp];
      var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset2 = within(min2, center, max2);
      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
    }
    function effect$1(_ref2) {
      var state = _ref2.state, options = _ref2.options;
      var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
        return;
      }
      if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains(state.elements.popper, arrowElement)) {
        return;
      }
      state.elements.arrow = arrowElement;
    }
    const arrow$1 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow,
      effect: effect$1,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function getVariation(placement) {
      return placement.split("-")[1];
    }
    var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR(_ref, win) {
      var x = _ref.x, y = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round$2(x * dpr) / dpr || 0,
        y: round$2(y * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x,
        y
      }) : {
        x,
        y
      };
      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
          offsetParent = getDocumentElement(popper2);
          if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            offsetParent[heightProp]
          );
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            offsetParent[widthProp]
          );
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x,
        y
      }, getWindow(popper2)) : {
        x,
        y
      };
      x = _ref4.x;
      y = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
      };
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
      });
    }
    const computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
    var passive = {
      passive: true
    };
    function effect(_ref) {
      var state = _ref.state, instance = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance.update, passive);
      }
      return function() {
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance.update, passive);
        }
      };
    }
    const eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn() {
      },
      effect,
      data: {}
    };
    var hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$1[matched];
      });
    }
    var hash = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
      });
    }
    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x: x + getWindowScrollBarX(element),
        y
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;
      if (getComputedStyle$1(body || html).direction === "rtl") {
        x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width,
        height,
        x,
        y
      };
    }
    function isScrollParent(element) {
      var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function getScrollParent(node) {
      if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
        return node.ownerDocument.body;
      }
      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }
      return getScrollParent(getParentNode(node));
    }
    function listScrollParents(element, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
        list = [];
      }
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        updatedList.concat(listScrollParents(getParentNode(target)))
      );
    }
    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
      var clippingParents2 = listScrollParents(getParentNode(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
      });
    }
    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents2[0];
      var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max$1(rect.top, accRect.top);
        accRect.right = min$1(rect.right, accRect.right);
        accRect.bottom = min$1(rect.bottom, accRect.bottom);
        accRect.left = max$1(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function computeOffsets(_ref) {
      var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference2.x + reference2.width / 2 - element.width / 2;
      var commonY = reference2.y + reference2.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference2.y - element.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case right:
          offsets = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference2.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference2.x,
            y: reference2.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
            break;
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
            break;
        }
      }
      return offsets;
    }
    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset;
      if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
          overflowOffsets[key] += offset2[axis] * multiply;
        });
      }
      return overflowOffsets;
    }
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding
        })[getBasePlacement(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
      });
    }
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      if (state.modifiersData[name]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements2[0];
      for (var i = 0; i < placements2.length; i++) {
        var placement = placements2[i];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow(state, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function(check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i2).every(function(check) {
                return check;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break") break;
        }
      }
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    }
    const flip$1 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function(side) {
        return overflow[side] >= 0;
      });
    }
    function hide(_ref) {
      var state = _ref.state, name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
      });
    }
    const hide$1 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
    };
    function distanceAndSkiddingToXY(placement, rects, offset2) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
        placement
      })) : offset2, skidding = _ref[0], distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    function offset$1(_ref2) {
      var state = _ref2.state, options = _ref2.options, name = _ref2.name;
      var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }
      state.modifiersData[name] = data;
    }
    const offset$2 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset$1
    };
    function popperOffsets(_ref) {
      var state = _ref.state, name = _ref.name;
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
      });
    }
    const popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
    function getAltAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function preventOverflow(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
      if (!popperOffsets2) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min2 = offset2 + overflow[mainSide];
        var max2 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
      state.modifiersData[name] = data;
    }
    const preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }
    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round$2(rect.width) / element.offsetWidth || 1;
      var scaleY = round$2(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function order(modifiers) {
      var map2 = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result = [];
      modifiers.forEach(function(modifier) {
        map2.set(modifier.name, modifier);
      });
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map2.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort(modifier);
        }
      });
      return result;
    }
    function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce$1(fn) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve2) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve2(fn());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key) {
        return merged[key];
      });
    }
    var DEFAULT_OPTIONS = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
          options = defaultOptions2;
        }
        var state = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
          modifiersData: {},
          elements: {
            reference: reference2,
            popper: popper2
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state,
          setOptions: function setOptions(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions2, state.options, options2);
            state.scrollParents = {
              reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
              popper: listScrollParents(popper2)
            };
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
            state.orderedModifiers = orderedModifiers.filter(function(m) {
              return m.enabled;
            });
            runModifierEffects();
            return instance.update();
          },
          // Sync update  it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (!areValidElements(reference3, popper3)) {
              return;
            }
            state.rects = {
              reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
              popper: getLayoutRect(popper3)
            };
            state.reset = false;
            state.placement = state.options.placement;
            state.orderedModifiers.forEach(function(modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
              if (state.reset === true) {
                state.reset = false;
                index2 = -1;
                continue;
              }
              var _state$orderedModifie = state.orderedModifiers[index2], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
              if (typeof fn === "function") {
                state = fn({
                  state,
                  options: _options,
                  name,
                  instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update  it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function() {
            return new Promise(function(resolve2) {
              instance.forceUpdate();
              resolve2(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference2, popper2)) {
          return instance;
        }
        instance.setOptions(options).then(function(state2) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state2);
          }
        });
        function runModifierEffects() {
          state.orderedModifiers.forEach(function(_ref) {
            var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
            if (typeof effect2 === "function") {
              var cleanupFn = effect2({
                state,
                name,
                instance,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn) {
            return fn();
          });
          effectCleanupFns = [];
        }
        return instance;
      };
    }
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$2, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /* @__PURE__ */ popperGenerator({
      defaultModifiers
    });
    var __assign$9 = function() {
      __assign$9 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$9.apply(this, arguments);
    };
    var __spreadArray$2 = function(to2, from2, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
      return to2.concat(ar || Array.prototype.slice.call(from2));
    };
    var Default$9 = {
      placement: "bottom",
      triggerType: "click",
      offsetSkidding: 0,
      offsetDistance: 10,
      delay: 300,
      ignoreClickOutsideClass: false,
      onShow: function() {
      },
      onHide: function() {
      },
      onToggle: function() {
      }
    };
    var DefaultInstanceOptions$9 = {
      id: null,
      override: true
    };
    var Dropdown$1 = (
      /** @class */
      function() {
        function Dropdown2(targetElement, triggerElement, options, instanceOptions) {
          if (targetElement === void 0) {
            targetElement = null;
          }
          if (triggerElement === void 0) {
            triggerElement = null;
          }
          if (options === void 0) {
            options = Default$9;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$9;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : targetElement.id;
          this._targetEl = targetElement;
          this._triggerEl = triggerElement;
          this._options = __assign$9(__assign$9({}, Default$9), options);
          this._popperInstance = null;
          this._visible = false;
          this._initialized = false;
          this.init();
          instances$1.addInstance("Dropdown", this, this._instanceId, instanceOptions.override);
        }
        Dropdown2.prototype.init = function() {
          if (this._triggerEl && this._targetEl && !this._initialized) {
            this._popperInstance = this._createPopperInstance();
            this._setupEventListeners();
            this._initialized = true;
          }
        };
        Dropdown2.prototype.destroy = function() {
          var _this = this;
          var triggerEvents = this._getTriggerEvents();
          if (this._options.triggerType === "click") {
            triggerEvents.showEvents.forEach(function(ev) {
              _this._triggerEl.removeEventListener(ev, _this._clickHandler);
            });
          }
          if (this._options.triggerType === "hover") {
            triggerEvents.showEvents.forEach(function(ev) {
              _this._triggerEl.removeEventListener(ev, _this._hoverShowTriggerElHandler);
              _this._targetEl.removeEventListener(ev, _this._hoverShowTargetElHandler);
            });
            triggerEvents.hideEvents.forEach(function(ev) {
              _this._triggerEl.removeEventListener(ev, _this._hoverHideHandler);
              _this._targetEl.removeEventListener(ev, _this._hoverHideHandler);
            });
          }
          this._popperInstance.destroy();
          this._initialized = false;
        };
        Dropdown2.prototype.removeInstance = function() {
          instances$1.removeInstance("Dropdown", this._instanceId);
        };
        Dropdown2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Dropdown2.prototype._setupEventListeners = function() {
          var _this = this;
          var triggerEvents = this._getTriggerEvents();
          this._clickHandler = function() {
            _this.toggle();
          };
          if (this._options.triggerType === "click") {
            triggerEvents.showEvents.forEach(function(ev) {
              _this._triggerEl.addEventListener(ev, _this._clickHandler);
            });
          }
          this._hoverShowTriggerElHandler = function(ev) {
            if (ev.type === "click") {
              _this.toggle();
            } else {
              setTimeout(function() {
                _this.show();
              }, _this._options.delay);
            }
          };
          this._hoverShowTargetElHandler = function() {
            _this.show();
          };
          this._hoverHideHandler = function() {
            setTimeout(function() {
              if (!_this._targetEl.matches(":hover")) {
                _this.hide();
              }
            }, _this._options.delay);
          };
          if (this._options.triggerType === "hover") {
            triggerEvents.showEvents.forEach(function(ev) {
              _this._triggerEl.addEventListener(ev, _this._hoverShowTriggerElHandler);
              _this._targetEl.addEventListener(ev, _this._hoverShowTargetElHandler);
            });
            triggerEvents.hideEvents.forEach(function(ev) {
              _this._triggerEl.addEventListener(ev, _this._hoverHideHandler);
              _this._targetEl.addEventListener(ev, _this._hoverHideHandler);
            });
          }
        };
        Dropdown2.prototype._createPopperInstance = function() {
          return createPopper(this._triggerEl, this._targetEl, {
            placement: this._options.placement,
            modifiers: [
              {
                name: "offset",
                options: {
                  offset: [
                    this._options.offsetSkidding,
                    this._options.offsetDistance
                  ]
                }
              }
            ]
          });
        };
        Dropdown2.prototype._setupClickOutsideListener = function() {
          var _this = this;
          this._clickOutsideEventListener = function(ev) {
            _this._handleClickOutside(ev, _this._targetEl);
          };
          document.body.addEventListener("click", this._clickOutsideEventListener, true);
        };
        Dropdown2.prototype._removeClickOutsideListener = function() {
          document.body.removeEventListener("click", this._clickOutsideEventListener, true);
        };
        Dropdown2.prototype._handleClickOutside = function(ev, targetEl) {
          var clickedEl = ev.target;
          var ignoreClickOutsideClass = this._options.ignoreClickOutsideClass;
          var isIgnored = false;
          if (ignoreClickOutsideClass) {
            var ignoredClickOutsideEls = document.querySelectorAll(".".concat(ignoreClickOutsideClass));
            ignoredClickOutsideEls.forEach(function(el) {
              if (el.contains(clickedEl)) {
                isIgnored = true;
                return;
              }
            });
          }
          if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && !isIgnored && this.isVisible()) {
            this.hide();
          }
        };
        Dropdown2.prototype._getTriggerEvents = function() {
          switch (this._options.triggerType) {
            case "hover":
              return {
                showEvents: ["mouseenter", "click"],
                hideEvents: ["mouseleave"]
              };
            case "click":
              return {
                showEvents: ["click"],
                hideEvents: []
              };
            case "none":
              return {
                showEvents: [],
                hideEvents: []
              };
            default:
              return {
                showEvents: ["click"],
                hideEvents: []
              };
          }
        };
        Dropdown2.prototype.toggle = function() {
          if (this.isVisible()) {
            this.hide();
          } else {
            this.show();
          }
          this._options.onToggle(this);
        };
        Dropdown2.prototype.isVisible = function() {
          return this._visible;
        };
        Dropdown2.prototype.show = function() {
          this._targetEl.classList.remove("hidden");
          this._targetEl.classList.add("block");
          this._targetEl.removeAttribute("aria-hidden");
          this._popperInstance.setOptions(function(options) {
            return __assign$9(__assign$9({}, options), { modifiers: __spreadArray$2(__spreadArray$2([], options.modifiers, true), [
              { name: "eventListeners", enabled: true }
            ], false) });
          });
          this._setupClickOutsideListener();
          this._popperInstance.update();
          this._visible = true;
          this._options.onShow(this);
        };
        Dropdown2.prototype.hide = function() {
          this._targetEl.classList.remove("block");
          this._targetEl.classList.add("hidden");
          this._targetEl.setAttribute("aria-hidden", "true");
          this._popperInstance.setOptions(function(options) {
            return __assign$9(__assign$9({}, options), { modifiers: __spreadArray$2(__spreadArray$2([], options.modifiers, true), [
              { name: "eventListeners", enabled: false }
            ], false) });
          });
          this._visible = false;
          this._removeClickOutsideListener();
          this._options.onHide(this);
        };
        Dropdown2.prototype.updateOnShow = function(callback2) {
          this._options.onShow = callback2;
        };
        Dropdown2.prototype.updateOnHide = function(callback2) {
          this._options.onHide = callback2;
        };
        Dropdown2.prototype.updateOnToggle = function(callback2) {
          this._options.onToggle = callback2;
        };
        return Dropdown2;
      }()
    );
    function initDropdowns() {
      document.querySelectorAll("[data-dropdown-toggle]").forEach(function($triggerEl) {
        var dropdownId = $triggerEl.getAttribute("data-dropdown-toggle");
        var $dropdownEl = document.getElementById(dropdownId);
        if ($dropdownEl) {
          var placement = $triggerEl.getAttribute("data-dropdown-placement");
          var offsetSkidding = $triggerEl.getAttribute("data-dropdown-offset-skidding");
          var offsetDistance = $triggerEl.getAttribute("data-dropdown-offset-distance");
          var triggerType = $triggerEl.getAttribute("data-dropdown-trigger");
          var delay = $triggerEl.getAttribute("data-dropdown-delay");
          var ignoreClickOutsideClass = $triggerEl.getAttribute("data-dropdown-ignore-click-outside-class");
          new Dropdown$1($dropdownEl, $triggerEl, {
            placement: placement ? placement : Default$9.placement,
            triggerType: triggerType ? triggerType : Default$9.triggerType,
            offsetSkidding: offsetSkidding ? parseInt(offsetSkidding) : Default$9.offsetSkidding,
            offsetDistance: offsetDistance ? parseInt(offsetDistance) : Default$9.offsetDistance,
            delay: delay ? parseInt(delay) : Default$9.delay,
            ignoreClickOutsideClass: ignoreClickOutsideClass ? ignoreClickOutsideClass : Default$9.ignoreClickOutsideClass
          });
        } else {
          console.error('The dropdown element with id "'.concat(dropdownId, '" does not exist. Please check the data-dropdown-toggle attribute.'));
        }
      });
    }
    if (typeof window !== "undefined") {
      window.Dropdown = Dropdown$1;
      window.initDropdowns = initDropdowns;
    }
    var __assign$8 = function() {
      __assign$8 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$8.apply(this, arguments);
    };
    var Default$8 = {
      placement: "center",
      backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-40",
      backdrop: "dynamic",
      closable: true,
      onHide: function() {
      },
      onShow: function() {
      },
      onToggle: function() {
      }
    };
    var DefaultInstanceOptions$8 = {
      id: null,
      override: true
    };
    var Modal = (
      /** @class */
      function() {
        function Modal2(targetEl, options, instanceOptions) {
          if (targetEl === void 0) {
            targetEl = null;
          }
          if (options === void 0) {
            options = Default$8;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$8;
          }
          this._eventListenerInstances = [];
          this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
          this._targetEl = targetEl;
          this._options = __assign$8(__assign$8({}, Default$8), options);
          this._isHidden = true;
          this._backdropEl = null;
          this._initialized = false;
          this.init();
          instances$1.addInstance("Modal", this, this._instanceId, instanceOptions.override);
        }
        Modal2.prototype.init = function() {
          var _this = this;
          if (this._targetEl && !this._initialized) {
            this._getPlacementClasses().map(function(c) {
              _this._targetEl.classList.add(c);
            });
            this._initialized = true;
          }
        };
        Modal2.prototype.destroy = function() {
          if (this._initialized) {
            this.removeAllEventListenerInstances();
            this._destroyBackdropEl();
            this._initialized = false;
          }
        };
        Modal2.prototype.removeInstance = function() {
          instances$1.removeInstance("Modal", this._instanceId);
        };
        Modal2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Modal2.prototype._createBackdrop = function() {
          var _a2;
          if (this._isHidden) {
            var backdropEl = document.createElement("div");
            (_a2 = backdropEl.classList).add.apply(_a2, this._options.backdropClasses.split(" "));
            document.querySelector("body").append(backdropEl);
            this._backdropEl = backdropEl;
          }
        };
        Modal2.prototype._destroyBackdropEl = function() {
          if (!this._isHidden && this._backdropEl) {
            this._backdropEl.remove();
            this._backdropEl = null;
          }
        };
        Modal2.prototype._setupModalCloseEventListeners = function() {
          var _this = this;
          if (this._options.backdrop === "dynamic") {
            this._clickOutsideEventListener = function(ev) {
              _this._handleOutsideClick(ev.target);
            };
            this._targetEl.addEventListener("click", this._clickOutsideEventListener, true);
          }
          this._keydownEventListener = function(ev) {
            if (ev.key === "Escape") {
              _this.hide();
            }
          };
          document.body.addEventListener("keydown", this._keydownEventListener, true);
        };
        Modal2.prototype._removeModalCloseEventListeners = function() {
          if (this._options.backdrop === "dynamic") {
            this._targetEl.removeEventListener("click", this._clickOutsideEventListener, true);
          }
          document.body.removeEventListener("keydown", this._keydownEventListener, true);
        };
        Modal2.prototype._handleOutsideClick = function(target) {
          if (target === this._targetEl || target === this._backdropEl && this.isVisible()) {
            this.hide();
          }
        };
        Modal2.prototype._getPlacementClasses = function() {
          switch (this._options.placement) {
            // top
            case "top-left":
              return ["justify-start", "items-start"];
            case "top-center":
              return ["justify-center", "items-start"];
            case "top-right":
              return ["justify-end", "items-start"];
            // center
            case "center-left":
              return ["justify-start", "items-center"];
            case "center":
              return ["justify-center", "items-center"];
            case "center-right":
              return ["justify-end", "items-center"];
            // bottom
            case "bottom-left":
              return ["justify-start", "items-end"];
            case "bottom-center":
              return ["justify-center", "items-end"];
            case "bottom-right":
              return ["justify-end", "items-end"];
            default:
              return ["justify-center", "items-center"];
          }
        };
        Modal2.prototype.toggle = function() {
          if (this._isHidden) {
            this.show();
          } else {
            this.hide();
          }
          this._options.onToggle(this);
        };
        Modal2.prototype.show = function() {
          if (this.isHidden) {
            this._targetEl.classList.add("flex");
            this._targetEl.classList.remove("hidden");
            this._targetEl.setAttribute("aria-modal", "true");
            this._targetEl.setAttribute("role", "dialog");
            this._targetEl.removeAttribute("aria-hidden");
            this._createBackdrop();
            this._isHidden = false;
            if (this._options.closable) {
              this._setupModalCloseEventListeners();
            }
            document.body.classList.add("overflow-hidden");
            this._options.onShow(this);
          }
        };
        Modal2.prototype.hide = function() {
          if (this.isVisible) {
            this._targetEl.classList.add("hidden");
            this._targetEl.classList.remove("flex");
            this._targetEl.setAttribute("aria-hidden", "true");
            this._targetEl.removeAttribute("aria-modal");
            this._targetEl.removeAttribute("role");
            this._destroyBackdropEl();
            this._isHidden = true;
            document.body.classList.remove("overflow-hidden");
            if (this._options.closable) {
              this._removeModalCloseEventListeners();
            }
            this._options.onHide(this);
          }
        };
        Modal2.prototype.isVisible = function() {
          return !this._isHidden;
        };
        Modal2.prototype.isHidden = function() {
          return this._isHidden;
        };
        Modal2.prototype.addEventListenerInstance = function(element, type, handler) {
          this._eventListenerInstances.push({
            element,
            type,
            handler
          });
        };
        Modal2.prototype.removeAllEventListenerInstances = function() {
          this._eventListenerInstances.map(function(eventListenerInstance) {
            eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
          });
          this._eventListenerInstances = [];
        };
        Modal2.prototype.getAllEventListenerInstances = function() {
          return this._eventListenerInstances;
        };
        Modal2.prototype.updateOnShow = function(callback2) {
          this._options.onShow = callback2;
        };
        Modal2.prototype.updateOnHide = function(callback2) {
          this._options.onHide = callback2;
        };
        Modal2.prototype.updateOnToggle = function(callback2) {
          this._options.onToggle = callback2;
        };
        return Modal2;
      }()
    );
    function initModals() {
      document.querySelectorAll("[data-modal-target]").forEach(function($triggerEl) {
        var modalId = $triggerEl.getAttribute("data-modal-target");
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
          var placement = $modalEl.getAttribute("data-modal-placement");
          var backdrop = $modalEl.getAttribute("data-modal-backdrop");
          new Modal($modalEl, {
            placement: placement ? placement : Default$8.placement,
            backdrop: backdrop ? backdrop : Default$8.backdrop
          });
        } else {
          console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-target attribute points to the correct modal id?."));
        }
      });
      document.querySelectorAll("[data-modal-toggle]").forEach(function($triggerEl) {
        var modalId = $triggerEl.getAttribute("data-modal-toggle");
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
          var modal_1 = instances$1.getInstance("Modal", modalId);
          if (modal_1) {
            var toggleModal = function() {
              modal_1.toggle();
            };
            $triggerEl.addEventListener("click", toggleModal);
            modal_1.addEventListenerInstance($triggerEl, "click", toggleModal);
          } else {
            console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
          }
        } else {
          console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-toggle attribute points to the correct modal id?"));
        }
      });
      document.querySelectorAll("[data-modal-show]").forEach(function($triggerEl) {
        var modalId = $triggerEl.getAttribute("data-modal-show");
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
          var modal_2 = instances$1.getInstance("Modal", modalId);
          if (modal_2) {
            var showModal = function() {
              modal_2.show();
            };
            $triggerEl.addEventListener("click", showModal);
            modal_2.addEventListenerInstance($triggerEl, "click", showModal);
          } else {
            console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
          }
        } else {
          console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-show attribute points to the correct modal id?"));
        }
      });
      document.querySelectorAll("[data-modal-hide]").forEach(function($triggerEl) {
        var modalId = $triggerEl.getAttribute("data-modal-hide");
        var $modalEl = document.getElementById(modalId);
        if ($modalEl) {
          var modal_3 = instances$1.getInstance("Modal", modalId);
          if (modal_3) {
            var hideModal = function() {
              modal_3.hide();
            };
            $triggerEl.addEventListener("click", hideModal);
            modal_3.addEventListenerInstance($triggerEl, "click", hideModal);
          } else {
            console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
          }
        } else {
          console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-hide attribute points to the correct modal id?"));
        }
      });
    }
    if (typeof window !== "undefined") {
      window.Modal = Modal;
      window.initModals = initModals;
    }
    var __assign$7 = function() {
      __assign$7 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$7.apply(this, arguments);
    };
    var Default$7 = {
      placement: "left",
      bodyScrolling: false,
      backdrop: true,
      edge: false,
      edgeOffset: "bottom-[60px]",
      backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-30",
      onShow: function() {
      },
      onHide: function() {
      },
      onToggle: function() {
      }
    };
    var DefaultInstanceOptions$7 = {
      id: null,
      override: true
    };
    var Drawer = (
      /** @class */
      function() {
        function Drawer2(targetEl, options, instanceOptions) {
          if (targetEl === void 0) {
            targetEl = null;
          }
          if (options === void 0) {
            options = Default$7;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$7;
          }
          this._eventListenerInstances = [];
          this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
          this._targetEl = targetEl;
          this._options = __assign$7(__assign$7({}, Default$7), options);
          this._visible = false;
          this._initialized = false;
          this.init();
          instances$1.addInstance("Drawer", this, this._instanceId, instanceOptions.override);
        }
        Drawer2.prototype.init = function() {
          var _this = this;
          if (this._targetEl && !this._initialized) {
            this._targetEl.setAttribute("aria-hidden", "true");
            this._targetEl.classList.add("transition-transform");
            this._getPlacementClasses(this._options.placement).base.map(function(c) {
              _this._targetEl.classList.add(c);
            });
            this._handleEscapeKey = function(event) {
              if (event.key === "Escape") {
                if (_this.isVisible()) {
                  _this.hide();
                }
              }
            };
            document.addEventListener("keydown", this._handleEscapeKey);
            this._initialized = true;
          }
        };
        Drawer2.prototype.destroy = function() {
          if (this._initialized) {
            this.removeAllEventListenerInstances();
            this._destroyBackdropEl();
            document.removeEventListener("keydown", this._handleEscapeKey);
            this._initialized = false;
          }
        };
        Drawer2.prototype.removeInstance = function() {
          instances$1.removeInstance("Drawer", this._instanceId);
        };
        Drawer2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Drawer2.prototype.hide = function() {
          var _this = this;
          if (this._options.edge) {
            this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c) {
              _this._targetEl.classList.remove(c);
            });
            this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c) {
              _this._targetEl.classList.add(c);
            });
          } else {
            this._getPlacementClasses(this._options.placement).active.map(function(c) {
              _this._targetEl.classList.remove(c);
            });
            this._getPlacementClasses(this._options.placement).inactive.map(function(c) {
              _this._targetEl.classList.add(c);
            });
          }
          this._targetEl.setAttribute("aria-hidden", "true");
          this._targetEl.removeAttribute("aria-modal");
          this._targetEl.removeAttribute("role");
          if (!this._options.bodyScrolling) {
            document.body.classList.remove("overflow-hidden");
          }
          if (this._options.backdrop) {
            this._destroyBackdropEl();
          }
          this._visible = false;
          this._options.onHide(this);
        };
        Drawer2.prototype.show = function() {
          var _this = this;
          if (this._options.edge) {
            this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c) {
              _this._targetEl.classList.add(c);
            });
            this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c) {
              _this._targetEl.classList.remove(c);
            });
          } else {
            this._getPlacementClasses(this._options.placement).active.map(function(c) {
              _this._targetEl.classList.add(c);
            });
            this._getPlacementClasses(this._options.placement).inactive.map(function(c) {
              _this._targetEl.classList.remove(c);
            });
          }
          this._targetEl.setAttribute("aria-modal", "true");
          this._targetEl.setAttribute("role", "dialog");
          this._targetEl.removeAttribute("aria-hidden");
          if (!this._options.bodyScrolling) {
            document.body.classList.add("overflow-hidden");
          }
          if (this._options.backdrop) {
            this._createBackdrop();
          }
          this._visible = true;
          this._options.onShow(this);
        };
        Drawer2.prototype.toggle = function() {
          if (this.isVisible()) {
            this.hide();
          } else {
            this.show();
          }
        };
        Drawer2.prototype._createBackdrop = function() {
          var _a2;
          var _this = this;
          if (!this._visible) {
            var backdropEl = document.createElement("div");
            backdropEl.setAttribute("drawer-backdrop", "");
            (_a2 = backdropEl.classList).add.apply(_a2, this._options.backdropClasses.split(" "));
            document.querySelector("body").append(backdropEl);
            backdropEl.addEventListener("click", function() {
              _this.hide();
            });
          }
        };
        Drawer2.prototype._destroyBackdropEl = function() {
          if (this._visible && document.querySelector("[drawer-backdrop]") !== null) {
            document.querySelector("[drawer-backdrop]").remove();
          }
        };
        Drawer2.prototype._getPlacementClasses = function(placement) {
          switch (placement) {
            case "top":
              return {
                base: ["top-0", "left-0", "right-0"],
                active: ["transform-none"],
                inactive: ["-translate-y-full"]
              };
            case "right":
              return {
                base: ["right-0", "top-0"],
                active: ["transform-none"],
                inactive: ["translate-x-full"]
              };
            case "bottom":
              return {
                base: ["bottom-0", "left-0", "right-0"],
                active: ["transform-none"],
                inactive: ["translate-y-full"]
              };
            case "left":
              return {
                base: ["left-0", "top-0"],
                active: ["transform-none"],
                inactive: ["-translate-x-full"]
              };
            case "bottom-edge":
              return {
                base: ["left-0", "top-0"],
                active: ["transform-none"],
                inactive: ["translate-y-full", this._options.edgeOffset]
              };
            default:
              return {
                base: ["left-0", "top-0"],
                active: ["transform-none"],
                inactive: ["-translate-x-full"]
              };
          }
        };
        Drawer2.prototype.isHidden = function() {
          return !this._visible;
        };
        Drawer2.prototype.isVisible = function() {
          return this._visible;
        };
        Drawer2.prototype.addEventListenerInstance = function(element, type, handler) {
          this._eventListenerInstances.push({
            element,
            type,
            handler
          });
        };
        Drawer2.prototype.removeAllEventListenerInstances = function() {
          this._eventListenerInstances.map(function(eventListenerInstance) {
            eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
          });
          this._eventListenerInstances = [];
        };
        Drawer2.prototype.getAllEventListenerInstances = function() {
          return this._eventListenerInstances;
        };
        Drawer2.prototype.updateOnShow = function(callback2) {
          this._options.onShow = callback2;
        };
        Drawer2.prototype.updateOnHide = function(callback2) {
          this._options.onHide = callback2;
        };
        Drawer2.prototype.updateOnToggle = function(callback2) {
          this._options.onToggle = callback2;
        };
        return Drawer2;
      }()
    );
    function initDrawers() {
      document.querySelectorAll("[data-drawer-target]").forEach(function($triggerEl) {
        var drawerId = $triggerEl.getAttribute("data-drawer-target");
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
          var placement = $triggerEl.getAttribute("data-drawer-placement");
          var bodyScrolling = $triggerEl.getAttribute("data-drawer-body-scrolling");
          var backdrop = $triggerEl.getAttribute("data-drawer-backdrop");
          var edge = $triggerEl.getAttribute("data-drawer-edge");
          var edgeOffset = $triggerEl.getAttribute("data-drawer-edge-offset");
          new Drawer($drawerEl, {
            placement: placement ? placement : Default$7.placement,
            bodyScrolling: bodyScrolling ? bodyScrolling === "true" ? true : false : Default$7.bodyScrolling,
            backdrop: backdrop ? backdrop === "true" ? true : false : Default$7.backdrop,
            edge: edge ? edge === "true" ? true : false : Default$7.edge,
            edgeOffset: edgeOffset ? edgeOffset : Default$7.edgeOffset
          });
        } else {
          console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
        }
      });
      document.querySelectorAll("[data-drawer-toggle]").forEach(function($triggerEl) {
        var drawerId = $triggerEl.getAttribute("data-drawer-toggle");
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
          var drawer_1 = instances$1.getInstance("Drawer", drawerId);
          if (drawer_1) {
            var toggleDrawer = function() {
              drawer_1.toggle();
            };
            $triggerEl.addEventListener("click", toggleDrawer);
            drawer_1.addEventListenerInstance($triggerEl, "click", toggleDrawer);
          } else {
            console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
          }
        } else {
          console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
        }
      });
      document.querySelectorAll("[data-drawer-dismiss], [data-drawer-hide]").forEach(function($triggerEl) {
        var drawerId = $triggerEl.getAttribute("data-drawer-dismiss") ? $triggerEl.getAttribute("data-drawer-dismiss") : $triggerEl.getAttribute("data-drawer-hide");
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
          var drawer_2 = instances$1.getInstance("Drawer", drawerId);
          if (drawer_2) {
            var hideDrawer = function() {
              drawer_2.hide();
            };
            $triggerEl.addEventListener("click", hideDrawer);
            drawer_2.addEventListenerInstance($triggerEl, "click", hideDrawer);
          } else {
            console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
          }
        } else {
          console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id"));
        }
      });
      document.querySelectorAll("[data-drawer-show]").forEach(function($triggerEl) {
        var drawerId = $triggerEl.getAttribute("data-drawer-show");
        var $drawerEl = document.getElementById(drawerId);
        if ($drawerEl) {
          var drawer_3 = instances$1.getInstance("Drawer", drawerId);
          if (drawer_3) {
            var showDrawer = function() {
              drawer_3.show();
            };
            $triggerEl.addEventListener("click", showDrawer);
            drawer_3.addEventListenerInstance($triggerEl, "click", showDrawer);
          } else {
            console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
          }
        } else {
          console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
        }
      });
    }
    if (typeof window !== "undefined") {
      window.Drawer = Drawer;
      window.initDrawers = initDrawers;
    }
    var __assign$6 = function() {
      __assign$6 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$6.apply(this, arguments);
    };
    var Default$6 = {
      defaultTabId: null,
      activeClasses: "text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-500 border-blue-600 dark:border-blue-500",
      inactiveClasses: "dark:border-transparent text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300",
      onShow: function() {
      }
    };
    var DefaultInstanceOptions$6 = {
      id: null,
      override: true
    };
    var Tabs = (
      /** @class */
      function() {
        function Tabs2(tabsEl, items, options, instanceOptions) {
          if (tabsEl === void 0) {
            tabsEl = null;
          }
          if (items === void 0) {
            items = [];
          }
          if (options === void 0) {
            options = Default$6;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$6;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : tabsEl.id;
          this._tabsEl = tabsEl;
          this._items = items;
          this._activeTab = options ? this.getTab(options.defaultTabId) : null;
          this._options = __assign$6(__assign$6({}, Default$6), options);
          this._initialized = false;
          this.init();
          instances$1.addInstance("Tabs", this, this._instanceId, instanceOptions.override);
        }
        Tabs2.prototype.init = function() {
          var _this = this;
          if (this._items.length && !this._initialized) {
            if (!this._activeTab) {
              this.setActiveTab(this._items[0]);
            }
            this.show(this._activeTab.id, true);
            this._items.map(function(tab) {
              tab.triggerEl.addEventListener("click", function(event) {
                event.preventDefault();
                _this.show(tab.id);
              });
            });
          }
        };
        Tabs2.prototype.destroy = function() {
          if (this._initialized) {
            this._initialized = false;
          }
        };
        Tabs2.prototype.removeInstance = function() {
          this.destroy();
          instances$1.removeInstance("Tabs", this._instanceId);
        };
        Tabs2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Tabs2.prototype.getActiveTab = function() {
          return this._activeTab;
        };
        Tabs2.prototype.setActiveTab = function(tab) {
          this._activeTab = tab;
        };
        Tabs2.prototype.getTab = function(id) {
          return this._items.filter(function(t) {
            return t.id === id;
          })[0];
        };
        Tabs2.prototype.show = function(id, forceShow) {
          var _a2, _b2;
          var _this = this;
          if (forceShow === void 0) {
            forceShow = false;
          }
          var tab = this.getTab(id);
          if (tab === this._activeTab && !forceShow) {
            return;
          }
          this._items.map(function(t) {
            var _a3, _b3;
            if (t !== tab) {
              (_a3 = t.triggerEl.classList).remove.apply(_a3, _this._options.activeClasses.split(" "));
              (_b3 = t.triggerEl.classList).add.apply(_b3, _this._options.inactiveClasses.split(" "));
              t.targetEl.classList.add("hidden");
              t.triggerEl.setAttribute("aria-selected", "false");
            }
          });
          (_a2 = tab.triggerEl.classList).add.apply(_a2, this._options.activeClasses.split(" "));
          (_b2 = tab.triggerEl.classList).remove.apply(_b2, this._options.inactiveClasses.split(" "));
          tab.triggerEl.setAttribute("aria-selected", "true");
          tab.targetEl.classList.remove("hidden");
          this.setActiveTab(tab);
          this._options.onShow(this, tab);
        };
        Tabs2.prototype.updateOnShow = function(callback2) {
          this._options.onShow = callback2;
        };
        return Tabs2;
      }()
    );
    function initTabs() {
      document.querySelectorAll("[data-tabs-toggle]").forEach(function($parentEl) {
        var tabItems = [];
        var activeClasses = $parentEl.getAttribute("data-tabs-active-classes");
        var inactiveClasses = $parentEl.getAttribute("data-tabs-inactive-classes");
        var defaultTabId = null;
        $parentEl.querySelectorAll('[role="tab"]').forEach(function($triggerEl) {
          var isActive = $triggerEl.getAttribute("aria-selected") === "true";
          var tab = {
            id: $triggerEl.getAttribute("data-tabs-target"),
            triggerEl: $triggerEl,
            targetEl: document.querySelector($triggerEl.getAttribute("data-tabs-target"))
          };
          tabItems.push(tab);
          if (isActive) {
            defaultTabId = tab.id;
          }
        });
        new Tabs($parentEl, tabItems, {
          defaultTabId,
          activeClasses: activeClasses ? activeClasses : Default$6.activeClasses,
          inactiveClasses: inactiveClasses ? inactiveClasses : Default$6.inactiveClasses
        });
      });
    }
    if (typeof window !== "undefined") {
      window.Tabs = Tabs;
      window.initTabs = initTabs;
    }
    var __assign$5 = function() {
      __assign$5 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$5.apply(this, arguments);
    };
    var __spreadArray$1 = function(to2, from2, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
      return to2.concat(ar || Array.prototype.slice.call(from2));
    };
    var Default$5 = {
      placement: "top",
      triggerType: "hover",
      onShow: function() {
      },
      onHide: function() {
      },
      onToggle: function() {
      }
    };
    var DefaultInstanceOptions$5 = {
      id: null,
      override: true
    };
    var Tooltip$1 = (
      /** @class */
      function() {
        function Tooltip2(targetEl, triggerEl, options, instanceOptions) {
          if (targetEl === void 0) {
            targetEl = null;
          }
          if (triggerEl === void 0) {
            triggerEl = null;
          }
          if (options === void 0) {
            options = Default$5;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$5;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
          this._targetEl = targetEl;
          this._triggerEl = triggerEl;
          this._options = __assign$5(__assign$5({}, Default$5), options);
          this._popperInstance = null;
          this._visible = false;
          this._initialized = false;
          this.init();
          instances$1.addInstance("Tooltip", this, this._instanceId, instanceOptions.override);
        }
        Tooltip2.prototype.init = function() {
          if (this._triggerEl && this._targetEl && !this._initialized) {
            this._setupEventListeners();
            this._popperInstance = this._createPopperInstance();
            this._initialized = true;
          }
        };
        Tooltip2.prototype.destroy = function() {
          var _this = this;
          if (this._initialized) {
            var triggerEvents = this._getTriggerEvents();
            triggerEvents.showEvents.forEach(function(ev) {
              _this._triggerEl.removeEventListener(ev, _this._showHandler);
            });
            triggerEvents.hideEvents.forEach(function(ev) {
              _this._triggerEl.removeEventListener(ev, _this._hideHandler);
            });
            this._removeKeydownListener();
            this._removeClickOutsideListener();
            if (this._popperInstance) {
              this._popperInstance.destroy();
            }
            this._initialized = false;
          }
        };
        Tooltip2.prototype.removeInstance = function() {
          instances$1.removeInstance("Tooltip", this._instanceId);
        };
        Tooltip2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Tooltip2.prototype._setupEventListeners = function() {
          var _this = this;
          var triggerEvents = this._getTriggerEvents();
          this._showHandler = function() {
            _this.show();
          };
          this._hideHandler = function() {
            _this.hide();
          };
          triggerEvents.showEvents.forEach(function(ev) {
            _this._triggerEl.addEventListener(ev, _this._showHandler);
          });
          triggerEvents.hideEvents.forEach(function(ev) {
            _this._triggerEl.addEventListener(ev, _this._hideHandler);
          });
        };
        Tooltip2.prototype._createPopperInstance = function() {
          return createPopper(this._triggerEl, this._targetEl, {
            placement: this._options.placement,
            modifiers: [
              {
                name: "offset",
                options: {
                  offset: [0, 8]
                }
              }
            ]
          });
        };
        Tooltip2.prototype._getTriggerEvents = function() {
          switch (this._options.triggerType) {
            case "hover":
              return {
                showEvents: ["mouseenter", "focus"],
                hideEvents: ["mouseleave", "blur"]
              };
            case "click":
              return {
                showEvents: ["click", "focus"],
                hideEvents: ["focusout", "blur"]
              };
            case "none":
              return {
                showEvents: [],
                hideEvents: []
              };
            default:
              return {
                showEvents: ["mouseenter", "focus"],
                hideEvents: ["mouseleave", "blur"]
              };
          }
        };
        Tooltip2.prototype._setupKeydownListener = function() {
          var _this = this;
          this._keydownEventListener = function(ev) {
            if (ev.key === "Escape") {
              _this.hide();
            }
          };
          document.body.addEventListener("keydown", this._keydownEventListener, true);
        };
        Tooltip2.prototype._removeKeydownListener = function() {
          document.body.removeEventListener("keydown", this._keydownEventListener, true);
        };
        Tooltip2.prototype._setupClickOutsideListener = function() {
          var _this = this;
          this._clickOutsideEventListener = function(ev) {
            _this._handleClickOutside(ev, _this._targetEl);
          };
          document.body.addEventListener("click", this._clickOutsideEventListener, true);
        };
        Tooltip2.prototype._removeClickOutsideListener = function() {
          document.body.removeEventListener("click", this._clickOutsideEventListener, true);
        };
        Tooltip2.prototype._handleClickOutside = function(ev, targetEl) {
          var clickedEl = ev.target;
          if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
            this.hide();
          }
        };
        Tooltip2.prototype.isVisible = function() {
          return this._visible;
        };
        Tooltip2.prototype.toggle = function() {
          if (this.isVisible()) {
            this.hide();
          } else {
            this.show();
          }
        };
        Tooltip2.prototype.show = function() {
          this._targetEl.classList.remove("opacity-0", "invisible");
          this._targetEl.classList.add("opacity-100", "visible");
          this._popperInstance.setOptions(function(options) {
            return __assign$5(__assign$5({}, options), { modifiers: __spreadArray$1(__spreadArray$1([], options.modifiers, true), [
              { name: "eventListeners", enabled: true }
            ], false) });
          });
          this._setupClickOutsideListener();
          this._setupKeydownListener();
          this._popperInstance.update();
          this._visible = true;
          this._options.onShow(this);
        };
        Tooltip2.prototype.hide = function() {
          this._targetEl.classList.remove("opacity-100", "visible");
          this._targetEl.classList.add("opacity-0", "invisible");
          this._popperInstance.setOptions(function(options) {
            return __assign$5(__assign$5({}, options), { modifiers: __spreadArray$1(__spreadArray$1([], options.modifiers, true), [
              { name: "eventListeners", enabled: false }
            ], false) });
          });
          this._removeClickOutsideListener();
          this._removeKeydownListener();
          this._visible = false;
          this._options.onHide(this);
        };
        Tooltip2.prototype.updateOnShow = function(callback2) {
          this._options.onShow = callback2;
        };
        Tooltip2.prototype.updateOnHide = function(callback2) {
          this._options.onHide = callback2;
        };
        Tooltip2.prototype.updateOnToggle = function(callback2) {
          this._options.onToggle = callback2;
        };
        return Tooltip2;
      }()
    );
    function initTooltips() {
      document.querySelectorAll("[data-tooltip-target]").forEach(function($triggerEl) {
        var tooltipId = $triggerEl.getAttribute("data-tooltip-target");
        var $tooltipEl = document.getElementById(tooltipId);
        if ($tooltipEl) {
          var triggerType = $triggerEl.getAttribute("data-tooltip-trigger");
          var placement = $triggerEl.getAttribute("data-tooltip-placement");
          new Tooltip$1($tooltipEl, $triggerEl, {
            placement: placement ? placement : Default$5.placement,
            triggerType: triggerType ? triggerType : Default$5.triggerType
          });
        } else {
          console.error('The tooltip element with id "'.concat(tooltipId, '" does not exist. Please check the data-tooltip-target attribute.'));
        }
      });
    }
    if (typeof window !== "undefined") {
      window.Tooltip = Tooltip$1;
      window.initTooltips = initTooltips;
    }
    var __assign$4 = function() {
      __assign$4 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$4.apply(this, arguments);
    };
    var __spreadArray = function(to2, from2, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
      return to2.concat(ar || Array.prototype.slice.call(from2));
    };
    var Default$4 = {
      placement: "top",
      offset: 10,
      triggerType: "hover",
      onShow: function() {
      },
      onHide: function() {
      },
      onToggle: function() {
      }
    };
    var DefaultInstanceOptions$4 = {
      id: null,
      override: true
    };
    var Popover = (
      /** @class */
      function() {
        function Popover2(targetEl, triggerEl, options, instanceOptions) {
          if (targetEl === void 0) {
            targetEl = null;
          }
          if (triggerEl === void 0) {
            triggerEl = null;
          }
          if (options === void 0) {
            options = Default$4;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$4;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
          this._targetEl = targetEl;
          this._triggerEl = triggerEl;
          this._options = __assign$4(__assign$4({}, Default$4), options);
          this._popperInstance = null;
          this._visible = false;
          this._initialized = false;
          this.init();
          instances$1.addInstance("Popover", this, instanceOptions.id ? instanceOptions.id : this._targetEl.id, instanceOptions.override);
        }
        Popover2.prototype.init = function() {
          if (this._triggerEl && this._targetEl && !this._initialized) {
            this._setupEventListeners();
            this._popperInstance = this._createPopperInstance();
            this._initialized = true;
          }
        };
        Popover2.prototype.destroy = function() {
          var _this = this;
          if (this._initialized) {
            var triggerEvents = this._getTriggerEvents();
            triggerEvents.showEvents.forEach(function(ev) {
              _this._triggerEl.removeEventListener(ev, _this._showHandler);
              _this._targetEl.removeEventListener(ev, _this._showHandler);
            });
            triggerEvents.hideEvents.forEach(function(ev) {
              _this._triggerEl.removeEventListener(ev, _this._hideHandler);
              _this._targetEl.removeEventListener(ev, _this._hideHandler);
            });
            this._removeKeydownListener();
            this._removeClickOutsideListener();
            if (this._popperInstance) {
              this._popperInstance.destroy();
            }
            this._initialized = false;
          }
        };
        Popover2.prototype.removeInstance = function() {
          instances$1.removeInstance("Popover", this._instanceId);
        };
        Popover2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Popover2.prototype._setupEventListeners = function() {
          var _this = this;
          var triggerEvents = this._getTriggerEvents();
          this._showHandler = function() {
            _this.show();
          };
          this._hideHandler = function() {
            setTimeout(function() {
              if (!_this._targetEl.matches(":hover")) {
                _this.hide();
              }
            }, 100);
          };
          triggerEvents.showEvents.forEach(function(ev) {
            _this._triggerEl.addEventListener(ev, _this._showHandler);
            _this._targetEl.addEventListener(ev, _this._showHandler);
          });
          triggerEvents.hideEvents.forEach(function(ev) {
            _this._triggerEl.addEventListener(ev, _this._hideHandler);
            _this._targetEl.addEventListener(ev, _this._hideHandler);
          });
        };
        Popover2.prototype._createPopperInstance = function() {
          return createPopper(this._triggerEl, this._targetEl, {
            placement: this._options.placement,
            modifiers: [
              {
                name: "offset",
                options: {
                  offset: [0, this._options.offset]
                }
              }
            ]
          });
        };
        Popover2.prototype._getTriggerEvents = function() {
          switch (this._options.triggerType) {
            case "hover":
              return {
                showEvents: ["mouseenter", "focus"],
                hideEvents: ["mouseleave", "blur"]
              };
            case "click":
              return {
                showEvents: ["click", "focus"],
                hideEvents: ["focusout", "blur"]
              };
            case "none":
              return {
                showEvents: [],
                hideEvents: []
              };
            default:
              return {
                showEvents: ["mouseenter", "focus"],
                hideEvents: ["mouseleave", "blur"]
              };
          }
        };
        Popover2.prototype._setupKeydownListener = function() {
          var _this = this;
          this._keydownEventListener = function(ev) {
            if (ev.key === "Escape") {
              _this.hide();
            }
          };
          document.body.addEventListener("keydown", this._keydownEventListener, true);
        };
        Popover2.prototype._removeKeydownListener = function() {
          document.body.removeEventListener("keydown", this._keydownEventListener, true);
        };
        Popover2.prototype._setupClickOutsideListener = function() {
          var _this = this;
          this._clickOutsideEventListener = function(ev) {
            _this._handleClickOutside(ev, _this._targetEl);
          };
          document.body.addEventListener("click", this._clickOutsideEventListener, true);
        };
        Popover2.prototype._removeClickOutsideListener = function() {
          document.body.removeEventListener("click", this._clickOutsideEventListener, true);
        };
        Popover2.prototype._handleClickOutside = function(ev, targetEl) {
          var clickedEl = ev.target;
          if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
            this.hide();
          }
        };
        Popover2.prototype.isVisible = function() {
          return this._visible;
        };
        Popover2.prototype.toggle = function() {
          if (this.isVisible()) {
            this.hide();
          } else {
            this.show();
          }
          this._options.onToggle(this);
        };
        Popover2.prototype.show = function() {
          this._targetEl.classList.remove("opacity-0", "invisible");
          this._targetEl.classList.add("opacity-100", "visible");
          this._popperInstance.setOptions(function(options) {
            return __assign$4(__assign$4({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
              { name: "eventListeners", enabled: true }
            ], false) });
          });
          this._setupClickOutsideListener();
          this._setupKeydownListener();
          this._popperInstance.update();
          this._visible = true;
          this._options.onShow(this);
        };
        Popover2.prototype.hide = function() {
          this._targetEl.classList.remove("opacity-100", "visible");
          this._targetEl.classList.add("opacity-0", "invisible");
          this._popperInstance.setOptions(function(options) {
            return __assign$4(__assign$4({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
              { name: "eventListeners", enabled: false }
            ], false) });
          });
          this._removeClickOutsideListener();
          this._removeKeydownListener();
          this._visible = false;
          this._options.onHide(this);
        };
        Popover2.prototype.updateOnShow = function(callback2) {
          this._options.onShow = callback2;
        };
        Popover2.prototype.updateOnHide = function(callback2) {
          this._options.onHide = callback2;
        };
        Popover2.prototype.updateOnToggle = function(callback2) {
          this._options.onToggle = callback2;
        };
        return Popover2;
      }()
    );
    function initPopovers() {
      document.querySelectorAll("[data-popover-target]").forEach(function($triggerEl) {
        var popoverID = $triggerEl.getAttribute("data-popover-target");
        var $popoverEl = document.getElementById(popoverID);
        if ($popoverEl) {
          var triggerType = $triggerEl.getAttribute("data-popover-trigger");
          var placement = $triggerEl.getAttribute("data-popover-placement");
          var offset2 = $triggerEl.getAttribute("data-popover-offset");
          new Popover($popoverEl, $triggerEl, {
            placement: placement ? placement : Default$4.placement,
            offset: offset2 ? parseInt(offset2) : Default$4.offset,
            triggerType: triggerType ? triggerType : Default$4.triggerType
          });
        } else {
          console.error('The popover element with id "'.concat(popoverID, '" does not exist. Please check the data-popover-target attribute.'));
        }
      });
    }
    if (typeof window !== "undefined") {
      window.Popover = Popover;
      window.initPopovers = initPopovers;
    }
    var __assign$3 = function() {
      __assign$3 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$3.apply(this, arguments);
    };
    var Default$3 = {
      triggerType: "hover",
      onShow: function() {
      },
      onHide: function() {
      },
      onToggle: function() {
      }
    };
    var DefaultInstanceOptions$3 = {
      id: null,
      override: true
    };
    var Dial = (
      /** @class */
      function() {
        function Dial2(parentEl, triggerEl, targetEl, options, instanceOptions) {
          if (parentEl === void 0) {
            parentEl = null;
          }
          if (triggerEl === void 0) {
            triggerEl = null;
          }
          if (targetEl === void 0) {
            targetEl = null;
          }
          if (options === void 0) {
            options = Default$3;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$3;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
          this._parentEl = parentEl;
          this._triggerEl = triggerEl;
          this._targetEl = targetEl;
          this._options = __assign$3(__assign$3({}, Default$3), options);
          this._visible = false;
          this._initialized = false;
          this.init();
          instances$1.addInstance("Dial", this, this._instanceId, instanceOptions.override);
        }
        Dial2.prototype.init = function() {
          var _this = this;
          if (this._triggerEl && this._targetEl && !this._initialized) {
            var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
            this._showEventHandler = function() {
              _this.show();
            };
            triggerEventTypes.showEvents.forEach(function(ev) {
              _this._triggerEl.addEventListener(ev, _this._showEventHandler);
              _this._targetEl.addEventListener(ev, _this._showEventHandler);
            });
            this._hideEventHandler = function() {
              if (!_this._parentEl.matches(":hover")) {
                _this.hide();
              }
            };
            triggerEventTypes.hideEvents.forEach(function(ev) {
              _this._parentEl.addEventListener(ev, _this._hideEventHandler);
            });
            this._initialized = true;
          }
        };
        Dial2.prototype.destroy = function() {
          var _this = this;
          if (this._initialized) {
            var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
            triggerEventTypes.showEvents.forEach(function(ev) {
              _this._triggerEl.removeEventListener(ev, _this._showEventHandler);
              _this._targetEl.removeEventListener(ev, _this._showEventHandler);
            });
            triggerEventTypes.hideEvents.forEach(function(ev) {
              _this._parentEl.removeEventListener(ev, _this._hideEventHandler);
            });
            this._initialized = false;
          }
        };
        Dial2.prototype.removeInstance = function() {
          instances$1.removeInstance("Dial", this._instanceId);
        };
        Dial2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Dial2.prototype.hide = function() {
          this._targetEl.classList.add("hidden");
          if (this._triggerEl) {
            this._triggerEl.setAttribute("aria-expanded", "false");
          }
          this._visible = false;
          this._options.onHide(this);
        };
        Dial2.prototype.show = function() {
          this._targetEl.classList.remove("hidden");
          if (this._triggerEl) {
            this._triggerEl.setAttribute("aria-expanded", "true");
          }
          this._visible = true;
          this._options.onShow(this);
        };
        Dial2.prototype.toggle = function() {
          if (this._visible) {
            this.hide();
          } else {
            this.show();
          }
        };
        Dial2.prototype.isHidden = function() {
          return !this._visible;
        };
        Dial2.prototype.isVisible = function() {
          return this._visible;
        };
        Dial2.prototype._getTriggerEventTypes = function(triggerType) {
          switch (triggerType) {
            case "hover":
              return {
                showEvents: ["mouseenter", "focus"],
                hideEvents: ["mouseleave", "blur"]
              };
            case "click":
              return {
                showEvents: ["click", "focus"],
                hideEvents: ["focusout", "blur"]
              };
            case "none":
              return {
                showEvents: [],
                hideEvents: []
              };
            default:
              return {
                showEvents: ["mouseenter", "focus"],
                hideEvents: ["mouseleave", "blur"]
              };
          }
        };
        Dial2.prototype.updateOnShow = function(callback2) {
          this._options.onShow = callback2;
        };
        Dial2.prototype.updateOnHide = function(callback2) {
          this._options.onHide = callback2;
        };
        Dial2.prototype.updateOnToggle = function(callback2) {
          this._options.onToggle = callback2;
        };
        return Dial2;
      }()
    );
    function initDials() {
      document.querySelectorAll("[data-dial-init]").forEach(function($parentEl) {
        var $triggerEl = $parentEl.querySelector("[data-dial-toggle]");
        if ($triggerEl) {
          var dialId = $triggerEl.getAttribute("data-dial-toggle");
          var $dialEl = document.getElementById(dialId);
          if ($dialEl) {
            var triggerType = $triggerEl.getAttribute("data-dial-trigger");
            new Dial($parentEl, $triggerEl, $dialEl, {
              triggerType: triggerType ? triggerType : Default$3.triggerType
            });
          } else {
            console.error("Dial with id ".concat(dialId, " does not exist. Are you sure that the data-dial-toggle attribute points to the correct modal id?"));
          }
        } else {
          console.error("Dial with id ".concat($parentEl.id, " does not have a trigger element. Are you sure that the data-dial-toggle attribute exists?"));
        }
      });
    }
    if (typeof window !== "undefined") {
      window.Dial = Dial;
      window.initDials = initDials;
    }
    var __assign$2 = function() {
      __assign$2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$2.apply(this, arguments);
    };
    var Default$2 = {
      minValue: null,
      maxValue: null,
      onIncrement: function() {
      },
      onDecrement: function() {
      }
    };
    var DefaultInstanceOptions$2 = {
      id: null,
      override: true
    };
    var InputCounter = (
      /** @class */
      function() {
        function InputCounter2(targetEl, incrementEl, decrementEl, options, instanceOptions) {
          if (targetEl === void 0) {
            targetEl = null;
          }
          if (incrementEl === void 0) {
            incrementEl = null;
          }
          if (decrementEl === void 0) {
            decrementEl = null;
          }
          if (options === void 0) {
            options = Default$2;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$2;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
          this._targetEl = targetEl;
          this._incrementEl = incrementEl;
          this._decrementEl = decrementEl;
          this._options = __assign$2(__assign$2({}, Default$2), options);
          this._initialized = false;
          this.init();
          instances$1.addInstance("InputCounter", this, this._instanceId, instanceOptions.override);
        }
        InputCounter2.prototype.init = function() {
          var _this = this;
          if (this._targetEl && !this._initialized) {
            this._inputHandler = function(event) {
              {
                var target = event.target;
                if (!/^\d*$/.test(target.value)) {
                  target.value = target.value.replace(/[^\d]/g, "");
                }
                if (_this._options.maxValue !== null && parseInt(target.value) > _this._options.maxValue) {
                  target.value = _this._options.maxValue.toString();
                }
                if (_this._options.minValue !== null && parseInt(target.value) < _this._options.minValue) {
                  target.value = _this._options.minValue.toString();
                }
              }
            };
            this._incrementClickHandler = function() {
              _this.increment();
            };
            this._decrementClickHandler = function() {
              _this.decrement();
            };
            this._targetEl.addEventListener("input", this._inputHandler);
            if (this._incrementEl) {
              this._incrementEl.addEventListener("click", this._incrementClickHandler);
            }
            if (this._decrementEl) {
              this._decrementEl.addEventListener("click", this._decrementClickHandler);
            }
            this._initialized = true;
          }
        };
        InputCounter2.prototype.destroy = function() {
          if (this._targetEl && this._initialized) {
            this._targetEl.removeEventListener("input", this._inputHandler);
            if (this._incrementEl) {
              this._incrementEl.removeEventListener("click", this._incrementClickHandler);
            }
            if (this._decrementEl) {
              this._decrementEl.removeEventListener("click", this._decrementClickHandler);
            }
            this._initialized = false;
          }
        };
        InputCounter2.prototype.removeInstance = function() {
          instances$1.removeInstance("InputCounter", this._instanceId);
        };
        InputCounter2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        InputCounter2.prototype.getCurrentValue = function() {
          return parseInt(this._targetEl.value) || 0;
        };
        InputCounter2.prototype.increment = function() {
          if (this._options.maxValue !== null && this.getCurrentValue() >= this._options.maxValue) {
            return;
          }
          this._targetEl.value = (this.getCurrentValue() + 1).toString();
          this._options.onIncrement(this);
        };
        InputCounter2.prototype.decrement = function() {
          if (this._options.minValue !== null && this.getCurrentValue() <= this._options.minValue) {
            return;
          }
          this._targetEl.value = (this.getCurrentValue() - 1).toString();
          this._options.onDecrement(this);
        };
        InputCounter2.prototype.updateOnIncrement = function(callback2) {
          this._options.onIncrement = callback2;
        };
        InputCounter2.prototype.updateOnDecrement = function(callback2) {
          this._options.onDecrement = callback2;
        };
        return InputCounter2;
      }()
    );
    function initInputCounters() {
      document.querySelectorAll("[data-input-counter]").forEach(function($targetEl) {
        var targetId = $targetEl.id;
        var $incrementEl = document.querySelector('[data-input-counter-increment="' + targetId + '"]');
        var $decrementEl = document.querySelector('[data-input-counter-decrement="' + targetId + '"]');
        var minValue = $targetEl.getAttribute("data-input-counter-min");
        var maxValue = $targetEl.getAttribute("data-input-counter-max");
        if ($targetEl) {
          if (!instances$1.instanceExists("InputCounter", $targetEl.getAttribute("id"))) {
            new InputCounter($targetEl, $incrementEl ? $incrementEl : null, $decrementEl ? $decrementEl : null, {
              minValue: minValue ? parseInt(minValue) : null,
              maxValue: maxValue ? parseInt(maxValue) : null
            });
          }
        } else {
          console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-input-counter attribute.'));
        }
      });
    }
    if (typeof window !== "undefined") {
      window.InputCounter = InputCounter;
      window.initInputCounters = initInputCounters;
    }
    var __assign$1 = function() {
      __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign$1.apply(this, arguments);
    };
    var Default$1 = {
      htmlEntities: false,
      contentType: "input",
      onCopy: function() {
      }
    };
    var DefaultInstanceOptions$1 = {
      id: null,
      override: true
    };
    var CopyClipboard = (
      /** @class */
      function() {
        function CopyClipboard2(triggerEl, targetEl, options, instanceOptions) {
          if (triggerEl === void 0) {
            triggerEl = null;
          }
          if (targetEl === void 0) {
            targetEl = null;
          }
          if (options === void 0) {
            options = Default$1;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions$1;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
          this._triggerEl = triggerEl;
          this._targetEl = targetEl;
          this._options = __assign$1(__assign$1({}, Default$1), options);
          this._initialized = false;
          this.init();
          instances$1.addInstance("CopyClipboard", this, this._instanceId, instanceOptions.override);
        }
        CopyClipboard2.prototype.init = function() {
          var _this = this;
          if (this._targetEl && this._triggerEl && !this._initialized) {
            this._triggerElClickHandler = function() {
              _this.copy();
            };
            if (this._triggerEl) {
              this._triggerEl.addEventListener("click", this._triggerElClickHandler);
            }
            this._initialized = true;
          }
        };
        CopyClipboard2.prototype.destroy = function() {
          if (this._triggerEl && this._targetEl && this._initialized) {
            if (this._triggerEl) {
              this._triggerEl.removeEventListener("click", this._triggerElClickHandler);
            }
            this._initialized = false;
          }
        };
        CopyClipboard2.prototype.removeInstance = function() {
          instances$1.removeInstance("CopyClipboard", this._instanceId);
        };
        CopyClipboard2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        CopyClipboard2.prototype.getTargetValue = function() {
          if (this._options.contentType === "input") {
            return this._targetEl.value;
          }
          if (this._options.contentType === "innerHTML") {
            return this._targetEl.innerHTML;
          }
          if (this._options.contentType === "textContent") {
            return this._targetEl.textContent.replace(/\s+/g, " ").trim();
          }
        };
        CopyClipboard2.prototype.copy = function() {
          var textToCopy = this.getTargetValue();
          if (this._options.htmlEntities) {
            textToCopy = this.decodeHTML(textToCopy);
          }
          var tempTextArea = document.createElement("textarea");
          tempTextArea.value = textToCopy;
          document.body.appendChild(tempTextArea);
          tempTextArea.select();
          document.execCommand("copy");
          document.body.removeChild(tempTextArea);
          this._options.onCopy(this);
          return textToCopy;
        };
        CopyClipboard2.prototype.decodeHTML = function(html) {
          var textarea = document.createElement("textarea");
          textarea.innerHTML = html;
          return textarea.textContent;
        };
        CopyClipboard2.prototype.updateOnCopyCallback = function(callback2) {
          this._options.onCopy = callback2;
        };
        return CopyClipboard2;
      }()
    );
    function initCopyClipboards() {
      document.querySelectorAll("[data-copy-to-clipboard-target]").forEach(function($triggerEl) {
        var targetId = $triggerEl.getAttribute("data-copy-to-clipboard-target");
        var $targetEl = document.getElementById(targetId);
        var contentType = $triggerEl.getAttribute("data-copy-to-clipboard-content-type");
        var htmlEntities = $triggerEl.getAttribute("data-copy-to-clipboard-html-entities");
        if ($targetEl) {
          if (!instances$1.instanceExists("CopyClipboard", $targetEl.getAttribute("id"))) {
            new CopyClipboard($triggerEl, $targetEl, {
              htmlEntities: htmlEntities && htmlEntities === "true" ? true : Default$1.htmlEntities,
              contentType: contentType ? contentType : Default$1.contentType
            });
          }
        } else {
          console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-copy-to-clipboard-target attribute.'));
        }
      });
    }
    if (typeof window !== "undefined") {
      window.CopyClipboard = CopyClipboard;
      window.initClipboards = initCopyClipboards;
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: false
      }), e;
    }
    function _get() {
      return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
        var p = _superPropBase(e, t);
        if (p) {
          var n = Object.getOwnPropertyDescriptor(p, t);
          return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
        }
      }, _get.apply(null, arguments);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: true,
          configurable: true
        }
      }), Object.defineProperty(t, "prototype", {
        writable: false
      }), e && _setPrototypeOf(t, e);
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function() {
        return !!t;
      })();
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == typeof e || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _superPropBase(t, o) {
      for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
      return t;
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _toPrimitive(t, r) {
      if ("object" != typeof t || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r);
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(t);
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == typeof i ? i : i + "";
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function hasProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function lastItemOf(arr) {
      return arr[arr.length - 1];
    }
    function pushUnique(arr) {
      for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        items[_key - 1] = arguments[_key];
      }
      items.forEach(function(item) {
        if (arr.includes(item)) {
          return;
        }
        arr.push(item);
      });
      return arr;
    }
    function stringToArray(str, separator) {
      return str ? str.split(separator) : [];
    }
    function isInRange(testVal, min2, max2) {
      var minOK = min2 === void 0 || testVal >= min2;
      var maxOK = max2 === void 0 || testVal <= max2;
      return minOK && maxOK;
    }
    function limitToRange(val, min2, max2) {
      if (val < min2) {
        return min2;
      }
      if (val > max2) {
        return max2;
      }
      return val;
    }
    function createTagRepeat(tagName, repeat) {
      var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var html = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "";
      var openTagSrc = Object.keys(attributes).reduce(function(src2, attr) {
        var val = attributes[attr];
        if (typeof val === "function") {
          val = val(index2);
        }
        return "".concat(src2, " ").concat(attr, '="').concat(val, '"');
      }, tagName);
      html += "<".concat(openTagSrc, "></").concat(tagName, ">");
      var next = index2 + 1;
      return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;
    }
    function optimizeTemplateHTML(html) {
      return html.replace(/>\s+/g, ">").replace(/\s+</, "<");
    }
    function stripTime(timeValue) {
      return new Date(timeValue).setHours(0, 0, 0, 0);
    }
    function today() {
      return (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
    }
    function dateValue() {
      switch (arguments.length) {
        case 0:
          return today();
        case 1:
          return stripTime(arguments.length <= 0 ? void 0 : arguments[0]);
      }
      var newDate = /* @__PURE__ */ new Date(0);
      newDate.setFullYear.apply(newDate, arguments);
      return newDate.setHours(0, 0, 0, 0);
    }
    function addDays(date, amount) {
      var newDate = new Date(date);
      return newDate.setDate(newDate.getDate() + amount);
    }
    function addWeeks(date, amount) {
      return addDays(date, amount * 7);
    }
    function addMonths(date, amount) {
      var newDate = new Date(date);
      var monthsToSet = newDate.getMonth() + amount;
      var expectedMonth = monthsToSet % 12;
      if (expectedMonth < 0) {
        expectedMonth += 12;
      }
      var time = newDate.setMonth(monthsToSet);
      return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
    }
    function addYears(date, amount) {
      var newDate = new Date(date);
      var expectedMonth = newDate.getMonth();
      var time = newDate.setFullYear(newDate.getFullYear() + amount);
      return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
    }
    function dayDiff(day, from2) {
      return (day - from2 + 7) % 7;
    }
    function dayOfTheWeekOf(baseDate, dayOfWeek) {
      var weekStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var baseDay = new Date(baseDate).getDay();
      return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
    }
    function getWeek(date) {
      var thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);
      var firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
      return Math.round((thuOfTheWeek - firstThu) / 6048e5) + 1;
    }
    function startOfYearPeriod(date, years2) {
      var year = new Date(date).getFullYear();
      return Math.floor(year / years2) * years2;
    }
    var reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
    var reNonDateParts = /[\s!-/:-@[-`{-~]+/;
    var knownFormats = {};
    var parseFns = {
      y: function y(date, year) {
        return new Date(date).setFullYear(parseInt(year, 10));
      },
      m: function m(date, month, locale2) {
        var newDate = new Date(date);
        var monthIndex = parseInt(month, 10) - 1;
        if (isNaN(monthIndex)) {
          if (!month) {
            return NaN;
          }
          var monthName = month.toLowerCase();
          var compareNames = function compareNames2(name) {
            return name.toLowerCase().startsWith(monthName);
          };
          monthIndex = locale2.monthsShort.findIndex(compareNames);
          if (monthIndex < 0) {
            monthIndex = locale2.months.findIndex(compareNames);
          }
          if (monthIndex < 0) {
            return NaN;
          }
        }
        newDate.setMonth(monthIndex);
        return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();
      },
      d: function d(date, day) {
        return new Date(date).setDate(parseInt(day, 10));
      }
    };
    var formatFns = {
      d: function d(date) {
        return date.getDate();
      },
      dd: function dd(date) {
        return padZero(date.getDate(), 2);
      },
      D: function D(date, locale2) {
        return locale2.daysShort[date.getDay()];
      },
      DD: function DD(date, locale2) {
        return locale2.days[date.getDay()];
      },
      m: function m(date) {
        return date.getMonth() + 1;
      },
      mm: function mm(date) {
        return padZero(date.getMonth() + 1, 2);
      },
      M: function M(date, locale2) {
        return locale2.monthsShort[date.getMonth()];
      },
      MM: function MM(date, locale2) {
        return locale2.months[date.getMonth()];
      },
      y: function y(date) {
        return date.getFullYear();
      },
      yy: function yy(date) {
        return padZero(date.getFullYear(), 2).slice(-2);
      },
      yyyy: function yyyy(date) {
        return padZero(date.getFullYear(), 4);
      }
    };
    function normalizeMonth(monthIndex) {
      return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
    }
    function padZero(num, length) {
      return num.toString().padStart(length, "0");
    }
    function parseFormatString(format2) {
      if (typeof format2 !== "string") {
        throw new Error("Invalid date format.");
      }
      if (format2 in knownFormats) {
        return knownFormats[format2];
      }
      var separators = format2.split(reFormatTokens);
      var parts = format2.match(new RegExp(reFormatTokens, "g"));
      if (separators.length === 0 || !parts) {
        throw new Error("Invalid date format.");
      }
      var partFormatters = parts.map(function(token2) {
        return formatFns[token2];
      });
      var partParserKeys = Object.keys(parseFns).reduce(function(keys2, key) {
        var token2 = parts.find(function(part) {
          return part[0] !== "D" && part[0].toLowerCase() === key;
        });
        if (token2) {
          keys2.push(key);
        }
        return keys2;
      }, []);
      return knownFormats[format2] = {
        parser: function parser(dateStr, locale2) {
          var dateParts = dateStr.split(reNonDateParts).reduce(function(dtParts, part, index2) {
            if (part.length > 0 && parts[index2]) {
              var token2 = parts[index2][0];
              if (token2 === "M") {
                dtParts.m = part;
              } else if (token2 !== "D") {
                dtParts[token2] = part;
              }
            }
            return dtParts;
          }, {});
          return partParserKeys.reduce(function(origDate, key) {
            var newDate = parseFns[key](origDate, dateParts[key], locale2);
            return isNaN(newDate) ? origDate : newDate;
          }, today());
        },
        formatter: function formatter(date, locale2) {
          var dateStr = partFormatters.reduce(function(str, fn, index2) {
            return str += "".concat(separators[index2]).concat(fn(date, locale2));
          }, "");
          return dateStr += lastItemOf(separators);
        }
      };
    }
    function parseDate(dateStr, format2, locale2) {
      if (dateStr instanceof Date || typeof dateStr === "number") {
        var date = stripTime(dateStr);
        return isNaN(date) ? void 0 : date;
      }
      if (!dateStr) {
        return void 0;
      }
      if (dateStr === "today") {
        return today();
      }
      if (format2 && format2.toValue) {
        var _date = format2.toValue(dateStr, format2, locale2);
        return isNaN(_date) ? void 0 : stripTime(_date);
      }
      return parseFormatString(format2).parser(dateStr, locale2);
    }
    function formatDate(date, format2, locale2) {
      if (isNaN(date) || !date && date !== 0) {
        return "";
      }
      var dateObj = typeof date === "number" ? new Date(date) : date;
      if (format2.toDisplay) {
        return format2.toDisplay(dateObj, format2, locale2);
      }
      return parseFormatString(format2).formatter(dateObj, locale2);
    }
    var listenerRegistry = /* @__PURE__ */ new WeakMap();
    var _EventTarget$prototyp = EventTarget.prototype, addEventListener = _EventTarget$prototyp.addEventListener, removeEventListener = _EventTarget$prototyp.removeEventListener;
    function registerListeners(keyObj, listeners) {
      var registered = listenerRegistry.get(keyObj);
      if (!registered) {
        registered = [];
        listenerRegistry.set(keyObj, registered);
      }
      listeners.forEach(function(listener) {
        addEventListener.call.apply(addEventListener, _toConsumableArray(listener));
        registered.push(listener);
      });
    }
    function unregisterListeners(keyObj) {
      var listeners = listenerRegistry.get(keyObj);
      if (!listeners) {
        return;
      }
      listeners.forEach(function(listener) {
        removeEventListener.call.apply(removeEventListener, _toConsumableArray(listener));
      });
      listenerRegistry["delete"](keyObj);
    }
    if (!Event.prototype.composedPath) {
      var getComposedPath = function getComposedPath2(node) {
        var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        path.push(node);
        var parent;
        if (node.parentNode) {
          parent = node.parentNode;
        } else if (node.host) {
          parent = node.host;
        } else if (node.defaultView) {
          parent = node.defaultView;
        }
        return parent ? getComposedPath2(parent, path) : path;
      };
      Event.prototype.composedPath = function() {
        return getComposedPath(this.target);
      };
    }
    function findFromPath(path, criteria, currentTarget) {
      var index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var el = path[index2];
      if (criteria(el)) {
        return el;
      } else if (el === currentTarget || !el.parentElement) {
        return;
      }
      return findFromPath(path, criteria, currentTarget, index2 + 1);
    }
    function findElementInEventPath(ev, selector) {
      var criteria = typeof selector === "function" ? selector : function(el) {
        return el.matches(selector);
      };
      return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
    }
    var locales$1 = {
      en: {
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        today: "Today",
        clear: "Clear",
        titleFormat: "MM y"
      }
    };
    var defaultOptions = {
      autohide: false,
      beforeShowDay: null,
      beforeShowDecade: null,
      beforeShowMonth: null,
      beforeShowYear: null,
      calendarWeeks: false,
      clearBtn: false,
      dateDelimiter: ",",
      datesDisabled: [],
      daysOfWeekDisabled: [],
      daysOfWeekHighlighted: [],
      defaultViewDate: void 0,
      // placeholder, defaults to today() by the program
      disableTouchKeyboard: false,
      format: "mm/dd/yyyy",
      language: "en",
      maxDate: null,
      maxNumberOfDates: 1,
      maxView: 3,
      minDate: null,
      nextArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 5h12m0 0L9 1m4 4L9 9"/></svg>',
      orientation: "auto",
      pickLevel: 0,
      prevArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5H1m0 0 4 4M1 5l4-4"/></svg>',
      showDaysOfWeek: true,
      showOnClick: true,
      showOnFocus: true,
      startView: 0,
      title: "",
      todayBtn: false,
      todayBtnMode: 0,
      todayHighlight: false,
      updateOnBlur: true,
      weekStart: 0
    };
    var range = null;
    function parseHTML(html) {
      if (range == null) {
        range = document.createRange();
      }
      return range.createContextualFragment(html);
    }
    function hideElement(el) {
      if (el.style.display === "none") {
        return;
      }
      if (el.style.display) {
        el.dataset.styleDisplay = el.style.display;
      }
      el.style.display = "none";
    }
    function showElement(el) {
      if (el.style.display !== "none") {
        return;
      }
      if (el.dataset.styleDisplay) {
        el.style.display = el.dataset.styleDisplay;
        delete el.dataset.styleDisplay;
      } else {
        el.style.display = "";
      }
    }
    function emptyChildNodes(el) {
      if (el.firstChild) {
        el.removeChild(el.firstChild);
        emptyChildNodes(el);
      }
    }
    function replaceChildNodes(el, newChildNodes) {
      emptyChildNodes(el);
      if (newChildNodes instanceof DocumentFragment) {
        el.appendChild(newChildNodes);
      } else if (typeof newChildNodes === "string") {
        el.appendChild(parseHTML(newChildNodes));
      } else if (typeof newChildNodes.forEach === "function") {
        newChildNodes.forEach(function(node) {
          el.appendChild(node);
        });
      }
    }
    var defaultLang = defaultOptions.language, defaultFormat = defaultOptions.format, defaultWeekStart = defaultOptions.weekStart;
    function sanitizeDOW(dow, day) {
      return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;
    }
    function calcEndOfWeek(startOfWeek) {
      return (startOfWeek + 6) % 7;
    }
    function validateDate(value, format2, locale2, origValue) {
      var date = parseDate(value, format2, locale2);
      return date !== void 0 ? date : origValue;
    }
    function validateViewId(value, origValue) {
      var max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
      var viewId = parseInt(value, 10);
      return viewId >= 0 && viewId <= max2 ? viewId : origValue;
    }
    function processOptions(options, datepicker) {
      var inOpts = Object.assign({}, options);
      var config = {};
      var locales2 = datepicker.constructor.locales;
      var _ref = datepicker.config || {}, format2 = _ref.format, language = _ref.language, locale2 = _ref.locale, maxDate = _ref.maxDate, maxView = _ref.maxView, minDate = _ref.minDate, pickLevel = _ref.pickLevel, startView = _ref.startView, weekStart = _ref.weekStart;
      if (inOpts.language) {
        var lang2;
        if (inOpts.language !== language) {
          if (locales2[inOpts.language]) {
            lang2 = inOpts.language;
          } else {
            lang2 = inOpts.language.split("-")[0];
            if (locales2[lang2] === void 0) {
              lang2 = false;
            }
          }
        }
        delete inOpts.language;
        if (lang2) {
          language = config.language = lang2;
          var origLocale = locale2 || locales2[defaultLang];
          locale2 = Object.assign({
            format: defaultFormat,
            weekStart: defaultWeekStart
          }, locales2[defaultLang]);
          if (language !== defaultLang) {
            Object.assign(locale2, locales2[language]);
          }
          config.locale = locale2;
          if (format2 === origLocale.format) {
            format2 = config.format = locale2.format;
          }
          if (weekStart === origLocale.weekStart) {
            weekStart = config.weekStart = locale2.weekStart;
            config.weekEnd = calcEndOfWeek(locale2.weekStart);
          }
        }
      }
      if (inOpts.format) {
        var hasToDisplay = typeof inOpts.format.toDisplay === "function";
        var hasToValue = typeof inOpts.format.toValue === "function";
        var validFormatString = reFormatTokens.test(inOpts.format);
        if (hasToDisplay && hasToValue || validFormatString) {
          format2 = config.format = inOpts.format;
        }
        delete inOpts.format;
      }
      var minDt = minDate;
      var maxDt = maxDate;
      if (inOpts.minDate !== void 0) {
        minDt = inOpts.minDate === null ? dateValue(0, 0, 1) : validateDate(inOpts.minDate, format2, locale2, minDt);
        delete inOpts.minDate;
      }
      if (inOpts.maxDate !== void 0) {
        maxDt = inOpts.maxDate === null ? void 0 : validateDate(inOpts.maxDate, format2, locale2, maxDt);
        delete inOpts.maxDate;
      }
      if (maxDt < minDt) {
        minDate = config.minDate = maxDt;
        maxDate = config.maxDate = minDt;
      } else {
        if (minDate !== minDt) {
          minDate = config.minDate = minDt;
        }
        if (maxDate !== maxDt) {
          maxDate = config.maxDate = maxDt;
        }
      }
      if (inOpts.datesDisabled) {
        config.datesDisabled = inOpts.datesDisabled.reduce(function(dates, dt) {
          var date = parseDate(dt, format2, locale2);
          return date !== void 0 ? pushUnique(dates, date) : dates;
        }, []);
        delete inOpts.datesDisabled;
      }
      if (inOpts.defaultViewDate !== void 0) {
        var viewDate = parseDate(inOpts.defaultViewDate, format2, locale2);
        if (viewDate !== void 0) {
          config.defaultViewDate = viewDate;
        }
        delete inOpts.defaultViewDate;
      }
      if (inOpts.weekStart !== void 0) {
        var wkStart = Number(inOpts.weekStart) % 7;
        if (!isNaN(wkStart)) {
          weekStart = config.weekStart = wkStart;
          config.weekEnd = calcEndOfWeek(wkStart);
        }
        delete inOpts.weekStart;
      }
      if (inOpts.daysOfWeekDisabled) {
        config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
        delete inOpts.daysOfWeekDisabled;
      }
      if (inOpts.daysOfWeekHighlighted) {
        config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
        delete inOpts.daysOfWeekHighlighted;
      }
      if (inOpts.maxNumberOfDates !== void 0) {
        var maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
        if (maxNumberOfDates >= 0) {
          config.maxNumberOfDates = maxNumberOfDates;
          config.multidate = maxNumberOfDates !== 1;
        }
        delete inOpts.maxNumberOfDates;
      }
      if (inOpts.dateDelimiter) {
        config.dateDelimiter = String(inOpts.dateDelimiter);
        delete inOpts.dateDelimiter;
      }
      var newPickLevel = pickLevel;
      if (inOpts.pickLevel !== void 0) {
        newPickLevel = validateViewId(inOpts.pickLevel, 2);
        delete inOpts.pickLevel;
      }
      if (newPickLevel !== pickLevel) {
        pickLevel = config.pickLevel = newPickLevel;
      }
      var newMaxView = maxView;
      if (inOpts.maxView !== void 0) {
        newMaxView = validateViewId(inOpts.maxView, maxView);
        delete inOpts.maxView;
      }
      newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
      if (newMaxView !== maxView) {
        maxView = config.maxView = newMaxView;
      }
      var newStartView = startView;
      if (inOpts.startView !== void 0) {
        newStartView = validateViewId(inOpts.startView, newStartView);
        delete inOpts.startView;
      }
      if (newStartView < pickLevel) {
        newStartView = pickLevel;
      } else if (newStartView > maxView) {
        newStartView = maxView;
      }
      if (newStartView !== startView) {
        config.startView = newStartView;
      }
      if (inOpts.prevArrow) {
        var prevArrow = parseHTML(inOpts.prevArrow);
        if (prevArrow.childNodes.length > 0) {
          config.prevArrow = prevArrow.childNodes;
        }
        delete inOpts.prevArrow;
      }
      if (inOpts.nextArrow) {
        var nextArrow = parseHTML(inOpts.nextArrow);
        if (nextArrow.childNodes.length > 0) {
          config.nextArrow = nextArrow.childNodes;
        }
        delete inOpts.nextArrow;
      }
      if (inOpts.disableTouchKeyboard !== void 0) {
        config.disableTouchKeyboard = "ontouchstart" in document && !!inOpts.disableTouchKeyboard;
        delete inOpts.disableTouchKeyboard;
      }
      if (inOpts.orientation) {
        var orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
        config.orientation = {
          x: orientation.find(function(x) {
            return x === "left" || x === "right";
          }) || "auto",
          y: orientation.find(function(y) {
            return y === "top" || y === "bottom";
          }) || "auto"
        };
        delete inOpts.orientation;
      }
      if (inOpts.todayBtnMode !== void 0) {
        switch (inOpts.todayBtnMode) {
          case 0:
          case 1:
            config.todayBtnMode = inOpts.todayBtnMode;
        }
        delete inOpts.todayBtnMode;
      }
      Object.keys(inOpts).forEach(function(key) {
        if (inOpts[key] !== void 0 && hasProperty(defaultOptions, key)) {
          config[key] = inOpts[key];
        }
      });
      return config;
    }
    var pickerTemplate = optimizeTemplateHTML('<div class="datepicker hidden">\n  <div class="datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4">\n    <div class="datepicker-header">\n      <div class="datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold"></div>\n      <div class="datepicker-controls flex justify-between mb-2">\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn"></button>\n        <button type="button" class="text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch"></button>\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn"></button>\n      </div>\n    </div>\n    <div class="datepicker-main p-1"></div>\n    <div class="datepicker-footer">\n      <div class="datepicker-controls flex space-x-2 rtl:space-x-reverse mt-2">\n        <button type="button" class="%buttonClass% today-btn text-white bg-blue-700 !bg-primary-700 dark:bg-blue-600 dark:!bg-primary-600 hover:bg-blue-800 hover:!bg-primary-800 dark:hover:bg-blue-700 dark:hover:!bg-primary-700 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n        <button type="button" class="%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n      </div>\n    </div>\n  </div>\n</div>');
    var daysTemplate = optimizeTemplateHTML('<div class="days">\n  <div class="days-of-week grid grid-cols-7 mb-1">'.concat(createTagRepeat("span", 7, {
      "class": "dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
    }), '</div>\n  <div class="datepicker-grid w-64 grid grid-cols-7">').concat(createTagRepeat("span", 42, {
      "class": "block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"
    }), "</div>\n</div>"));
    var calendarWeeksTemplate = optimizeTemplateHTML('<div class="calendar-weeks">\n  <div class="days-of-week flex"><span class="dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"></span></div>\n  <div class="weeks">'.concat(createTagRepeat("span", 6, {
      "class": "week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
    }), "</div>\n</div>"));
    var View = /* @__PURE__ */ function() {
      function View2(picker, config) {
        _classCallCheck(this, View2);
        Object.assign(this, config, {
          picker,
          element: parseHTML('<div class="datepicker-view flex"></div>').firstChild,
          selected: []
        });
        this.init(this.picker.datepicker.config);
      }
      return _createClass(View2, [{
        key: "init",
        value: function init(options) {
          if (options.pickLevel !== void 0) {
            this.isMinView = this.id === options.pickLevel;
          }
          this.setOptions(options);
          this.updateFocus();
          this.updateSelection();
        }
        // Execute beforeShow() callback and apply the result to the element
        // args:
        // - current - current value on the iteration on view rendering
        // - timeValue - time value of the date to pass to beforeShow()
      }, {
        key: "performBeforeHook",
        value: function performBeforeHook(el, current, timeValue) {
          var result = this.beforeShow(new Date(timeValue));
          switch (_typeof(result)) {
            case "boolean":
              result = {
                enabled: result
              };
              break;
            case "string":
              result = {
                classes: result
              };
          }
          if (result) {
            if (result.enabled === false) {
              el.classList.add("disabled");
              pushUnique(this.disabled, current);
            }
            if (result.classes) {
              var _el$classList;
              var extraClasses = result.classes.split(/\s+/);
              (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(extraClasses));
              if (extraClasses.includes("disabled")) {
                pushUnique(this.disabled, current);
              }
            }
            if (result.content) {
              replaceChildNodes(el, result.content);
            }
          }
        }
      }]);
    }();
    var DaysView = /* @__PURE__ */ function(_View) {
      function DaysView2(picker) {
        _classCallCheck(this, DaysView2);
        return _callSuper(this, DaysView2, [picker, {
          id: 0,
          name: "days",
          cellClass: "day"
        }]);
      }
      _inherits(DaysView2, _View);
      return _createClass(DaysView2, [{
        key: "init",
        value: function init(options) {
          var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (onConstruction) {
            var inner = parseHTML(daysTemplate).firstChild;
            this.dow = inner.firstChild;
            this.grid = inner.lastChild;
            this.element.appendChild(inner);
          }
          _get(_getPrototypeOf(DaysView2.prototype), "init", this).call(this, options);
        }
      }, {
        key: "setOptions",
        value: function setOptions(options) {
          var _this = this;
          var updateDOW;
          if (hasProperty(options, "minDate")) {
            this.minDate = options.minDate;
          }
          if (hasProperty(options, "maxDate")) {
            this.maxDate = options.maxDate;
          }
          if (options.datesDisabled) {
            this.datesDisabled = options.datesDisabled;
          }
          if (options.daysOfWeekDisabled) {
            this.daysOfWeekDisabled = options.daysOfWeekDisabled;
            updateDOW = true;
          }
          if (options.daysOfWeekHighlighted) {
            this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
          }
          if (options.todayHighlight !== void 0) {
            this.todayHighlight = options.todayHighlight;
          }
          if (options.weekStart !== void 0) {
            this.weekStart = options.weekStart;
            this.weekEnd = options.weekEnd;
            updateDOW = true;
          }
          if (options.locale) {
            var locale2 = this.locale = options.locale;
            this.dayNames = locale2.daysMin;
            this.switchLabelFormat = locale2.titleFormat;
            updateDOW = true;
          }
          if (options.beforeShowDay !== void 0) {
            this.beforeShow = typeof options.beforeShowDay === "function" ? options.beforeShowDay : void 0;
          }
          if (options.calendarWeeks !== void 0) {
            if (options.calendarWeeks && !this.calendarWeeks) {
              var weeksElem = parseHTML(calendarWeeksTemplate).firstChild;
              this.calendarWeeks = {
                element: weeksElem,
                dow: weeksElem.firstChild,
                weeks: weeksElem.lastChild
              };
              this.element.insertBefore(weeksElem, this.element.firstChild);
            } else if (this.calendarWeeks && !options.calendarWeeks) {
              this.element.removeChild(this.calendarWeeks.element);
              this.calendarWeeks = null;
            }
          }
          if (options.showDaysOfWeek !== void 0) {
            if (options.showDaysOfWeek) {
              showElement(this.dow);
              if (this.calendarWeeks) {
                showElement(this.calendarWeeks.dow);
              }
            } else {
              hideElement(this.dow);
              if (this.calendarWeeks) {
                hideElement(this.calendarWeeks.dow);
              }
            }
          }
          if (updateDOW) {
            Array.from(this.dow.children).forEach(function(el, index2) {
              var dow = (_this.weekStart + index2) % 7;
              el.textContent = _this.dayNames[dow];
              el.className = _this.daysOfWeekDisabled.includes(dow) ? "dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed" : "dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400";
            });
          }
        }
        // Apply update on the focused date to view's settings
      }, {
        key: "updateFocus",
        value: function updateFocus() {
          var viewDate = new Date(this.picker.viewDate);
          var viewYear = viewDate.getFullYear();
          var viewMonth = viewDate.getMonth();
          var firstOfMonth = dateValue(viewYear, viewMonth, 1);
          var start2 = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);
          this.first = firstOfMonth;
          this.last = dateValue(viewYear, viewMonth + 1, 0);
          this.start = start2;
          this.focused = this.picker.viewDate;
        }
        // Apply update on the selected dates to view's settings
      }, {
        key: "updateSelection",
        value: function updateSelection() {
          var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
          this.selected = dates;
          if (rangepicker) {
            this.range = rangepicker.dates;
          }
        }
        // Update the entire view UI
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          this.today = this.todayHighlight ? today() : void 0;
          this.disabled = _toConsumableArray(this.datesDisabled);
          var switchLabel = formatDate(this.focused, this.switchLabelFormat, this.locale);
          this.picker.setViewSwitchLabel(switchLabel);
          this.picker.setPrevBtnDisabled(this.first <= this.minDate);
          this.picker.setNextBtnDisabled(this.last >= this.maxDate);
          if (this.calendarWeeks) {
            var startOfWeek = dayOfTheWeekOf(this.first, 1, 1);
            Array.from(this.calendarWeeks.weeks.children).forEach(function(el, index2) {
              el.textContent = getWeek(addWeeks(startOfWeek, index2));
            });
          }
          Array.from(this.grid.children).forEach(function(el, index2) {
            var classList = el.classList;
            var current = addDays(_this2.start, index2);
            var date = new Date(current);
            var day = date.getDay();
            el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
            el.dataset.date = current;
            el.textContent = date.getDate();
            if (current < _this2.first) {
              classList.add("prev", "text-gray-500", "dark:text-white");
            } else if (current > _this2.last) {
              classList.add("next", "text-gray-500", "dark:text-white");
            }
            if (_this2.today === current) {
              classList.add("today", "bg-gray-100", "dark:bg-gray-600");
            }
            if (current < _this2.minDate || current > _this2.maxDate || _this2.disabled.includes(current)) {
              classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
              classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
            }
            if (_this2.daysOfWeekDisabled.includes(day)) {
              classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
              classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
              pushUnique(_this2.disabled, current);
            }
            if (_this2.daysOfWeekHighlighted.includes(day)) {
              classList.add("highlighted");
            }
            if (_this2.range) {
              var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
              if (current > rangeStart && current < rangeEnd) {
                classList.add("range", "bg-gray-200", "dark:bg-gray-600");
                classList.remove("rounded-lg", "rounded-l-lg", "rounded-r-lg");
              }
              if (current === rangeStart) {
                classList.add("range-start", "bg-gray-100", "dark:bg-gray-600", "rounded-l-lg");
                classList.remove("rounded-lg", "rounded-r-lg");
              }
              if (current === rangeEnd) {
                classList.add("range-end", "bg-gray-100", "dark:bg-gray-600", "rounded-r-lg");
                classList.remove("rounded-lg", "rounded-l-lg");
              }
            }
            if (_this2.selected.includes(current)) {
              classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
              classList.remove("text-gray-900", "text-gray-500", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "dark:bg-gray-600", "bg-gray-100", "bg-gray-200");
            }
            if (current === _this2.focused) {
              classList.add("focused");
            }
            if (_this2.beforeShow) {
              _this2.performBeforeHook(el, current, current);
            }
          });
        }
        // Update the view UI by applying the changes of selected and focused items
      }, {
        key: "refresh",
        value: function refresh() {
          var _this3 = this;
          var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
          this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
            el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white", "focused");
            el.classList.add("text-gray-900", "rounded-lg", "dark:text-white");
          });
          Array.from(this.grid.children).forEach(function(el) {
            var current = Number(el.dataset.date);
            var classList = el.classList;
            classList.remove("bg-gray-200", "dark:bg-gray-600", "rounded-l-lg", "rounded-r-lg");
            if (current > rangeStart && current < rangeEnd) {
              classList.add("range", "bg-gray-200", "dark:bg-gray-600");
              classList.remove("rounded-lg");
            }
            if (current === rangeStart) {
              classList.add("range-start", "bg-gray-200", "dark:bg-gray-600", "rounded-l-lg");
              classList.remove("rounded-lg");
            }
            if (current === rangeEnd) {
              classList.add("range-end", "bg-gray-200", "dark:bg-gray-600", "rounded-r-lg");
              classList.remove("rounded-lg");
            }
            if (_this3.selected.includes(current)) {
              classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
              classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "bg-gray-100", "bg-gray-200", "dark:bg-gray-600");
            }
            if (current === _this3.focused) {
              classList.add("focused");
            }
          });
        }
        // Update the view UI by applying the change of focused item
      }, {
        key: "refreshFocus",
        value: function refreshFocus() {
          var index2 = Math.round((this.focused - this.start) / 864e5);
          this.grid.querySelectorAll(".focused").forEach(function(el) {
            el.classList.remove("focused");
          });
          this.grid.children[index2].classList.add("focused");
        }
      }]);
    }(View);
    function computeMonthRange(range2, thisYear) {
      if (!range2 || !range2[0] || !range2[1]) {
        return;
      }
      var _range = _slicedToArray(range2, 2), _range$ = _slicedToArray(_range[0], 2), startY = _range$[0], startM = _range$[1], _range$2 = _slicedToArray(_range[1], 2), endY = _range$2[0], endM = _range$2[1];
      if (startY > thisYear || endY < thisYear) {
        return;
      }
      return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];
    }
    var MonthsView = /* @__PURE__ */ function(_View) {
      function MonthsView2(picker) {
        _classCallCheck(this, MonthsView2);
        return _callSuper(this, MonthsView2, [picker, {
          id: 1,
          name: "months",
          cellClass: "month"
        }]);
      }
      _inherits(MonthsView2, _View);
      return _createClass(MonthsView2, [{
        key: "init",
        value: function init(options) {
          var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (onConstruction) {
            this.grid = this.element;
            this.element.classList.add("months", "datepicker-grid", "w-64", "grid", "grid-cols-4");
            this.grid.appendChild(parseHTML(createTagRepeat("span", 12, {
              "data-month": function dataMonth(ix) {
                return ix;
              }
            })));
          }
          _get(_getPrototypeOf(MonthsView2.prototype), "init", this).call(this, options);
        }
      }, {
        key: "setOptions",
        value: function setOptions(options) {
          if (options.locale) {
            this.monthNames = options.locale.monthsShort;
          }
          if (hasProperty(options, "minDate")) {
            if (options.minDate === void 0) {
              this.minYear = this.minMonth = this.minDate = void 0;
            } else {
              var minDateObj = new Date(options.minDate);
              this.minYear = minDateObj.getFullYear();
              this.minMonth = minDateObj.getMonth();
              this.minDate = minDateObj.setDate(1);
            }
          }
          if (hasProperty(options, "maxDate")) {
            if (options.maxDate === void 0) {
              this.maxYear = this.maxMonth = this.maxDate = void 0;
            } else {
              var maxDateObj = new Date(options.maxDate);
              this.maxYear = maxDateObj.getFullYear();
              this.maxMonth = maxDateObj.getMonth();
              this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);
            }
          }
          if (options.beforeShowMonth !== void 0) {
            this.beforeShow = typeof options.beforeShowMonth === "function" ? options.beforeShowMonth : void 0;
          }
        }
        // Update view's settings to reflect the viewDate set on the picker
      }, {
        key: "updateFocus",
        value: function updateFocus() {
          var viewDate = new Date(this.picker.viewDate);
          this.year = viewDate.getFullYear();
          this.focused = viewDate.getMonth();
        }
        // Update view's settings to reflect the selected dates
      }, {
        key: "updateSelection",
        value: function updateSelection() {
          var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
          this.selected = dates.reduce(function(selected, timeValue) {
            var date = new Date(timeValue);
            var year = date.getFullYear();
            var month = date.getMonth();
            if (selected[year] === void 0) {
              selected[year] = [month];
            } else {
              pushUnique(selected[year], month);
            }
            return selected;
          }, {});
          if (rangepicker && rangepicker.dates) {
            this.range = rangepicker.dates.map(function(timeValue) {
              var date = new Date(timeValue);
              return isNaN(date) ? void 0 : [date.getFullYear(), date.getMonth()];
            });
          }
        }
        // Update the entire view UI
      }, {
        key: "render",
        value: function render() {
          var _this = this;
          this.disabled = [];
          this.picker.setViewSwitchLabel(this.year);
          this.picker.setPrevBtnDisabled(this.year <= this.minYear);
          this.picker.setNextBtnDisabled(this.year >= this.maxYear);
          var selected = this.selected[this.year] || [];
          var yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
          var isMinYear = this.year === this.minYear;
          var isMaxYear = this.year === this.maxYear;
          var range2 = computeMonthRange(this.range, this.year);
          Array.from(this.grid.children).forEach(function(el, index2) {
            var classList = el.classList;
            var date = dateValue(_this.year, index2, 1);
            el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this.cellClass);
            if (_this.isMinView) {
              el.dataset.date = date;
            }
            el.textContent = _this.monthNames[index2];
            if (yrOutOfRange || isMinYear && index2 < _this.minMonth || isMaxYear && index2 > _this.maxMonth) {
              classList.add("disabled");
            }
            if (range2) {
              var _range2 = _slicedToArray(range2, 2), rangeStart = _range2[0], rangeEnd = _range2[1];
              if (index2 > rangeStart && index2 < rangeEnd) {
                classList.add("range");
              }
              if (index2 === rangeStart) {
                classList.add("range-start");
              }
              if (index2 === rangeEnd) {
                classList.add("range-end");
              }
            }
            if (selected.includes(index2)) {
              classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
              classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
            }
            if (index2 === _this.focused) {
              classList.add("focused");
            }
            if (_this.beforeShow) {
              _this.performBeforeHook(el, index2, date);
            }
          });
        }
        // Update the view UI by applying the changes of selected and focused items
      }, {
        key: "refresh",
        value: function refresh() {
          var _this2 = this;
          var selected = this.selected[this.year] || [];
          var _ref = computeMonthRange(this.range, this.year) || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
          this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
            el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "dark:bg-blue-600", "dark:!bg-primary-700", "dark:text-white", "text-white", "focused");
            el.classList.add("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
          });
          Array.from(this.grid.children).forEach(function(el, index2) {
            var classList = el.classList;
            if (index2 > rangeStart && index2 < rangeEnd) {
              classList.add("range");
            }
            if (index2 === rangeStart) {
              classList.add("range-start");
            }
            if (index2 === rangeEnd) {
              classList.add("range-end");
            }
            if (selected.includes(index2)) {
              classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
              classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
            }
            if (index2 === _this2.focused) {
              classList.add("focused");
            }
          });
        }
        // Update the view UI by applying the change of focused item
      }, {
        key: "refreshFocus",
        value: function refreshFocus() {
          this.grid.querySelectorAll(".focused").forEach(function(el) {
            el.classList.remove("focused");
          });
          this.grid.children[this.focused].classList.add("focused");
        }
      }]);
    }(View);
    function toTitleCase(word) {
      return _toConsumableArray(word).reduce(function(str, ch, ix) {
        return str += ix ? ch : ch.toUpperCase();
      }, "");
    }
    var YearsView = /* @__PURE__ */ function(_View) {
      function YearsView2(picker, config) {
        _classCallCheck(this, YearsView2);
        return _callSuper(this, YearsView2, [picker, config]);
      }
      _inherits(YearsView2, _View);
      return _createClass(YearsView2, [{
        key: "init",
        value: function init(options) {
          var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          if (onConstruction) {
            this.navStep = this.step * 10;
            this.beforeShowOption = "beforeShow".concat(toTitleCase(this.cellClass));
            this.grid = this.element;
            this.element.classList.add(this.name, "datepicker-grid", "w-64", "grid", "grid-cols-4");
            this.grid.appendChild(parseHTML(createTagRepeat("span", 12)));
          }
          _get(_getPrototypeOf(YearsView2.prototype), "init", this).call(this, options);
        }
      }, {
        key: "setOptions",
        value: function setOptions(options) {
          if (hasProperty(options, "minDate")) {
            if (options.minDate === void 0) {
              this.minYear = this.minDate = void 0;
            } else {
              this.minYear = startOfYearPeriod(options.minDate, this.step);
              this.minDate = dateValue(this.minYear, 0, 1);
            }
          }
          if (hasProperty(options, "maxDate")) {
            if (options.maxDate === void 0) {
              this.maxYear = this.maxDate = void 0;
            } else {
              this.maxYear = startOfYearPeriod(options.maxDate, this.step);
              this.maxDate = dateValue(this.maxYear, 11, 31);
            }
          }
          if (options[this.beforeShowOption] !== void 0) {
            var beforeShow = options[this.beforeShowOption];
            this.beforeShow = typeof beforeShow === "function" ? beforeShow : void 0;
          }
        }
        // Update view's settings to reflect the viewDate set on the picker
      }, {
        key: "updateFocus",
        value: function updateFocus() {
          var viewDate = new Date(this.picker.viewDate);
          var first = startOfYearPeriod(viewDate, this.navStep);
          var last = first + 9 * this.step;
          this.first = first;
          this.last = last;
          this.start = first - this.step;
          this.focused = startOfYearPeriod(viewDate, this.step);
        }
        // Update view's settings to reflect the selected dates
      }, {
        key: "updateSelection",
        value: function updateSelection() {
          var _this = this;
          var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
          this.selected = dates.reduce(function(years2, timeValue) {
            return pushUnique(years2, startOfYearPeriod(timeValue, _this.step));
          }, []);
          if (rangepicker && rangepicker.dates) {
            this.range = rangepicker.dates.map(function(timeValue) {
              if (timeValue !== void 0) {
                return startOfYearPeriod(timeValue, _this.step);
              }
            });
          }
        }
        // Update the entire view UI
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          this.disabled = [];
          this.picker.setViewSwitchLabel("".concat(this.first, "-").concat(this.last));
          this.picker.setPrevBtnDisabled(this.first <= this.minYear);
          this.picker.setNextBtnDisabled(this.last >= this.maxYear);
          Array.from(this.grid.children).forEach(function(el, index2) {
            var classList = el.classList;
            var current = _this2.start + index2 * _this2.step;
            var date = dateValue(current, 0, 1);
            el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
            if (_this2.isMinView) {
              el.dataset.date = date;
            }
            el.textContent = el.dataset.year = current;
            if (index2 === 0) {
              classList.add("prev");
            } else if (index2 === 11) {
              classList.add("next");
            }
            if (current < _this2.minYear || current > _this2.maxYear) {
              classList.add("disabled");
            }
            if (_this2.range) {
              var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
              if (current > rangeStart && current < rangeEnd) {
                classList.add("range");
              }
              if (current === rangeStart) {
                classList.add("range-start");
              }
              if (current === rangeEnd) {
                classList.add("range-end");
              }
            }
            if (_this2.selected.includes(current)) {
              classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
              classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
            }
            if (current === _this2.focused) {
              classList.add("focused");
            }
            if (_this2.beforeShow) {
              _this2.performBeforeHook(el, current, date);
            }
          });
        }
        // Update the view UI by applying the changes of selected and focused items
      }, {
        key: "refresh",
        value: function refresh() {
          var _this3 = this;
          var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
          this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
            el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark!bg-primary-600", "dark:text-white", "focused");
          });
          Array.from(this.grid.children).forEach(function(el) {
            var current = Number(el.textContent);
            var classList = el.classList;
            if (current > rangeStart && current < rangeEnd) {
              classList.add("range");
            }
            if (current === rangeStart) {
              classList.add("range-start");
            }
            if (current === rangeEnd) {
              classList.add("range-end");
            }
            if (_this3.selected.includes(current)) {
              classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
              classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
            }
            if (current === _this3.focused) {
              classList.add("focused");
            }
          });
        }
        // Update the view UI by applying the change of focused item
      }, {
        key: "refreshFocus",
        value: function refreshFocus() {
          var index2 = Math.round((this.focused - this.start) / this.step);
          this.grid.querySelectorAll(".focused").forEach(function(el) {
            el.classList.remove("focused");
          });
          this.grid.children[index2].classList.add("focused");
        }
      }]);
    }(View);
    function triggerDatepickerEvent(datepicker, type) {
      var detail = {
        date: datepicker.getDate(),
        viewDate: new Date(datepicker.picker.viewDate),
        viewId: datepicker.picker.currentView.id,
        datepicker
      };
      datepicker.element.dispatchEvent(new CustomEvent(type, {
        detail
      }));
    }
    function goToPrevOrNext(datepicker, direction) {
      var _datepicker$config = datepicker.config, minDate = _datepicker$config.minDate, maxDate = _datepicker$config.maxDate;
      var _datepicker$picker = datepicker.picker, currentView = _datepicker$picker.currentView, viewDate = _datepicker$picker.viewDate;
      var newViewDate;
      switch (currentView.id) {
        case 0:
          newViewDate = addMonths(viewDate, direction);
          break;
        case 1:
          newViewDate = addYears(viewDate, direction);
          break;
        default:
          newViewDate = addYears(viewDate, direction * currentView.navStep);
      }
      newViewDate = limitToRange(newViewDate, minDate, maxDate);
      datepicker.picker.changeFocus(newViewDate).render();
    }
    function switchView(datepicker) {
      var viewId = datepicker.picker.currentView.id;
      if (viewId === datepicker.config.maxView) {
        return;
      }
      datepicker.picker.changeView(viewId + 1).render();
    }
    function unfocus(datepicker) {
      if (datepicker.config.updateOnBlur) {
        datepicker.update({
          autohide: true
        });
      } else {
        datepicker.refresh("input");
        datepicker.hide();
      }
    }
    function goToSelectedMonthOrYear(datepicker, selection) {
      var picker = datepicker.picker;
      var viewDate = new Date(picker.viewDate);
      var viewId = picker.currentView.id;
      var newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());
      picker.changeFocus(newDate).changeView(viewId - 1).render();
    }
    function onClickTodayBtn(datepicker) {
      var picker = datepicker.picker;
      var currentDate = today();
      if (datepicker.config.todayBtnMode === 1) {
        if (datepicker.config.autohide) {
          datepicker.setDate(currentDate);
          return;
        }
        datepicker.setDate(currentDate, {
          render: false
        });
        picker.update();
      }
      if (picker.viewDate !== currentDate) {
        picker.changeFocus(currentDate);
      }
      picker.changeView(0).render();
    }
    function onClickClearBtn(datepicker) {
      datepicker.setDate({
        clear: true
      });
    }
    function onClickViewSwitch(datepicker) {
      switchView(datepicker);
    }
    function onClickPrevBtn(datepicker) {
      goToPrevOrNext(datepicker, -1);
    }
    function onClickNextBtn(datepicker) {
      goToPrevOrNext(datepicker, 1);
    }
    function onClickView(datepicker, ev) {
      var target = findElementInEventPath(ev, ".datepicker-cell");
      if (!target || target.classList.contains("disabled")) {
        return;
      }
      var _datepicker$picker$cu = datepicker.picker.currentView, id = _datepicker$picker$cu.id, isMinView = _datepicker$picker$cu.isMinView;
      if (isMinView) {
        datepicker.setDate(Number(target.dataset.date));
      } else if (id === 1) {
        goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));
      } else {
        goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));
      }
    }
    function onClickPicker(datepicker) {
      if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {
        datepicker.inputField.focus();
      }
    }
    function processPickerOptions(picker, options) {
      if (options.title !== void 0) {
        if (options.title) {
          picker.controls.title.textContent = options.title;
          showElement(picker.controls.title);
        } else {
          picker.controls.title.textContent = "";
          hideElement(picker.controls.title);
        }
      }
      if (options.prevArrow) {
        var prevBtn = picker.controls.prevBtn;
        emptyChildNodes(prevBtn);
        options.prevArrow.forEach(function(node) {
          prevBtn.appendChild(node.cloneNode(true));
        });
      }
      if (options.nextArrow) {
        var nextBtn = picker.controls.nextBtn;
        emptyChildNodes(nextBtn);
        options.nextArrow.forEach(function(node) {
          nextBtn.appendChild(node.cloneNode(true));
        });
      }
      if (options.locale) {
        picker.controls.todayBtn.textContent = options.locale.today;
        picker.controls.clearBtn.textContent = options.locale.clear;
      }
      if (options.todayBtn !== void 0) {
        if (options.todayBtn) {
          showElement(picker.controls.todayBtn);
        } else {
          hideElement(picker.controls.todayBtn);
        }
      }
      if (hasProperty(options, "minDate") || hasProperty(options, "maxDate")) {
        var _picker$datepicker$co = picker.datepicker.config, minDate = _picker$datepicker$co.minDate, maxDate = _picker$datepicker$co.maxDate;
        picker.controls.todayBtn.disabled = !isInRange(today(), minDate, maxDate);
      }
      if (options.clearBtn !== void 0) {
        if (options.clearBtn) {
          showElement(picker.controls.clearBtn);
        } else {
          hideElement(picker.controls.clearBtn);
        }
      }
    }
    function computeResetViewDate(datepicker) {
      var dates = datepicker.dates, config = datepicker.config;
      var viewDate = dates.length > 0 ? lastItemOf(dates) : config.defaultViewDate;
      return limitToRange(viewDate, config.minDate, config.maxDate);
    }
    function setViewDate(picker, newDate) {
      var oldViewDate = new Date(picker.viewDate);
      var newViewDate = new Date(newDate);
      var _picker$currentView = picker.currentView, id = _picker$currentView.id, year = _picker$currentView.year, first = _picker$currentView.first, last = _picker$currentView.last;
      var viewYear = newViewDate.getFullYear();
      picker.viewDate = newDate;
      if (viewYear !== oldViewDate.getFullYear()) {
        triggerDatepickerEvent(picker.datepicker, "changeYear");
      }
      if (newViewDate.getMonth() !== oldViewDate.getMonth()) {
        triggerDatepickerEvent(picker.datepicker, "changeMonth");
      }
      switch (id) {
        case 0:
          return newDate < first || newDate > last;
        case 1:
          return viewYear !== year;
        default:
          return viewYear < first || viewYear > last;
      }
    }
    function getTextDirection(el) {
      return window.getComputedStyle(el).direction;
    }
    var Picker = /* @__PURE__ */ function() {
      function Picker2(datepicker) {
        _classCallCheck(this, Picker2);
        this.datepicker = datepicker;
        var template = pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);
        var element = this.element = parseHTML(template).firstChild;
        var _element$firstChild$c = _slicedToArray(element.firstChild.children, 3), header = _element$firstChild$c[0], main2 = _element$firstChild$c[1], footer = _element$firstChild$c[2];
        var title = header.firstElementChild;
        var _header$lastElementCh = _slicedToArray(header.lastElementChild.children, 3), prevBtn = _header$lastElementCh[0], viewSwitch = _header$lastElementCh[1], nextBtn = _header$lastElementCh[2];
        var _footer$firstChild$ch = _slicedToArray(footer.firstChild.children, 2), todayBtn = _footer$firstChild$ch[0], clearBtn = _footer$firstChild$ch[1];
        var controls = {
          title,
          prevBtn,
          viewSwitch,
          nextBtn,
          todayBtn,
          clearBtn
        };
        this.main = main2;
        this.controls = controls;
        var elementClass = datepicker.inline ? "inline" : "dropdown";
        element.classList.add("datepicker-".concat(elementClass));
        elementClass === "dropdown" ? element.classList.add("dropdown", "absolute", "top-0", "left-0", "z-50", "pt-2") : null;
        processPickerOptions(this, datepicker.config);
        this.viewDate = computeResetViewDate(datepicker);
        registerListeners(datepicker, [[element, "click", onClickPicker.bind(null, datepicker), {
          capture: true
        }], [main2, "click", onClickView.bind(null, datepicker)], [controls.viewSwitch, "click", onClickViewSwitch.bind(null, datepicker)], [controls.prevBtn, "click", onClickPrevBtn.bind(null, datepicker)], [controls.nextBtn, "click", onClickNextBtn.bind(null, datepicker)], [controls.todayBtn, "click", onClickTodayBtn.bind(null, datepicker)], [controls.clearBtn, "click", onClickClearBtn.bind(null, datepicker)]]);
        this.views = [new DaysView(this), new MonthsView(this), new YearsView(this, {
          id: 2,
          name: "years",
          cellClass: "year",
          step: 1
        }), new YearsView(this, {
          id: 3,
          name: "decades",
          cellClass: "decade",
          step: 10
        })];
        this.currentView = this.views[datepicker.config.startView];
        this.currentView.render();
        this.main.appendChild(this.currentView.element);
        datepicker.config.container.appendChild(this.element);
      }
      return _createClass(Picker2, [{
        key: "setOptions",
        value: function setOptions(options) {
          processPickerOptions(this, options);
          this.views.forEach(function(view) {
            view.init(options, false);
          });
          this.currentView.render();
        }
      }, {
        key: "detach",
        value: function detach() {
          this.datepicker.config.container.removeChild(this.element);
        }
      }, {
        key: "show",
        value: function show() {
          if (this.active) {
            return;
          }
          this.element.classList.add("active", "block");
          this.element.classList.remove("hidden");
          this.active = true;
          var datepicker = this.datepicker;
          if (!datepicker.inline) {
            var inputDirection = getTextDirection(datepicker.inputField);
            if (inputDirection !== getTextDirection(datepicker.config.container)) {
              this.element.dir = inputDirection;
            } else if (this.element.dir) {
              this.element.removeAttribute("dir");
            }
            this.place();
            if (datepicker.config.disableTouchKeyboard) {
              datepicker.inputField.blur();
            }
          }
          triggerDatepickerEvent(datepicker, "show");
        }
      }, {
        key: "hide",
        value: function hide2() {
          if (!this.active) {
            return;
          }
          this.datepicker.exitEditMode();
          this.element.classList.remove("active", "block");
          this.element.classList.add("active", "block", "hidden");
          this.active = false;
          triggerDatepickerEvent(this.datepicker, "hide");
        }
      }, {
        key: "place",
        value: function place() {
          var _this$element = this.element, classList = _this$element.classList, style = _this$element.style;
          var _this$datepicker = this.datepicker, config = _this$datepicker.config, inputField = _this$datepicker.inputField;
          var container = config.container;
          var _this$element$getBoun = this.element.getBoundingClientRect(), calendarWidth = _this$element$getBoun.width, calendarHeight = _this$element$getBoun.height;
          var _container$getBoundin = container.getBoundingClientRect(), containerLeft = _container$getBoundin.left, containerTop = _container$getBoundin.top, containerWidth = _container$getBoundin.width;
          var _inputField$getBoundi = inputField.getBoundingClientRect(), inputLeft = _inputField$getBoundi.left, inputTop = _inputField$getBoundi.top, inputWidth = _inputField$getBoundi.width, inputHeight = _inputField$getBoundi.height;
          var _config$orientation = config.orientation, orientX = _config$orientation.x, orientY = _config$orientation.y;
          var scrollTop;
          var left2;
          var top2;
          if (container === document.body) {
            scrollTop = window.scrollY;
            left2 = inputLeft + window.scrollX;
            top2 = inputTop + scrollTop;
          } else {
            scrollTop = container.scrollTop;
            left2 = inputLeft - containerLeft;
            top2 = inputTop - containerTop + scrollTop;
          }
          if (orientX === "auto") {
            if (left2 < 0) {
              orientX = "left";
              left2 = 10;
            } else if (left2 + calendarWidth > containerWidth) {
              orientX = "right";
            } else {
              orientX = getTextDirection(inputField) === "rtl" ? "right" : "left";
            }
          }
          if (orientX === "right") {
            left2 -= calendarWidth - inputWidth;
          }
          if (orientY === "auto") {
            orientY = top2 - calendarHeight < scrollTop ? "bottom" : "top";
          }
          if (orientY === "top") {
            top2 -= calendarHeight;
          } else {
            top2 += inputHeight;
          }
          classList.remove("datepicker-orient-top", "datepicker-orient-bottom", "datepicker-orient-right", "datepicker-orient-left");
          classList.add("datepicker-orient-".concat(orientY), "datepicker-orient-".concat(orientX));
          style.top = top2 ? "".concat(top2, "px") : top2;
          style.left = left2 ? "".concat(left2, "px") : left2;
        }
      }, {
        key: "setViewSwitchLabel",
        value: function setViewSwitchLabel(labelText) {
          this.controls.viewSwitch.textContent = labelText;
        }
      }, {
        key: "setPrevBtnDisabled",
        value: function setPrevBtnDisabled(disabled) {
          this.controls.prevBtn.disabled = disabled;
        }
      }, {
        key: "setNextBtnDisabled",
        value: function setNextBtnDisabled(disabled) {
          this.controls.nextBtn.disabled = disabled;
        }
      }, {
        key: "changeView",
        value: function changeView(viewId) {
          var oldView = this.currentView;
          var newView = this.views[viewId];
          if (newView.id !== oldView.id) {
            this.currentView = newView;
            this._renderMethod = "render";
            triggerDatepickerEvent(this.datepicker, "changeView");
            this.main.replaceChild(newView.element, oldView.element);
          }
          return this;
        }
        // Change the focused date (view date)
      }, {
        key: "changeFocus",
        value: function changeFocus(newViewDate) {
          this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refreshFocus";
          this.views.forEach(function(view) {
            view.updateFocus();
          });
          return this;
        }
        // Apply the change of the selected dates
      }, {
        key: "update",
        value: function update() {
          var newViewDate = computeResetViewDate(this.datepicker);
          this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refresh";
          this.views.forEach(function(view) {
            view.updateFocus();
            view.updateSelection();
          });
          return this;
        }
        // Refresh the picker UI
      }, {
        key: "render",
        value: function render() {
          var quickRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          var renderMethod = quickRender && this._renderMethod || "render";
          delete this._renderMethod;
          this.currentView[renderMethod]();
        }
      }]);
    }();
    function findNextAvailableOne(date, addFn, increase, testFn, min2, max2) {
      if (!isInRange(date, min2, max2)) {
        return;
      }
      if (testFn(date)) {
        var newDate = addFn(date, increase);
        return findNextAvailableOne(newDate, addFn, increase, testFn, min2, max2);
      }
      return date;
    }
    function moveByArrowKey(datepicker, ev, direction, vertical) {
      var picker = datepicker.picker;
      var currentView = picker.currentView;
      var step = currentView.step || 1;
      var viewDate = picker.viewDate;
      var addFn;
      var testFn;
      switch (currentView.id) {
        case 0:
          if (vertical) {
            viewDate = addDays(viewDate, direction * 7);
          } else if (ev.ctrlKey || ev.metaKey) {
            viewDate = addYears(viewDate, direction);
          } else {
            viewDate = addDays(viewDate, direction);
          }
          addFn = addDays;
          testFn = function testFn2(date) {
            return currentView.disabled.includes(date);
          };
          break;
        case 1:
          viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);
          addFn = addMonths;
          testFn = function testFn2(date) {
            var dt = new Date(date);
            var year = currentView.year, disabled = currentView.disabled;
            return dt.getFullYear() === year && disabled.includes(dt.getMonth());
          };
          break;
        default:
          viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);
          addFn = addYears;
          testFn = function testFn2(date) {
            return currentView.disabled.includes(startOfYearPeriod(date, step));
          };
      }
      viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);
      if (viewDate !== void 0) {
        picker.changeFocus(viewDate).render();
      }
    }
    function onKeydown(datepicker, ev) {
      if (ev.key === "Tab") {
        unfocus(datepicker);
        return;
      }
      var picker = datepicker.picker;
      var _picker$currentView = picker.currentView, id = _picker$currentView.id, isMinView = _picker$currentView.isMinView;
      if (!picker.active) {
        switch (ev.key) {
          case "ArrowDown":
          case "Escape":
            picker.show();
            break;
          case "Enter":
            datepicker.update();
            break;
          default:
            return;
        }
      } else if (datepicker.editMode) {
        switch (ev.key) {
          case "Escape":
            picker.hide();
            break;
          case "Enter":
            datepicker.exitEditMode({
              update: true,
              autohide: datepicker.config.autohide
            });
            break;
          default:
            return;
        }
      } else {
        switch (ev.key) {
          case "Escape":
            picker.hide();
            break;
          case "ArrowLeft":
            if (ev.ctrlKey || ev.metaKey) {
              goToPrevOrNext(datepicker, -1);
            } else if (ev.shiftKey) {
              datepicker.enterEditMode();
              return;
            } else {
              moveByArrowKey(datepicker, ev, -1, false);
            }
            break;
          case "ArrowRight":
            if (ev.ctrlKey || ev.metaKey) {
              goToPrevOrNext(datepicker, 1);
            } else if (ev.shiftKey) {
              datepicker.enterEditMode();
              return;
            } else {
              moveByArrowKey(datepicker, ev, 1, false);
            }
            break;
          case "ArrowUp":
            if (ev.ctrlKey || ev.metaKey) {
              switchView(datepicker);
            } else if (ev.shiftKey) {
              datepicker.enterEditMode();
              return;
            } else {
              moveByArrowKey(datepicker, ev, -1, true);
            }
            break;
          case "ArrowDown":
            if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
              datepicker.enterEditMode();
              return;
            }
            moveByArrowKey(datepicker, ev, 1, true);
            break;
          case "Enter":
            if (isMinView) {
              datepicker.setDate(picker.viewDate);
            } else {
              picker.changeView(id - 1).render();
            }
            break;
          case "Backspace":
          case "Delete":
            datepicker.enterEditMode();
            return;
          default:
            if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {
              datepicker.enterEditMode();
            }
            return;
        }
      }
      ev.preventDefault();
      ev.stopPropagation();
    }
    function onFocus(datepicker) {
      if (datepicker.config.showOnFocus && !datepicker._showing) {
        datepicker.show();
      }
    }
    function onMousedown(datepicker, ev) {
      var el = ev.target;
      if (datepicker.picker.active || datepicker.config.showOnClick) {
        el._active = el === document.activeElement;
        el._clicking = setTimeout(function() {
          delete el._active;
          delete el._clicking;
        }, 2e3);
      }
    }
    function onClickInput(datepicker, ev) {
      var el = ev.target;
      if (!el._clicking) {
        return;
      }
      clearTimeout(el._clicking);
      delete el._clicking;
      if (el._active) {
        datepicker.enterEditMode();
      }
      delete el._active;
      if (datepicker.config.showOnClick) {
        datepicker.show();
      }
    }
    function onPaste(datepicker, ev) {
      if (ev.clipboardData.types.includes("text/plain")) {
        datepicker.enterEditMode();
      }
    }
    function onClickOutside(datepicker, ev) {
      var element = datepicker.element;
      if (element !== document.activeElement) {
        return;
      }
      var pickerElem = datepicker.picker.element;
      if (findElementInEventPath(ev, function(el) {
        return el === element || el === pickerElem;
      })) {
        return;
      }
      unfocus(datepicker);
    }
    function stringifyDates(dates, config) {
      return dates.map(function(dt) {
        return formatDate(dt, config.format, config.locale);
      }).join(config.dateDelimiter);
    }
    function processInputDates(datepicker, inputDates) {
      var clear = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var config = datepicker.config, origDates = datepicker.dates, rangepicker = datepicker.rangepicker;
      if (inputDates.length === 0) {
        return clear ? [] : void 0;
      }
      var rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];
      var newDates = inputDates.reduce(function(dates, dt) {
        var date = parseDate(dt, config.format, config.locale);
        if (date === void 0) {
          return dates;
        }
        if (config.pickLevel > 0) {
          var _dt = new Date(date);
          if (config.pickLevel === 1) {
            date = rangeEnd ? _dt.setMonth(_dt.getMonth() + 1, 0) : _dt.setDate(1);
          } else {
            date = rangeEnd ? _dt.setFullYear(_dt.getFullYear() + 1, 0, 0) : _dt.setMonth(0, 1);
          }
        }
        if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && !config.daysOfWeekDisabled.includes(new Date(date).getDay())) {
          dates.push(date);
        }
        return dates;
      }, []);
      if (newDates.length === 0) {
        return;
      }
      if (config.multidate && !clear) {
        newDates = newDates.reduce(function(dates, date) {
          if (!origDates.includes(date)) {
            dates.push(date);
          }
          return dates;
        }, origDates.filter(function(date) {
          return !newDates.includes(date);
        }));
      }
      return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;
    }
    function refreshUI(datepicker) {
      var mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
      var quickRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var config = datepicker.config, picker = datepicker.picker, inputField = datepicker.inputField;
      if (mode & 2) {
        var newView = picker.active ? config.pickLevel : config.startView;
        picker.update().changeView(newView).render(quickRender);
      }
      if (mode & 1 && inputField) {
        inputField.value = stringifyDates(datepicker.dates, config);
      }
    }
    function _setDate(datepicker, inputDates, options) {
      var clear = options.clear, render = options.render, autohide = options.autohide;
      if (render === void 0) {
        render = true;
      }
      if (!render) {
        autohide = false;
      } else if (autohide === void 0) {
        autohide = datepicker.config.autohide;
      }
      var newDates = processInputDates(datepicker, inputDates, clear);
      if (!newDates) {
        return;
      }
      if (newDates.toString() !== datepicker.dates.toString()) {
        datepicker.dates = newDates;
        refreshUI(datepicker, render ? 3 : 1);
        triggerDatepickerEvent(datepicker, "changeDate");
      } else {
        refreshUI(datepicker, 1);
      }
      if (autohide) {
        datepicker.hide();
      }
    }
    var Datepicker$1 = /* @__PURE__ */ function() {
      function Datepicker2(element) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var rangepicker = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
        _classCallCheck(this, Datepicker2);
        element.datepicker = this;
        this.element = element;
        var config = this.config = Object.assign({
          buttonClass: options.buttonClass && String(options.buttonClass) || "button",
          container: document.body,
          defaultViewDate: today(),
          maxDate: void 0,
          minDate: void 0
        }, processOptions(defaultOptions, this));
        this._options = options;
        Object.assign(config, processOptions(options, this));
        var inline = this.inline = element.tagName !== "INPUT";
        var inputField;
        var initialDates;
        if (inline) {
          config.container = element;
          initialDates = stringToArray(element.dataset.date, config.dateDelimiter);
          delete element.dataset.date;
        } else {
          var container = options.container ? document.querySelector(options.container) : null;
          if (container) {
            config.container = container;
          }
          inputField = this.inputField = element;
          inputField.classList.add("datepicker-input");
          initialDates = stringToArray(inputField.value, config.dateDelimiter);
        }
        if (rangepicker) {
          var index2 = rangepicker.inputs.indexOf(inputField);
          var datepickers = rangepicker.datepickers;
          if (index2 < 0 || index2 > 1 || !Array.isArray(datepickers)) {
            throw Error("Invalid rangepicker object.");
          }
          datepickers[index2] = this;
          Object.defineProperty(this, "rangepicker", {
            get: function get2() {
              return rangepicker;
            }
          });
        }
        this.dates = [];
        var inputDateValues = processInputDates(this, initialDates);
        if (inputDateValues && inputDateValues.length > 0) {
          this.dates = inputDateValues;
        }
        if (inputField) {
          inputField.value = stringifyDates(this.dates, config);
        }
        var picker = this.picker = new Picker(this);
        if (inline) {
          this.show();
        } else {
          var onMousedownDocument = onClickOutside.bind(null, this);
          var listeners = [[inputField, "keydown", onKeydown.bind(null, this)], [inputField, "focus", onFocus.bind(null, this)], [inputField, "mousedown", onMousedown.bind(null, this)], [inputField, "click", onClickInput.bind(null, this)], [inputField, "paste", onPaste.bind(null, this)], [document, "mousedown", onMousedownDocument], [document, "touchstart", onMousedownDocument], [window, "resize", picker.place.bind(picker)]];
          registerListeners(this, listeners);
        }
      }
      return _createClass(Datepicker2, [{
        key: "active",
        get: (
          /**
           * @type {Boolean} - Whether the picker element is shown. `true` whne shown
           */
          function get2() {
            return !!(this.picker && this.picker.active);
          }
        )
        /**
         * @type {HTMLDivElement} - DOM object of picker element
         */
      }, {
        key: "pickerElement",
        get: function get2() {
          return this.picker ? this.picker.element : void 0;
        }
        /**
         * Set new values to the config options
         * @param {Object} options - config options to update
         */
      }, {
        key: "setOptions",
        value: function setOptions(options) {
          var picker = this.picker;
          var newOptions = processOptions(options, this);
          Object.assign(this._options, options);
          Object.assign(this.config, newOptions);
          picker.setOptions(newOptions);
          refreshUI(this, 3);
        }
        /**
         * Show the picker element
         */
      }, {
        key: "show",
        value: function show() {
          if (this.inputField) {
            if (this.inputField.disabled) {
              return;
            }
            if (this.inputField !== document.activeElement) {
              this._showing = true;
              this.inputField.focus();
              delete this._showing;
            }
          }
          this.picker.show();
        }
        /**
         * Hide the picker element
         * Not available on inline picker
         */
      }, {
        key: "hide",
        value: function hide2() {
          if (this.inline) {
            return;
          }
          this.picker.hide();
          this.picker.update().changeView(this.config.startView).render();
        }
        /**
         * Destroy the Datepicker instance
         * @return {Detepicker} - the instance destroyed
         */
      }, {
        key: "destroy",
        value: function destroy() {
          this.hide();
          unregisterListeners(this);
          this.picker.detach();
          if (!this.inline) {
            this.inputField.classList.remove("datepicker-input");
          }
          delete this.element.datepicker;
          return this;
        }
        /**
         * Get the selected date(s)
         *
         * The method returns a Date object of selected date by default, and returns
         * an array of selected dates in multidate mode. If format string is passed,
         * it returns date string(s) formatted in given format.
         *
         * @param  {String} [format] - Format string to stringify the date(s)
         * @return {Date|String|Date[]|String[]} - selected date(s), or if none is
         * selected, empty array in multidate mode and untitled in sigledate mode
         */
      }, {
        key: "getDate",
        value: function getDate() {
          var _this = this;
          var format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
          var callback2 = format2 ? function(date) {
            return formatDate(date, format2, _this.config.locale);
          } : function(date) {
            return new Date(date);
          };
          if (this.config.multidate) {
            return this.dates.map(callback2);
          }
          if (this.dates.length > 0) {
            return callback2(this.dates[0]);
          }
        }
        /**
         * Set selected date(s)
         *
         * In multidate mode, you can pass multiple dates as a series of arguments
         * or an array. (Since each date is parsed individually, the type of the
         * dates doesn't have to be the same.)
         * The given dates are used to toggle the select status of each date. The
         * number of selected dates is kept from exceeding the length set to
         * maxNumberOfDates.
         *
         * With clear: true option, the method can be used to clear the selection
         * and to replace the selection instead of toggling in multidate mode.
         * If the option is passed with no date arguments or an empty dates array,
         * it works as "clear" (clear the selection then set nothing), and if the
         * option is passed with new dates to select, it works as "replace" (clear
         * the selection then set the given dates)
         *
         * When render: false option is used, the method omits re-rendering the
         * picker element. In this case, you need to call refresh() method later in
         * order for the picker element to reflect the changes. The input field is
         * refreshed always regardless of this option.
         *
         * When invalid (unparsable, repeated, disabled or out-of-range) dates are
         * passed, the method ignores them and applies only valid ones. In the case
         * that all the given dates are invalid, which is distinguished from passing
         * no dates, the method considers it as an error and leaves the selection
         * untouched.
         *
         * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date
         * objects, time values or mix of those for new selection
         * @param {Object} [options] - function options
         * - clear: {boolean} - Whether to clear the existing selection
         *     defualt: false
         * - render: {boolean} - Whether to re-render the picker element
         *     default: true
         * - autohide: {boolean} - Whether to hide the picker element after re-render
         *     Ignored when used with render: false
         *     default: config.autohide
         */
      }, {
        key: "setDate",
        value: function setDate() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var dates = [].concat(args);
          var opts = {};
          var lastArg = lastItemOf(args);
          if (_typeof(lastArg) === "object" && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) {
            Object.assign(opts, dates.pop());
          }
          var inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
          _setDate(this, inputDates, opts);
        }
        /**
         * Update the selected date(s) with input field's value
         * Not available on inline picker
         *
         * The input field will be refreshed with properly formatted date string.
         *
         * @param  {Object} [options] - function options
         * - autohide: {boolean} - whether to hide the picker element after refresh
         *     default: false
         */
      }, {
        key: "update",
        value: function update() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
          if (this.inline) {
            return;
          }
          var opts = {
            clear: true,
            autohide: !!(options && options.autohide)
          };
          var inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);
          _setDate(this, inputDates, opts);
        }
        /**
         * Refresh the picker element and the associated input field
         * @param {String} [target] - target item when refreshing one item only
         * 'picker' or 'input'
         * @param {Boolean} [forceRender] - whether to re-render the picker element
         * regardless of its state instead of optimized refresh
         */
      }, {
        key: "refresh",
        value: function refresh() {
          var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
          var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (target && typeof target !== "string") {
            forceRender = target;
            target = void 0;
          }
          var mode;
          if (target === "picker") {
            mode = 2;
          } else if (target === "input") {
            mode = 1;
          } else {
            mode = 3;
          }
          refreshUI(this, mode, !forceRender);
        }
        /**
         * Enter edit mode
         * Not available on inline picker or when the picker element is hidden
         */
      }, {
        key: "enterEditMode",
        value: function enterEditMode() {
          if (this.inline || !this.picker.active || this.editMode) {
            return;
          }
          this.editMode = true;
          this.inputField.classList.add("in-edit", "border-blue-700", "!border-primary-700");
        }
        /**
         * Exit from edit mode
         * Not available on inline picker
         * @param  {Object} [options] - function options
         * - update: {boolean} - whether to call update() after exiting
         *     If false, input field is revert to the existing selection
         *     default: false
         */
      }, {
        key: "exitEditMode",
        value: function exitEditMode() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
          if (this.inline || !this.editMode) {
            return;
          }
          var opts = Object.assign({
            update: false
          }, options);
          delete this.editMode;
          this.inputField.classList.remove("in-edit", "border-blue-700", "!border-primary-700");
          if (opts.update) {
            this.update(opts);
          }
        }
      }], [{
        key: "formatDate",
        value: function formatDate$1(date, format2, lang2) {
          return formatDate(date, format2, lang2 && locales$1[lang2] || locales$1.en);
        }
        /**
         * Parse date string
         * @param  {String|Date|Number} dateStr - date string, Date object or time
         * value to parse
         * @param  {String|Object} format - format string or object that contains
         * toValue() custom parser, whose signature is
         * - args:
         *   - dateStr: {String|Date|Number} - the dateStr passed to the method
         *   - format: {Object} - the format object passed to the method
         *   - locale: {Object} - locale for the language specified by `lang`
         * - return:
         *     {Date|Number} parsed date or its time value
         * @param  {String} [lang=en] - language code for the locale to use
         * @return {Number} time value of parsed date
         */
      }, {
        key: "parseDate",
        value: function parseDate$1(dateStr, format2, lang2) {
          return parseDate(dateStr, format2, lang2 && locales$1[lang2] || locales$1.en);
        }
        /**
         * @type {Object} - Installed locales in `[languageCode]: localeObject` format
         * en`:_English (US)_ is pre-installed.
         */
      }, {
        key: "locales",
        get: function get2() {
          return locales$1;
        }
      }]);
    }();
    function filterOptions(options) {
      var newOpts = Object.assign({}, options);
      delete newOpts.inputs;
      delete newOpts.allowOneSidedRange;
      delete newOpts.maxNumberOfDates;
      return newOpts;
    }
    function setupDatepicker(rangepicker, changeDateListener, el, options) {
      registerListeners(rangepicker, [[el, "changeDate", changeDateListener]]);
      new Datepicker$1(el, options, rangepicker);
    }
    function onChangeDate(rangepicker, ev) {
      if (rangepicker._updating) {
        return;
      }
      rangepicker._updating = true;
      var target = ev.target;
      if (target.datepicker === void 0) {
        return;
      }
      var datepickers = rangepicker.datepickers;
      var setDateOptions = {
        render: false
      };
      var changedSide = rangepicker.inputs.indexOf(target);
      var otherSide = changedSide === 0 ? 1 : 0;
      var changedDate = datepickers[changedSide].dates[0];
      var otherDate = datepickers[otherSide].dates[0];
      if (changedDate !== void 0 && otherDate !== void 0) {
        if (changedSide === 0 && changedDate > otherDate) {
          datepickers[0].setDate(otherDate, setDateOptions);
          datepickers[1].setDate(changedDate, setDateOptions);
        } else if (changedSide === 1 && changedDate < otherDate) {
          datepickers[0].setDate(changedDate, setDateOptions);
          datepickers[1].setDate(otherDate, setDateOptions);
        }
      } else if (!rangepicker.allowOneSidedRange) {
        if (changedDate !== void 0 || otherDate !== void 0) {
          setDateOptions.clear = true;
          datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);
        }
      }
      datepickers[0].picker.update().render();
      datepickers[1].picker.update().render();
      delete rangepicker._updating;
    }
    var DateRangePicker = /* @__PURE__ */ function() {
      function DateRangePicker2(element) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, DateRangePicker2);
        var inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll("input"));
        if (inputs.length < 2) {
          return;
        }
        element.rangepicker = this;
        this.element = element;
        this.inputs = inputs.slice(0, 2);
        this.allowOneSidedRange = !!options.allowOneSidedRange;
        var changeDateListener = onChangeDate.bind(null, this);
        var cleanOptions = filterOptions(options);
        var datepickers = [];
        Object.defineProperty(this, "datepickers", {
          get: function get2() {
            return datepickers;
          }
        });
        setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);
        setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);
        Object.freeze(datepickers);
        if (datepickers[0].dates.length > 0) {
          onChangeDate(this, {
            target: this.inputs[0]
          });
        } else if (datepickers[1].dates.length > 0) {
          onChangeDate(this, {
            target: this.inputs[1]
          });
        }
      }
      return _createClass(DateRangePicker2, [{
        key: "dates",
        get: function get2() {
          return this.datepickers.length === 2 ? [this.datepickers[0].dates[0], this.datepickers[1].dates[0]] : void 0;
        }
        /**
         * Set new values to the config options
         * @param {Object} options - config options to update
         */
      }, {
        key: "setOptions",
        value: function setOptions(options) {
          this.allowOneSidedRange = !!options.allowOneSidedRange;
          var cleanOptions = filterOptions(options);
          this.datepickers[0].setOptions(cleanOptions);
          this.datepickers[1].setOptions(cleanOptions);
        }
        /**
         * Destroy the DateRangePicker instance
         * @return {DateRangePicker} - the instance destroyed
         */
      }, {
        key: "destroy",
        value: function destroy() {
          this.datepickers[0].destroy();
          this.datepickers[1].destroy();
          unregisterListeners(this);
          delete this.element.rangepicker;
        }
        /**
         * Get the start and end dates of the date range
         *
         * The method returns Date objects by default. If format string is passed,
         * it returns date strings formatted in given format.
         * The result array always contains 2 items (start date/end date) and
         * undefined is used for unselected side. (e.g. If none is selected,
         * the result will be [undefined, undefined]. If only the end date is set
         * when allowOneSidedRange config option is true, [undefined, endDate] will
         * be returned.)
         *
         * @param  {String} [format] - Format string to stringify the dates
         * @return {Array} - Start and end dates
         */
      }, {
        key: "getDates",
        value: function getDates() {
          var _this = this;
          var format2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
          var callback2 = format2 ? function(date) {
            return formatDate(date, format2, _this.datepickers[0].config.locale);
          } : function(date) {
            return new Date(date);
          };
          return this.dates.map(function(date) {
            return date === void 0 ? date : callback2(date);
          });
        }
        /**
         * Set the start and end dates of the date range
         *
         * The method calls datepicker.setDate() internally using each of the
         * arguments in startend order.
         *
         * When a clear: true option object is passed instead of a date, the method
         * clears the date.
         *
         * If an invalid date, the same date as the current one or an option object
         * without clear: true is passed, the method considers that argument as an
         * "ineffective" argument because calling datepicker.setDate() with those
         * values makes no changes to the date selection.
         *
         * When the allowOneSidedRange config option is false, passing {clear: true}
         * to clear the range works only when it is done to the last effective
         * argument (in other words, passed to rangeEnd or to rangeStart along with
         * ineffective rangeEnd). This is because when the date range is changed,
         * it gets normalized based on the last change at the end of the changing
         * process.
         *
         * @param {Date|Number|String|Object} rangeStart - Start date of the range
         * or {clear: true} to clear the date
         * @param {Date|Number|String|Object} rangeEnd - End date of the range
         * or {clear: true} to clear the date
         */
      }, {
        key: "setDates",
        value: function setDates(rangeStart, rangeEnd) {
          var _this$datepickers = _slicedToArray(this.datepickers, 2), datepicker0 = _this$datepickers[0], datepicker1 = _this$datepickers[1];
          var origDates = this.dates;
          this._updating = true;
          datepicker0.setDate(rangeStart);
          datepicker1.setDate(rangeEnd);
          delete this._updating;
          if (datepicker1.dates[0] !== origDates[1]) {
            onChangeDate(this, {
              target: this.inputs[1]
            });
          } else if (datepicker0.dates[0] !== origDates[0]) {
            onChangeDate(this, {
              target: this.inputs[0]
            });
          }
        }
      }]);
    }();
    var __assign = function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var Default = {
      defaultDatepickerId: null,
      autohide: false,
      format: "mm/dd/yyyy",
      maxDate: null,
      minDate: null,
      orientation: "bottom",
      buttons: false,
      autoSelectToday: 0,
      title: null,
      language: "en",
      rangePicker: false,
      onShow: function() {
      },
      onHide: function() {
      }
    };
    var DefaultInstanceOptions = {
      id: null,
      override: true
    };
    var Datepicker = (
      /** @class */
      function() {
        function Datepicker2(datepickerEl, options, instanceOptions) {
          if (datepickerEl === void 0) {
            datepickerEl = null;
          }
          if (options === void 0) {
            options = Default;
          }
          if (instanceOptions === void 0) {
            instanceOptions = DefaultInstanceOptions;
          }
          this._instanceId = instanceOptions.id ? instanceOptions.id : datepickerEl.id;
          this._datepickerEl = datepickerEl;
          this._datepickerInstance = null;
          this._options = __assign(__assign({}, Default), options);
          this._initialized = false;
          this.init();
          instances$1.addInstance("Datepicker", this, this._instanceId, instanceOptions.override);
        }
        Datepicker2.prototype.init = function() {
          if (this._datepickerEl && !this._initialized) {
            if (this._options.rangePicker) {
              this._datepickerInstance = new DateRangePicker(this._datepickerEl, this._getDatepickerOptions(this._options));
            } else {
              this._datepickerInstance = new Datepicker$1(this._datepickerEl, this._getDatepickerOptions(this._options));
            }
            this._initialized = true;
          }
        };
        Datepicker2.prototype.destroy = function() {
          if (this._initialized) {
            this._initialized = false;
            this._datepickerInstance.destroy();
          }
        };
        Datepicker2.prototype.removeInstance = function() {
          this.destroy();
          instances$1.removeInstance("Datepicker", this._instanceId);
        };
        Datepicker2.prototype.destroyAndRemoveInstance = function() {
          this.destroy();
          this.removeInstance();
        };
        Datepicker2.prototype.getDatepickerInstance = function() {
          return this._datepickerInstance;
        };
        Datepicker2.prototype.getDate = function() {
          if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) {
            return this._datepickerInstance.getDates();
          }
          if (!this._options.rangePicker && this._datepickerInstance instanceof Datepicker$1) {
            return this._datepickerInstance.getDate();
          }
        };
        Datepicker2.prototype.setDate = function(date) {
          if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) {
            return this._datepickerInstance.setDates(date);
          }
          if (!this._options.rangePicker && this._datepickerInstance instanceof Datepicker$1) {
            return this._datepickerInstance.setDate(date);
          }
        };
        Datepicker2.prototype.show = function() {
          this._datepickerInstance.show();
          this._options.onShow(this);
        };
        Datepicker2.prototype.hide = function() {
          this._datepickerInstance.hide();
          this._options.onHide(this);
        };
        Datepicker2.prototype._getDatepickerOptions = function(options) {
          var datepickerOptions = {};
          if (options.buttons) {
            datepickerOptions.todayBtn = true;
            datepickerOptions.clearBtn = true;
            if (options.autoSelectToday) {
              datepickerOptions.todayBtnMode = 1;
            }
          }
          if (options.autohide) {
            datepickerOptions.autohide = true;
          }
          if (options.format) {
            datepickerOptions.format = options.format;
          }
          if (options.maxDate) {
            datepickerOptions.maxDate = options.maxDate;
          }
          if (options.minDate) {
            datepickerOptions.minDate = options.minDate;
          }
          if (options.orientation) {
            datepickerOptions.orientation = options.orientation;
          }
          if (options.title) {
            datepickerOptions.title = options.title;
          }
          if (options.language) {
            datepickerOptions.language = options.language;
          }
          return datepickerOptions;
        };
        Datepicker2.prototype.updateOnShow = function(callback2) {
          this._options.onShow = callback2;
        };
        Datepicker2.prototype.updateOnHide = function(callback2) {
          this._options.onHide = callback2;
        };
        return Datepicker2;
      }()
    );
    function initDatepickers() {
      document.querySelectorAll("[datepicker], [inline-datepicker], [date-rangepicker]").forEach(function($datepickerEl) {
        if ($datepickerEl) {
          var buttons = $datepickerEl.hasAttribute("datepicker-buttons");
          var autoselectToday = $datepickerEl.hasAttribute("datepicker-autoselect-today");
          var autohide = $datepickerEl.hasAttribute("datepicker-autohide");
          var format2 = $datepickerEl.getAttribute("datepicker-format");
          var maxDate = $datepickerEl.getAttribute("datepicker-max-date");
          var minDate = $datepickerEl.getAttribute("datepicker-min-date");
          var orientation_1 = $datepickerEl.getAttribute("datepicker-orientation");
          var title = $datepickerEl.getAttribute("datepicker-title");
          var language = $datepickerEl.getAttribute("datepicker-language");
          var rangePicker = $datepickerEl.hasAttribute("date-rangepicker");
          new Datepicker($datepickerEl, {
            buttons: buttons ? buttons : Default.buttons,
            autoSelectToday: autoselectToday ? autoselectToday : Default.autoSelectToday,
            autohide: autohide ? autohide : Default.autohide,
            format: format2 ? format2 : Default.format,
            maxDate: maxDate ? maxDate : Default.maxDate,
            minDate: minDate ? minDate : Default.minDate,
            orientation: orientation_1 ? orientation_1 : Default.orientation,
            title: title ? title : Default.title,
            language: language ? language : Default.language,
            rangePicker: rangePicker ? rangePicker : Default.rangePicker
          });
        } else {
          console.error("The datepicker element does not exist. Please check the datepicker attribute.");
        }
      });
    }
    if (typeof window !== "undefined") {
      window.Datepicker = Datepicker;
      window.initDatepickers = initDatepickers;
    }
    function initFlowbite() {
      initAccordions();
      initCollapses();
      initCarousels();
      initDismisses();
      initDropdowns();
      initModals();
      initDrawers();
      initTabs();
      initTooltips();
      initPopovers();
      initDials();
      initInputCounters();
      initCopyClipboards();
      initDatepickers();
    }
    if (typeof window !== "undefined") {
      window.initFlowbite = initFlowbite;
    }
    var events = new Events("load", [
      initAccordions,
      initCollapses,
      initCarousels,
      initDismisses,
      initDropdowns,
      initModals,
      initDrawers,
      initTabs,
      initTooltips,
      initPopovers,
      initDials,
      initInputCounters,
      initCopyClipboards,
      initDatepickers
    ]);
    events.init();
    const Dropdown = ({ data }) => {
      const buttonRef = reactExports.useRef(null);
      const dropdownRef = reactExports.useRef(null);
      const updateDropdownWidth = () => {
        if (buttonRef.current && dropdownRef.current) {
          dropdownRef.current.style.width = `${buttonRef.current.offsetWidth}px`;
        }
      };
      reactExports.useEffect(() => {
        const resizeObserver = new ResizeObserver(() => updateDropdownWidth());
        if (buttonRef.current) {
          resizeObserver.observe(buttonRef.current);
        }
        return () => {
          if (buttonRef.current) {
            resizeObserver.unobserve(buttonRef.current);
          }
        };
      }, []);
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(ReportsComponent, { name: "Reports" }), /* @__PURE__ */ React.createElement("div", { className: "flex flex-col sm:flex-row mx-1 my-4 gap-4" }, /* @__PURE__ */ React.createElement(
        "button",
        {
          id: "dropdownDefaultButton0",
          "data-dropdown-toggle": "dropdown0",
          className: "text-black bg-white focus:ring-4 focus:outline-none w-full font-medium rounded-2xl text-sm px-5 py-2.5 text-center inline-flex items-center justify-between",
          type: "button",
          ref: buttonRef
        },
        "Class: Class Name",
        /* @__PURE__ */ React.createElement(
          "svg",
          {
            className: "w-2.5 h-2.5 ms-3",
            "aria-hidden": "true",
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 10 6"
          },
          /* @__PURE__ */ React.createElement(
            "path",
            {
              stroke: "currentColor",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              strokeWidth: "2",
              d: "m1 1 4 4 4-4"
            }
          )
        )
      ), /* @__PURE__ */ React.createElement(
        "div",
        {
          id: "dropdown0",
          ref: dropdownRef,
          className: "z-10 hidden bg-white divide-y divide-gray-100 rounded-lg shadow w-auto dark:bg-gray-700"
        },
        /* @__PURE__ */ React.createElement(
          "ul",
          {
            className: "py-2 text-sm text-gray-700 dark:text-gray-200",
            "aria-labelledby": "dropdownDefaultButton0"
          },
          data.map((data2) => /* @__PURE__ */ React.createElement("li", { key: data2.id }, /* @__PURE__ */ React.createElement(
            "a",
            {
              href: `/home/${data2.id}`,
              className: "block px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-600 dark:hover:text-white"
            },
            data2.class_name
          )))
        )
      )));
    };
    const Card = ({ className, token: token2 }) => {
      const [copied, setCopied] = reactExports.useState(false);
      const copyToClipboard = () => {
        navigator.clipboard.writeText(token2);
        setCopied(true);
        setTimeout(() => setCopied(false), 2e3);
      };
      return /* @__PURE__ */ React.createElement("div", { className: "bg-white p-6 shadow rounded-3xl text-left w-full h-full border border-gray-100" }, /* @__PURE__ */ React.createElement("div", { className: "space-y-6" }, /* @__PURE__ */ React.createElement("div", { className: "pb-6 border-b border-gray-100" }, /* @__PURE__ */ React.createElement("h2", { className: "text-gray-500 text-sm mb-2 uppercase tracking-wide" }, "Class Name"), /* @__PURE__ */ React.createElement("p", { className: "text-2xl font-bold text-gray-800" }, className)), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("h2", { className: "text-gray-500 text-sm mb-3 uppercase tracking-wide" }, "Class Code"), /* @__PURE__ */ React.createElement("div", { className: "flex items-center justify-between p-3 bg-gray-50 rounded-xl" }, /* @__PURE__ */ React.createElement("p", { className: "text-lg font-medium text-gray-700 font-mono" }, token2), /* @__PURE__ */ React.createElement(
        "button",
        {
          onClick: copyToClipboard,
          className: `flex items-center gap-2 px-4 py-2 rounded-lg transition-all ${copied ? "bg-green-500 text-white" : "bg-blue-500 hover:bg-blue-600 text-white"}`
        },
        copied ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Check, { size: 16 }), /* @__PURE__ */ React.createElement("span", null, "Copied!")) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Copy, { size: 16 }), /* @__PURE__ */ React.createElement("span", null, "Copy"))
      ))), /* @__PURE__ */ React.createElement("div", { className: "pt-4" }, /* @__PURE__ */ React.createElement("div", { className: "p-4 bg-blue-50 rounded-xl" }, /* @__PURE__ */ React.createElement("p", { className: "text-sm text-blue-600" }, "Keep this token secure. You'll need it to access your class resources.")))));
    };
    const ProgressBar$1 = ({ label, percentage }) => {
      return /* @__PURE__ */ React.createElement("div", { className: "flex gap-4" }, /* @__PURE__ */ React.createElement("div", { className: "w-12 h-12 bg-gray-300 rounded-xl" }), /* @__PURE__ */ React.createElement("div", { className: "flex-1" }, /* @__PURE__ */ React.createElement("div", { className: "flex justify-between mb-1" }, /* @__PURE__ */ React.createElement("span", { className: "font-medium text-gray-800" }, label)), /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `w-full bg-gradient-to-r from-[#ffbe1a1e] to-[#ff40801f] rounded-full h-2.5`
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `bg-gradient-to-r from-[#ffbe1a] to-[#ff4080] h-2.5 rounded-full`,
            style: { width: `${percentage}%` }
          }
        )
      )), /* @__PURE__ */ React.createElement("div", { className: "flex justify-end items-end" }, /* @__PURE__ */ React.createElement("span", { className: "text-gray-500" }, percentage, "% Correct")));
    };
    const ProgressBar = ({ label, percentage }) => {
      return /* @__PURE__ */ React.createElement("div", { className: "flex gap-4" }, /* @__PURE__ */ React.createElement("div", { className: "w-12 h-12 bg-gray-300 rounded-xl" }), /* @__PURE__ */ React.createElement("div", { className: "flex-1" }, /* @__PURE__ */ React.createElement("div", { className: "flex justify-between mb-1" }, /* @__PURE__ */ React.createElement("span", { className: "font-medium text-gray-800" }, label)), /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `w-full bg-gradient-to-r from-[#2FEA9B4D] to-[#7FDD534D] rounded-full h-2.5`
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `bg-gradient-to-r from-[#2FEA9B] to-[#7FDD53] h-2.5 rounded-full`,
            style: { width: `${percentage}%` }
          }
        )
      )), /* @__PURE__ */ React.createElement("div", { className: "flex justify-end items-end" }, /* @__PURE__ */ React.createElement("span", { className: "text-gray-500 justify-end" }, percentage, "% Correct")));
    };
    const TopicsList = ({ title, topics }) => {
      return /* @__PURE__ */ React.createElement("div", { className: "bg-white p-4 shadow rounded-2xl h-full" }, /* @__PURE__ */ React.createElement("h2", { className: "text-gray-500" }, title), /* @__PURE__ */ React.createElement("ul", { className: "mt-4 space-y-2" }, topics.map(
        (topic, i) => title === "Strongest Topics" ? /* @__PURE__ */ React.createElement(
          ProgressBar,
          {
            key: i,
            label: `Topic #${topic.topic}`,
            percentage: topic.percentage
          }
        ) : /* @__PURE__ */ React.createElement(
          ProgressBar$1,
          {
            key: i,
            label: `Topic #${topic.topic}`,
            percentage: topic.percentage
          }
        )
      )));
    };
    const NameComponent = ({ name, points, accuracy, rank }) => {
      return /* @__PURE__ */ React.createElement("div", { className: "flex items-center justify-between px-6 py-2 rounded-lg flex-1 w-full" }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("p", { className: "font-bold text-gray-800" }, name), /* @__PURE__ */ React.createElement("p", { className: "text-sm text-gray-500" }, points, " Points / User - ", accuracy, "% Correct")), /* @__PURE__ */ React.createElement("div", { className: "flex items-center gap-1" }, /* @__PURE__ */ React.createElement("p", { className: "text-lg font-semibold text-gray-700" }, rank), /* @__PURE__ */ React.createElement("span", { className: "w-4 h-4 rounded-full flex justify-center items-center text-green-500" }, "")));
    };
    const Leaderboard = ({ title, leaders }) => {
      return /* @__PURE__ */ React.createElement("div", { className: "bg-white px-6 pt-6 shadow rounded-2xl h-full flex flex-col mb-4" }, /* @__PURE__ */ React.createElement("h2", { className: "text-gray-500" }, title), /* @__PURE__ */ React.createElement("ul", { className: "mt-4 space-y-2 flex-grow" }, leaders.map((leader, i) => /* @__PURE__ */ React.createElement(
        NameComponent,
        {
          key: i,
          name: leader.name,
          points: leader.totalscore,
          accuracy: leader.accuracy,
          rank: leader.rank
        }
      ))), /* @__PURE__ */ React.createElement("div", { className: "mt-auto" }));
    };
    const ThemeContext = reactExports.createContext({
      currentTheme: "light",
      changeCurrentTheme: () => {
      }
    });
    const useThemeProvider = () => reactExports.useContext(ThemeContext);
    /*!
     * @kurkle/color v0.3.4
     * https://github.com/kurkle/color#readme
     * (c) 2024 Jukka Kurkela
     * Released under the MIT License
     */
    function round$1(v) {
      return v + 0.5 | 0;
    }
    const lim = (v, l, h) => Math.max(Math.min(v, h), l);
    function p2b(v) {
      return lim(round$1(v * 2.55), 0, 255);
    }
    function n2b(v) {
      return lim(round$1(v * 255), 0, 255);
    }
    function b2n(v) {
      return lim(round$1(v / 2.55) / 100, 0, 1);
    }
    function n2p(v) {
      return lim(round$1(v * 100), 0, 100);
    }
    const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
    const hex = [..."0123456789ABCDEF"];
    const h1 = (b) => hex[b & 15];
    const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
    const eq = (b) => (b & 240) >> 4 === (b & 15);
    const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
    function hexParse(str) {
      var len = str.length;
      var ret;
      if (str[0] === "#") {
        if (len === 4 || len === 5) {
          ret = {
            r: 255 & map$1[str[1]] * 17,
            g: 255 & map$1[str[2]] * 17,
            b: 255 & map$1[str[3]] * 17,
            a: len === 5 ? map$1[str[4]] * 17 : 255
          };
        } else if (len === 7 || len === 9) {
          ret = {
            r: map$1[str[1]] << 4 | map$1[str[2]],
            g: map$1[str[3]] << 4 | map$1[str[4]],
            b: map$1[str[5]] << 4 | map$1[str[6]],
            a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
          };
        }
      }
      return ret;
    }
    const alpha = (a, f) => a < 255 ? f(a) : "";
    function hexString(v) {
      var f = isShort(v) ? h1 : h2;
      return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
    }
    const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
    function hsl2rgbn(h, s, l) {
      const a = s * Math.min(l, 1 - l);
      const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return [f(0), f(8), f(4)];
    }
    function hsv2rgbn(h, s, v) {
      const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      return [f(5), f(3), f(1)];
    }
    function hwb2rgbn(h, w, b) {
      const rgb = hsl2rgbn(h, 1, 0.5);
      let i;
      if (w + b > 1) {
        i = 1 / (w + b);
        w *= i;
        b *= i;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] *= 1 - w - b;
        rgb[i] += w;
      }
      return rgb;
    }
    function hueValue(r, g, b, d, max2) {
      if (r === max2) {
        return (g - b) / d + (g < b ? 6 : 0);
      }
      if (g === max2) {
        return (b - r) / d + 2;
      }
      return (r - g) / d + 4;
    }
    function rgb2hsl(v) {
      const range2 = 255;
      const r = v.r / range2;
      const g = v.g / range2;
      const b = v.b / range2;
      const max2 = Math.max(r, g, b);
      const min2 = Math.min(r, g, b);
      const l = (max2 + min2) / 2;
      let h, s, d;
      if (max2 !== min2) {
        d = max2 - min2;
        s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
        h = hueValue(r, g, b, d, max2);
        h = h * 60 + 0.5;
      }
      return [h | 0, s || 0, l];
    }
    function calln(f, a, b, c) {
      return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
    }
    function hsl2rgb(h, s, l) {
      return calln(hsl2rgbn, h, s, l);
    }
    function hwb2rgb(h, w, b) {
      return calln(hwb2rgbn, h, w, b);
    }
    function hsv2rgb(h, s, v) {
      return calln(hsv2rgbn, h, s, v);
    }
    function hue(h) {
      return (h % 360 + 360) % 360;
    }
    function hueParse(str) {
      const m = HUE_RE.exec(str);
      let a = 255;
      let v;
      if (!m) {
        return;
      }
      if (m[5] !== v) {
        a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
      }
      const h = hue(+m[2]);
      const p1 = +m[3] / 100;
      const p2 = +m[4] / 100;
      if (m[1] === "hwb") {
        v = hwb2rgb(h, p1, p2);
      } else if (m[1] === "hsv") {
        v = hsv2rgb(h, p1, p2);
      } else {
        v = hsl2rgb(h, p1, p2);
      }
      return {
        r: v[0],
        g: v[1],
        b: v[2],
        a
      };
    }
    function rotate(v, deg) {
      var h = rgb2hsl(v);
      h[0] = hue(h[0] + deg);
      h = hsl2rgb(h);
      v.r = h[0];
      v.g = h[1];
      v.b = h[2];
    }
    function hslString(v) {
      if (!v) {
        return;
      }
      const a = rgb2hsl(v);
      const h = a[0];
      const s = n2p(a[1]);
      const l = n2p(a[2]);
      return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
    }
    const map$2 = {
      x: "dark",
      Z: "light",
      Y: "re",
      X: "blu",
      W: "gr",
      V: "medium",
      U: "slate",
      A: "ee",
      T: "ol",
      S: "or",
      B: "ra",
      C: "lateg",
      D: "ights",
      R: "in",
      Q: "turquois",
      E: "hi",
      P: "ro",
      O: "al",
      N: "le",
      M: "de",
      L: "yello",
      F: "en",
      K: "ch",
      G: "arks",
      H: "ea",
      I: "ightg",
      J: "wh"
    };
    const names$1 = {
      OiceXe: "f0f8ff",
      antiquewEte: "faebd7",
      aqua: "ffff",
      aquamarRe: "7fffd4",
      azuY: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "0",
      blanKedOmond: "ffebcd",
      Xe: "ff",
      XeviTet: "8a2be2",
      bPwn: "a52a2a",
      burlywood: "deb887",
      caMtXe: "5f9ea0",
      KartYuse: "7fff00",
      KocTate: "d2691e",
      cSO: "ff7f50",
      cSnflowerXe: "6495ed",
      cSnsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "ffff",
      xXe: "8b",
      xcyan: "8b8b",
      xgTMnPd: "b8860b",
      xWay: "a9a9a9",
      xgYF: "6400",
      xgYy: "a9a9a9",
      xkhaki: "bdb76b",
      xmagFta: "8b008b",
      xTivegYF: "556b2f",
      xSange: "ff8c00",
      xScEd: "9932cc",
      xYd: "8b0000",
      xsOmon: "e9967a",
      xsHgYF: "8fbc8f",
      xUXe: "483d8b",
      xUWay: "2f4f4f",
      xUgYy: "2f4f4f",
      xQe: "ced1",
      xviTet: "9400d3",
      dAppRk: "ff1493",
      dApskyXe: "bfff",
      dimWay: "696969",
      dimgYy: "696969",
      dodgerXe: "1e90ff",
      fiYbrick: "b22222",
      flSOwEte: "fffaf0",
      foYstWAn: "228b22",
      fuKsia: "ff00ff",
      gaRsbSo: "dcdcdc",
      ghostwEte: "f8f8ff",
      gTd: "ffd700",
      gTMnPd: "daa520",
      Way: "808080",
      gYF: "8000",
      gYFLw: "adff2f",
      gYy: "808080",
      honeyMw: "f0fff0",
      hotpRk: "ff69b4",
      RdianYd: "cd5c5c",
      Rdigo: "4b0082",
      ivSy: "fffff0",
      khaki: "f0e68c",
      lavFMr: "e6e6fa",
      lavFMrXsh: "fff0f5",
      lawngYF: "7cfc00",
      NmoncEffon: "fffacd",
      ZXe: "add8e6",
      ZcSO: "f08080",
      Zcyan: "e0ffff",
      ZgTMnPdLw: "fafad2",
      ZWay: "d3d3d3",
      ZgYF: "90ee90",
      ZgYy: "d3d3d3",
      ZpRk: "ffb6c1",
      ZsOmon: "ffa07a",
      ZsHgYF: "20b2aa",
      ZskyXe: "87cefa",
      ZUWay: "778899",
      ZUgYy: "778899",
      ZstAlXe: "b0c4de",
      ZLw: "ffffe0",
      lime: "ff00",
      limegYF: "32cd32",
      lRF: "faf0e6",
      magFta: "ff00ff",
      maPon: "800000",
      VaquamarRe: "66cdaa",
      VXe: "cd",
      VScEd: "ba55d3",
      VpurpN: "9370db",
      VsHgYF: "3cb371",
      VUXe: "7b68ee",
      VsprRggYF: "fa9a",
      VQe: "48d1cc",
      VviTetYd: "c71585",
      midnightXe: "191970",
      mRtcYam: "f5fffa",
      mistyPse: "ffe4e1",
      moccasR: "ffe4b5",
      navajowEte: "ffdead",
      navy: "80",
      Tdlace: "fdf5e6",
      Tive: "808000",
      TivedBb: "6b8e23",
      Sange: "ffa500",
      SangeYd: "ff4500",
      ScEd: "da70d6",
      pOegTMnPd: "eee8aa",
      pOegYF: "98fb98",
      pOeQe: "afeeee",
      pOeviTetYd: "db7093",
      papayawEp: "ffefd5",
      pHKpuff: "ffdab9",
      peru: "cd853f",
      pRk: "ffc0cb",
      plum: "dda0dd",
      powMrXe: "b0e0e6",
      purpN: "800080",
      YbeccapurpN: "663399",
      Yd: "ff0000",
      Psybrown: "bc8f8f",
      PyOXe: "4169e1",
      saddNbPwn: "8b4513",
      sOmon: "fa8072",
      sandybPwn: "f4a460",
      sHgYF: "2e8b57",
      sHshell: "fff5ee",
      siFna: "a0522d",
      silver: "c0c0c0",
      skyXe: "87ceeb",
      UXe: "6a5acd",
      UWay: "708090",
      UgYy: "708090",
      snow: "fffafa",
      sprRggYF: "ff7f",
      stAlXe: "4682b4",
      tan: "d2b48c",
      teO: "8080",
      tEstN: "d8bfd8",
      tomato: "ff6347",
      Qe: "40e0d0",
      viTet: "ee82ee",
      JHt: "f5deb3",
      wEte: "ffffff",
      wEtesmoke: "f5f5f5",
      Lw: "ffff00",
      LwgYF: "9acd32"
    };
    function unpack() {
      const unpacked = {};
      const keys2 = Object.keys(names$1);
      const tkeys = Object.keys(map$2);
      let i, j, k, ok, nk;
      for (i = 0; i < keys2.length; i++) {
        ok = nk = keys2[i];
        for (j = 0; j < tkeys.length; j++) {
          k = tkeys[j];
          nk = nk.replace(k, map$2[k]);
        }
        k = parseInt(names$1[ok], 16);
        unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
      }
      return unpacked;
    }
    let names;
    function nameParse(str) {
      if (!names) {
        names = unpack();
        names.transparent = [0, 0, 0, 0];
      }
      const a = names[str.toLowerCase()];
      return a && {
        r: a[0],
        g: a[1],
        b: a[2],
        a: a.length === 4 ? a[3] : 255
      };
    }
    const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
    function rgbParse(str) {
      const m = RGB_RE.exec(str);
      let a = 255;
      let r, g, b;
      if (!m) {
        return;
      }
      if (m[7] !== r) {
        const v = +m[7];
        a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
      }
      r = +m[1];
      g = +m[3];
      b = +m[5];
      r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
      g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
      b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
      return {
        r,
        g,
        b,
        a
      };
    }
    function rgbString(v) {
      return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
    }
    const to$1 = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
    const from$1 = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
    function interpolate$1(rgb1, rgb2, t) {
      const r = from$1(b2n(rgb1.r));
      const g = from$1(b2n(rgb1.g));
      const b = from$1(b2n(rgb1.b));
      return {
        r: n2b(to$1(r + t * (from$1(b2n(rgb2.r)) - r))),
        g: n2b(to$1(g + t * (from$1(b2n(rgb2.g)) - g))),
        b: n2b(to$1(b + t * (from$1(b2n(rgb2.b)) - b))),
        a: rgb1.a + t * (rgb2.a - rgb1.a)
      };
    }
    function modHSL(v, i, ratio) {
      if (v) {
        let tmp = rgb2hsl(v);
        tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
        tmp = hsl2rgb(tmp);
        v.r = tmp[0];
        v.g = tmp[1];
        v.b = tmp[2];
      }
    }
    function clone$3(v, proto2) {
      return v ? Object.assign(proto2 || {}, v) : v;
    }
    function fromObject(input) {
      var v = { r: 0, g: 0, b: 0, a: 255 };
      if (Array.isArray(input)) {
        if (input.length >= 3) {
          v = { r: input[0], g: input[1], b: input[2], a: 255 };
          if (input.length > 3) {
            v.a = n2b(input[3]);
          }
        }
      } else {
        v = clone$3(input, { r: 0, g: 0, b: 0, a: 1 });
        v.a = n2b(v.a);
      }
      return v;
    }
    function functionParse(str) {
      if (str.charAt(0) === "r") {
        return rgbParse(str);
      }
      return hueParse(str);
    }
    class Color {
      constructor(input) {
        if (input instanceof Color) {
          return input;
        }
        const type = typeof input;
        let v;
        if (type === "object") {
          v = fromObject(input);
        } else if (type === "string") {
          v = hexParse(input) || nameParse(input) || functionParse(input);
        }
        this._rgb = v;
        this._valid = !!v;
      }
      get valid() {
        return this._valid;
      }
      get rgb() {
        var v = clone$3(this._rgb);
        if (v) {
          v.a = b2n(v.a);
        }
        return v;
      }
      set rgb(obj) {
        this._rgb = fromObject(obj);
      }
      rgbString() {
        return this._valid ? rgbString(this._rgb) : void 0;
      }
      hexString() {
        return this._valid ? hexString(this._rgb) : void 0;
      }
      hslString() {
        return this._valid ? hslString(this._rgb) : void 0;
      }
      mix(color2, weight) {
        if (color2) {
          const c1 = this.rgb;
          const c2 = color2.rgb;
          let w2;
          const p = weight === w2 ? 0.5 : weight;
          const w = 2 * p - 1;
          const a = c1.a - c2.a;
          const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
          w2 = 1 - w1;
          c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
          c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
          c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
          c1.a = p * c1.a + (1 - p) * c2.a;
          this.rgb = c1;
        }
        return this;
      }
      interpolate(color2, t) {
        if (color2) {
          this._rgb = interpolate$1(this._rgb, color2._rgb, t);
        }
        return this;
      }
      clone() {
        return new Color(this.rgb);
      }
      alpha(a) {
        this._rgb.a = n2b(a);
        return this;
      }
      clearer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 - ratio;
        return this;
      }
      greyscale() {
        const rgb = this._rgb;
        const val = round$1(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
        rgb.r = rgb.g = rgb.b = val;
        return this;
      }
      opaquer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 + ratio;
        return this;
      }
      negate() {
        const v = this._rgb;
        v.r = 255 - v.r;
        v.g = 255 - v.g;
        v.b = 255 - v.b;
        return this;
      }
      lighten(ratio) {
        modHSL(this._rgb, 2, ratio);
        return this;
      }
      darken(ratio) {
        modHSL(this._rgb, 2, -ratio);
        return this;
      }
      saturate(ratio) {
        modHSL(this._rgb, 1, ratio);
        return this;
      }
      desaturate(ratio) {
        modHSL(this._rgb, 1, -ratio);
        return this;
      }
      rotate(deg) {
        rotate(this._rgb, deg);
        return this;
      }
    }
    /*!
     * Chart.js v4.4.7
     * https://www.chartjs.org
     * (c) 2024 Chart.js Contributors
     * Released under the MIT License
     */
    function noop() {
    }
    const uid = /* @__PURE__ */ (() => {
      let id = 0;
      return () => id++;
    })();
    function isNullOrUndef(value) {
      return value === null || value === void 0;
    }
    function isArray$1(value) {
      if (Array.isArray && Array.isArray(value)) {
        return true;
      }
      const type = Object.prototype.toString.call(value);
      if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
        return true;
      }
      return false;
    }
    function isObject$1(value) {
      return value !== null && Object.prototype.toString.call(value) === "[object Object]";
    }
    function isNumberFinite(value) {
      return (typeof value === "number" || value instanceof Number) && isFinite(+value);
    }
    function finiteOrDefault(value, defaultValue) {
      return isNumberFinite(value) ? value : defaultValue;
    }
    function valueOrDefault(value, defaultValue) {
      return typeof value === "undefined" ? defaultValue : value;
    }
    const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
    function callback(fn, args, thisArg) {
      if (fn && typeof fn.call === "function") {
        return fn.apply(thisArg, args);
      }
    }
    function each(loopable, fn, thisArg, reverse) {
      let i, len, keys2;
      if (isArray$1(loopable)) {
        len = loopable.length;
        {
          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[i], i);
          }
        }
      } else if (isObject$1(loopable)) {
        keys2 = Object.keys(loopable);
        len = keys2.length;
        for (i = 0; i < len; i++) {
          fn.call(thisArg, loopable[keys2[i]], keys2[i]);
        }
      }
    }
    function _elementsEqual(a0, a1) {
      let i, ilen, v0, v1;
      if (!a0 || !a1 || a0.length !== a1.length) {
        return false;
      }
      for (i = 0, ilen = a0.length; i < ilen; ++i) {
        v0 = a0[i];
        v1 = a1[i];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
          return false;
        }
      }
      return true;
    }
    function clone$2(source) {
      if (isArray$1(source)) {
        return source.map(clone$2);
      }
      if (isObject$1(source)) {
        const target = /* @__PURE__ */ Object.create(null);
        const keys2 = Object.keys(source);
        const klen = keys2.length;
        let k = 0;
        for (; k < klen; ++k) {
          target[keys2[k]] = clone$2(source[keys2[k]]);
        }
        return target;
      }
      return source;
    }
    function isValidKey(key) {
      return [
        "__proto__",
        "prototype",
        "constructor"
      ].indexOf(key) === -1;
    }
    function _merger(key, target, source, options) {
      if (!isValidKey(key)) {
        return;
      }
      const tval = target[key];
      const sval = source[key];
      if (isObject$1(tval) && isObject$1(sval)) {
        merge(tval, sval, options);
      } else {
        target[key] = clone$2(sval);
      }
    }
    function merge(target, source, options) {
      const sources = isArray$1(source) ? source : [
        source
      ];
      const ilen = sources.length;
      if (!isObject$1(target)) {
        return target;
      }
      options = options || {};
      const merger = options.merger || _merger;
      let current;
      for (let i = 0; i < ilen; ++i) {
        current = sources[i];
        if (!isObject$1(current)) {
          continue;
        }
        const keys2 = Object.keys(current);
        for (let k = 0, klen = keys2.length; k < klen; ++k) {
          merger(keys2[k], target, current, options);
        }
      }
      return target;
    }
    function mergeIf(target, source) {
      return merge(target, source, {
        merger: _mergerIf
      });
    }
    function _mergerIf(key, target, source) {
      if (!isValidKey(key)) {
        return;
      }
      const tval = target[key];
      const sval = source[key];
      if (isObject$1(tval) && isObject$1(sval)) {
        mergeIf(tval, sval);
      } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
        target[key] = clone$2(sval);
      }
    }
    const keyResolvers = {
      // Chart.helpers.core resolveObjectKey should resolve empty key to root object
      "": (v) => v,
      // default resolvers
      x: (o) => o.x,
      y: (o) => o.y
    };
    function _splitKey(key) {
      const parts = key.split(".");
      const keys2 = [];
      let tmp = "";
      for (const part of parts) {
        tmp += part;
        if (tmp.endsWith("\\")) {
          tmp = tmp.slice(0, -1) + ".";
        } else {
          keys2.push(tmp);
          tmp = "";
        }
      }
      return keys2;
    }
    function _getKeyResolver(key) {
      const keys2 = _splitKey(key);
      return (obj) => {
        for (const k of keys2) {
          if (k === "") {
            break;
          }
          obj = obj && obj[k];
        }
        return obj;
      };
    }
    function resolveObjectKey(obj, key) {
      const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
      return resolver(obj);
    }
    function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    const defined = (value) => typeof value !== "undefined";
    const isFunction$1 = (value) => typeof value === "function";
    const setsEqual = (a, b) => {
      if (a.size !== b.size) {
        return false;
      }
      for (const item of a) {
        if (!b.has(item)) {
          return false;
        }
      }
      return true;
    };
    function _isClickEvent(e) {
      return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
    }
    const PI = Math.PI;
    const TAU = 2 * PI;
    const PITAU = TAU + PI;
    const INFINITY = Number.POSITIVE_INFINITY;
    const RAD_PER_DEG = PI / 180;
    const HALF_PI = PI / 2;
    const QUARTER_PI = PI / 4;
    const TWO_THIRDS_PI = PI * 2 / 3;
    const log10 = Math.log10;
    const sign$1 = Math.sign;
    function almostEquals(x, y, epsilon) {
      return Math.abs(x - y) < epsilon;
    }
    function niceNum(range2) {
      const roundedRange = Math.round(range2);
      range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
      const niceRange = Math.pow(10, Math.floor(log10(range2)));
      const fraction = range2 / niceRange;
      const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
      return niceFraction * niceRange;
    }
    function _factorize(value) {
      const result = [];
      const sqrt = Math.sqrt(value);
      let i;
      for (i = 1; i < sqrt; i++) {
        if (value % i === 0) {
          result.push(i);
          result.push(value / i);
        }
      }
      if (sqrt === (sqrt | 0)) {
        result.push(sqrt);
      }
      result.sort((a, b) => a - b).pop();
      return result;
    }
    function isNumber$1(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    function almostWhole(x, epsilon) {
      const rounded = Math.round(x);
      return rounded - epsilon <= x && rounded + epsilon >= x;
    }
    function _setMinAndMaxByKey(array, target, property) {
      let i, ilen, value;
      for (i = 0, ilen = array.length; i < ilen; i++) {
        value = array[i][property];
        if (!isNaN(value)) {
          target.min = Math.min(target.min, value);
          target.max = Math.max(target.max, value);
        }
      }
    }
    function toRadians(degrees) {
      return degrees * (PI / 180);
    }
    function toDegrees(radians) {
      return radians * (180 / PI);
    }
    function _decimalPlaces(x) {
      if (!isNumberFinite(x)) {
        return;
      }
      let e = 1;
      let p = 0;
      while (Math.round(x * e) / e !== x) {
        e *= 10;
        p++;
      }
      return p;
    }
    function getAngleFromPoint(centrePoint, anglePoint) {
      const distanceFromXCenter = anglePoint.x - centrePoint.x;
      const distanceFromYCenter = anglePoint.y - centrePoint.y;
      const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
      let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
      if (angle < -0.5 * PI) {
        angle += TAU;
      }
      return {
        angle,
        distance: radialDistanceFromCenter
      };
    }
    function distanceBetweenPoints(pt1, pt2) {
      return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
    }
    function _angleDiff(a, b) {
      return (a - b + PITAU) % TAU - PI;
    }
    function _normalizeAngle(a) {
      return (a % TAU + TAU) % TAU;
    }
    function _angleBetween(angle, start2, end2, sameAngleIsFullCircle) {
      const a = _normalizeAngle(angle);
      const s = _normalizeAngle(start2);
      const e = _normalizeAngle(end2);
      const angleToStart = _normalizeAngle(s - a);
      const angleToEnd = _normalizeAngle(e - a);
      const startToAngle = _normalizeAngle(a - s);
      const endToAngle = _normalizeAngle(a - e);
      return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
    }
    function _limitValue(value, min2, max2) {
      return Math.max(min2, Math.min(max2, value));
    }
    function _int16Range(value) {
      return _limitValue(value, -32768, 32767);
    }
    function _isBetween(value, start2, end2, epsilon = 1e-6) {
      return value >= Math.min(start2, end2) - epsilon && value <= Math.max(start2, end2) + epsilon;
    }
    function _lookup(table, value, cmp) {
      cmp = cmp || ((index2) => table[index2] < value);
      let hi = table.length - 1;
      let lo = 0;
      let mid;
      while (hi - lo > 1) {
        mid = lo + hi >> 1;
        if (cmp(mid)) {
          lo = mid;
        } else {
          hi = mid;
        }
      }
      return {
        lo,
        hi
      };
    }
    const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
      const ti = table[index2][key];
      return ti < value || ti === value && table[index2 + 1][key] === value;
    } : (index2) => table[index2][key] < value);
    const _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
    function _filterBetween(values, min2, max2) {
      let start2 = 0;
      let end2 = values.length;
      while (start2 < end2 && values[start2] < min2) {
        start2++;
      }
      while (end2 > start2 && values[end2 - 1] > max2) {
        end2--;
      }
      return start2 > 0 || end2 < values.length ? values.slice(start2, end2) : values;
    }
    const arrayEvents = [
      "push",
      "pop",
      "shift",
      "splice",
      "unshift"
    ];
    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
      }
      Object.defineProperty(array, "_chartjs", {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [
            listener
          ]
        }
      });
      arrayEvents.forEach((key) => {
        const method = "_onData" + _capitalize(key);
        const base = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value(...args) {
            const res = base.apply(this, args);
            array._chartjs.listeners.forEach((object) => {
              if (typeof object[method] === "function") {
                object[method](...args);
              }
            });
            return res;
          }
        });
      });
    }
    function unlistenArrayEvents(array, listener) {
      const stub = array._chartjs;
      if (!stub) {
        return;
      }
      const listeners = stub.listeners;
      const index2 = listeners.indexOf(listener);
      if (index2 !== -1) {
        listeners.splice(index2, 1);
      }
      if (listeners.length > 0) {
        return;
      }
      arrayEvents.forEach((key) => {
        delete array[key];
      });
      delete array._chartjs;
    }
    function _arrayUnique(items) {
      const set2 = new Set(items);
      if (set2.size === items.length) {
        return items;
      }
      return Array.from(set2);
    }
    const requestAnimFrame = function() {
      if (typeof window === "undefined") {
        return function(callback2) {
          return callback2();
        };
      }
      return window.requestAnimationFrame;
    }();
    function throttled(fn, thisArg) {
      let argsToUse = [];
      let ticking = false;
      return function(...args) {
        argsToUse = args;
        if (!ticking) {
          ticking = true;
          requestAnimFrame.call(window, () => {
            ticking = false;
            fn.apply(thisArg, argsToUse);
          });
        }
      };
    }
    function debounce(fn, delay) {
      let timeout;
      return function(...args) {
        if (delay) {
          clearTimeout(timeout);
          timeout = setTimeout(fn, delay, args);
        } else {
          fn.apply(this, args);
        }
        return delay;
      };
    }
    const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
    const _alignStartEnd = (align, start2, end2) => align === "start" ? start2 : align === "end" ? end2 : (start2 + end2) / 2;
    function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
      const pointCount = points.length;
      let start2 = 0;
      let count = pointCount;
      if (meta._sorted) {
        const { iScale, _parsed } = meta;
        const axis = iScale.axis;
        const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
        if (minDefined) {
          start2 = _limitValue(Math.min(
            // @ts-expect-error Need to type _parsed
            _lookupByKey(_parsed, axis, min2).lo,
            // @ts-expect-error Need to fix types on _lookupByKey
            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min2)).lo
          ), 0, pointCount - 1);
        }
        if (maxDefined) {
          count = _limitValue(Math.max(
            // @ts-expect-error Need to type _parsed
            _lookupByKey(_parsed, iScale.axis, max2, true).hi + 1,
            // @ts-expect-error Need to fix types on _lookupByKey
            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max2), true).hi + 1
          ), start2, pointCount) - start2;
        } else {
          count = pointCount - start2;
        }
      }
      return {
        start: start2,
        count
      };
    }
    function _scaleRangesChanged(meta) {
      const { xScale, yScale, _scaleRanges } = meta;
      const newRanges = {
        xmin: xScale.min,
        xmax: xScale.max,
        ymin: yScale.min,
        ymax: yScale.max
      };
      if (!_scaleRanges) {
        meta._scaleRanges = newRanges;
        return true;
      }
      const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
      Object.assign(_scaleRanges, newRanges);
      return changed;
    }
    const atEdge = (t) => t === 0 || t === 1;
    const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
    const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
    const effects = {
      linear: (t) => t,
      easeInQuad: (t) => t * t,
      easeOutQuad: (t) => -t * (t - 2),
      easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
      easeInCubic: (t) => t * t * t,
      easeOutCubic: (t) => (t -= 1) * t * t + 1,
      easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
      easeInQuart: (t) => t * t * t * t,
      easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
      easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
      easeInQuint: (t) => t * t * t * t * t,
      easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
      easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
      easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
      easeOutSine: (t) => Math.sin(t * HALF_PI),
      easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
      easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
      easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
      easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
      easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
      easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
      easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
      easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
      easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
      easeInOutElastic(t) {
        const s = 0.1125;
        const p = 0.45;
        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
      },
      easeInBack(t) {
        const s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack(t) {
        const s = 1.70158;
        return (t -= 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack(t) {
        let s = 1.70158;
        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }
        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
      easeOutBounce(t) {
        const m = 7.5625;
        const d = 2.75;
        if (t < 1 / d) {
          return m * t * t;
        }
        if (t < 2 / d) {
          return m * (t -= 1.5 / d) * t + 0.75;
        }
        if (t < 2.5 / d) {
          return m * (t -= 2.25 / d) * t + 0.9375;
        }
        return m * (t -= 2.625 / d) * t + 0.984375;
      },
      easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
    };
    function isPatternOrGradient(value) {
      if (value && typeof value === "object") {
        const type = value.toString();
        return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
      }
      return false;
    }
    function color$1(value) {
      return isPatternOrGradient(value) ? value : new Color(value);
    }
    function getHoverColor(value) {
      return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
    }
    const numbers = [
      "x",
      "y",
      "borderWidth",
      "radius",
      "tension"
    ];
    const colors$1 = [
      "color",
      "borderColor",
      "backgroundColor"
    ];
    function applyAnimationsDefaults(defaults2) {
      defaults2.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
      });
      defaults2.describe("animation", {
        _fallback: false,
        _indexable: false,
        _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
      });
      defaults2.set("animations", {
        colors: {
          type: "color",
          properties: colors$1
        },
        numbers: {
          type: "number",
          properties: numbers
        }
      });
      defaults2.describe("animations", {
        _fallback: "animation"
      });
      defaults2.set("transitions", {
        active: {
          animation: {
            duration: 400
          }
        },
        resize: {
          animation: {
            duration: 0
          }
        },
        show: {
          animations: {
            colors: {
              from: "transparent"
            },
            visible: {
              type: "boolean",
              duration: 0
            }
          }
        },
        hide: {
          animations: {
            colors: {
              to: "transparent"
            },
            visible: {
              type: "boolean",
              easing: "linear",
              fn: (v) => v | 0
            }
          }
        }
      });
    }
    function applyLayoutsDefaults(defaults2) {
      defaults2.set("layout", {
        autoPadding: true,
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      });
    }
    const intlCache = /* @__PURE__ */ new Map();
    function getNumberFormat(locale2, options) {
      options = options || {};
      const cacheKey = locale2 + JSON.stringify(options);
      let formatter = intlCache.get(cacheKey);
      if (!formatter) {
        formatter = new Intl.NumberFormat(locale2, options);
        intlCache.set(cacheKey, formatter);
      }
      return formatter;
    }
    function formatNumber(num, locale2, options) {
      return getNumberFormat(locale2, options).format(num);
    }
    const formatters = {
      values(value) {
        return isArray$1(value) ? value : "" + value;
      },
      numeric(tickValue, index2, ticks) {
        if (tickValue === 0) {
          return "0";
        }
        const locale2 = this.chart.options.locale;
        let notation;
        let delta = tickValue;
        if (ticks.length > 1) {
          const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
          if (maxTick < 1e-4 || maxTick > 1e15) {
            notation = "scientific";
          }
          delta = calculateDelta(tickValue, ticks);
        }
        const logDelta = log10(Math.abs(delta));
        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        const options = {
          notation,
          minimumFractionDigits: numDecimal,
          maximumFractionDigits: numDecimal
        };
        Object.assign(options, this.options.ticks.format);
        return formatNumber(tickValue, locale2, options);
      },
      logarithmic(tickValue, index2, ticks) {
        if (tickValue === 0) {
          return "0";
        }
        const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
        if ([
          1,
          2,
          3,
          5,
          10,
          15
        ].includes(remain) || index2 > 0.8 * ticks.length) {
          return formatters.numeric.call(this, tickValue, index2, ticks);
        }
        return "";
      }
    };
    function calculateDelta(tickValue, ticks) {
      let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
      if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
        delta = tickValue - Math.floor(tickValue);
      }
      return delta;
    }
    var Ticks = {
      formatters
    };
    function applyScaleDefaults(defaults2) {
      defaults2.set("scale", {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
        bounds: "ticks",
        clip: true,
        grace: 0,
        grid: {
          display: true,
          lineWidth: 1,
          drawOnChartArea: true,
          drawTicks: true,
          tickLength: 8,
          tickWidth: (_ctx, options) => options.lineWidth,
          tickColor: (_ctx, options) => options.color,
          offset: false
        },
        border: {
          display: true,
          dash: [],
          dashOffset: 0,
          width: 1
        },
        title: {
          display: false,
          text: "",
          padding: {
            top: 4,
            bottom: 4
          }
        },
        ticks: {
          minRotation: 0,
          maxRotation: 50,
          mirror: false,
          textStrokeWidth: 0,
          textStrokeColor: "",
          padding: 3,
          display: true,
          autoSkip: true,
          autoSkipPadding: 3,
          labelOffset: 0,
          callback: Ticks.formatters.values,
          minor: {},
          major: {},
          align: "center",
          crossAlign: "near",
          showLabelBackdrop: false,
          backdropColor: "rgba(255, 255, 255, 0.75)",
          backdropPadding: 2
        }
      });
      defaults2.route("scale.ticks", "color", "", "color");
      defaults2.route("scale.grid", "color", "", "borderColor");
      defaults2.route("scale.border", "color", "", "borderColor");
      defaults2.route("scale.title", "color", "", "color");
      defaults2.describe("scale", {
        _fallback: false,
        _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
        _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
      });
      defaults2.describe("scales", {
        _fallback: "scale"
      });
      defaults2.describe("scale.ticks", {
        _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
        _indexable: (name) => name !== "backdropPadding"
      });
    }
    const overrides = /* @__PURE__ */ Object.create(null);
    const descriptors = /* @__PURE__ */ Object.create(null);
    function getScope$1(node, key) {
      if (!key) {
        return node;
      }
      const keys2 = key.split(".");
      for (let i = 0, n = keys2.length; i < n; ++i) {
        const k = keys2[i];
        node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
      }
      return node;
    }
    function set$2(root, scope, values) {
      if (typeof scope === "string") {
        return merge(getScope$1(root, scope), values);
      }
      return merge(getScope$1(root, ""), scope);
    }
    class Defaults {
      constructor(_descriptors2, _appliers) {
        this.animation = void 0;
        this.backgroundColor = "rgba(0,0,0,0.1)";
        this.borderColor = "rgba(0,0,0,0.1)";
        this.color = "#666";
        this.datasets = {};
        this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
        this.elements = {};
        this.events = [
          "mousemove",
          "mouseout",
          "click",
          "touchstart",
          "touchmove"
        ];
        this.font = {
          family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
          size: 12,
          style: "normal",
          lineHeight: 1.2,
          weight: null
        };
        this.hover = {};
        this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
        this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
        this.hoverColor = (ctx, options) => getHoverColor(options.color);
        this.indexAxis = "x";
        this.interaction = {
          mode: "nearest",
          intersect: true,
          includeInvisible: false
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = void 0;
        this.scales = {};
        this.showLine = true;
        this.drawActiveElementsOnTop = true;
        this.describe(_descriptors2);
        this.apply(_appliers);
      }
      set(scope, values) {
        return set$2(this, scope, values);
      }
      get(scope) {
        return getScope$1(this, scope);
      }
      describe(scope, values) {
        return set$2(descriptors, scope, values);
      }
      override(scope, values) {
        return set$2(overrides, scope, values);
      }
      route(scope, name, targetScope, targetName) {
        const scopeObject = getScope$1(this, scope);
        const targetScopeObject = getScope$1(this, targetScope);
        const privateName = "_" + name;
        Object.defineProperties(scopeObject, {
          [privateName]: {
            value: scopeObject[name],
            writable: true
          },
          [name]: {
            enumerable: true,
            get() {
              const local = this[privateName];
              const target = targetScopeObject[targetName];
              if (isObject$1(local)) {
                return Object.assign({}, target, local);
              }
              return valueOrDefault(local, target);
            },
            set(value) {
              this[privateName] = value;
            }
          }
        });
      }
      apply(appliers) {
        appliers.forEach((apply) => apply(this));
      }
    }
    var defaults$2 = /* @__PURE__ */ new Defaults({
      _scriptable: (name) => !name.startsWith("on"),
      _indexable: (name) => name !== "events",
      hover: {
        _fallback: "interaction"
      },
      interaction: {
        _scriptable: false,
        _indexable: false
      }
    }, [
      applyAnimationsDefaults,
      applyLayoutsDefaults,
      applyScaleDefaults
    ]);
    function toFontString(font) {
      if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
        return null;
      }
      return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
    }
    function _measureText(ctx, data, gc, longest, string) {
      let textWidth = data[string];
      if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
      }
      if (textWidth > longest) {
        longest = textWidth;
      }
      return longest;
    }
    function _alignPixel(chart, pixel, width) {
      const devicePixelRatio = chart.currentDevicePixelRatio;
      const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
      return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
    }
    function clearCanvas(canvas, ctx) {
      if (!ctx && !canvas) {
        return;
      }
      ctx = ctx || canvas.getContext("2d");
      ctx.save();
      ctx.resetTransform();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
    function drawPoint(ctx, options, x, y) {
      drawPointLegend(ctx, options, x, y);
    }
    function drawPointLegend(ctx, options, x, y, w) {
      let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
      const style = options.pointStyle;
      const rotation = options.rotation;
      const radius = options.radius;
      let rad = (rotation || 0) * RAD_PER_DEG;
      if (style && typeof style === "object") {
        type = style.toString();
        if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(rad);
          ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
          ctx.restore();
          return;
        }
      }
      if (isNaN(radius) || radius <= 0) {
        return;
      }
      ctx.beginPath();
      switch (style) {
        // Default includes circle
        default:
          {
            ctx.arc(x, y, radius, 0, TAU);
          }
          ctx.closePath();
          break;
        case "triangle":
          width = radius;
          ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
          rad += TWO_THIRDS_PI;
          ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
          rad += TWO_THIRDS_PI;
          ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
          ctx.closePath();
          break;
        case "rectRounded":
          cornerRadius = radius * 0.516;
          size = radius - cornerRadius;
          xOffset = Math.cos(rad + QUARTER_PI) * size;
          xOffsetW = Math.cos(rad + QUARTER_PI) * size;
          yOffset = Math.sin(rad + QUARTER_PI) * size;
          yOffsetW = Math.sin(rad + QUARTER_PI) * size;
          ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
          ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
          ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
          ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
          ctx.closePath();
          break;
        case "rect":
          if (!rotation) {
            size = Math.SQRT1_2 * radius;
            width = size;
            ctx.rect(x - width, y - size, 2 * width, 2 * size);
            break;
          }
          rad += QUARTER_PI;
        /* falls through */
        case "rectRot":
          xOffsetW = Math.cos(rad) * radius;
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          yOffsetW = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffsetW, y - yOffset);
          ctx.lineTo(x + yOffsetW, y - xOffset);
          ctx.lineTo(x + xOffsetW, y + yOffset);
          ctx.lineTo(x - yOffsetW, y + xOffset);
          ctx.closePath();
          break;
        case "crossRot":
          rad += QUARTER_PI;
        /* falls through */
        case "cross":
          xOffsetW = Math.cos(rad) * radius;
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          yOffsetW = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffsetW, y - yOffset);
          ctx.lineTo(x + xOffsetW, y + yOffset);
          ctx.moveTo(x + yOffsetW, y - xOffset);
          ctx.lineTo(x - yOffsetW, y + xOffset);
          break;
        case "star":
          xOffsetW = Math.cos(rad) * radius;
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          yOffsetW = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffsetW, y - yOffset);
          ctx.lineTo(x + xOffsetW, y + yOffset);
          ctx.moveTo(x + yOffsetW, y - xOffset);
          ctx.lineTo(x - yOffsetW, y + xOffset);
          rad += QUARTER_PI;
          xOffsetW = Math.cos(rad) * radius;
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          yOffsetW = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffsetW, y - yOffset);
          ctx.lineTo(x + xOffsetW, y + yOffset);
          ctx.moveTo(x + yOffsetW, y - xOffset);
          ctx.lineTo(x - yOffsetW, y + xOffset);
          break;
        case "line":
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          break;
        case "dash":
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
          break;
        case false:
          ctx.closePath();
          break;
      }
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    function _isPointInArea(point, area, margin) {
      margin = margin || 0.5;
      return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
    }
    function clipArea(ctx, area) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
      ctx.clip();
    }
    function unclipArea(ctx) {
      ctx.restore();
    }
    function _steppedLineTo(ctx, previous, target, flip2, mode) {
      if (!previous) {
        return ctx.lineTo(target.x, target.y);
      }
      if (mode === "middle") {
        const midpoint = (previous.x + target.x) / 2;
        ctx.lineTo(midpoint, previous.y);
        ctx.lineTo(midpoint, target.y);
      } else if (mode === "after" !== !!flip2) {
        ctx.lineTo(previous.x, target.y);
      } else {
        ctx.lineTo(target.x, previous.y);
      }
      ctx.lineTo(target.x, target.y);
    }
    function _bezierCurveTo(ctx, previous, target, flip2) {
      if (!previous) {
        return ctx.lineTo(target.x, target.y);
      }
      ctx.bezierCurveTo(flip2 ? previous.cp1x : previous.cp2x, flip2 ? previous.cp1y : previous.cp2y, flip2 ? target.cp2x : target.cp1x, flip2 ? target.cp2y : target.cp1y, target.x, target.y);
    }
    function setRenderOpts(ctx, opts) {
      if (opts.translation) {
        ctx.translate(opts.translation[0], opts.translation[1]);
      }
      if (!isNullOrUndef(opts.rotation)) {
        ctx.rotate(opts.rotation);
      }
      if (opts.color) {
        ctx.fillStyle = opts.color;
      }
      if (opts.textAlign) {
        ctx.textAlign = opts.textAlign;
      }
      if (opts.textBaseline) {
        ctx.textBaseline = opts.textBaseline;
      }
    }
    function decorateText(ctx, x, y, line, opts) {
      if (opts.strikethrough || opts.underline) {
        const metrics = ctx.measureText(line);
        const left2 = x - metrics.actualBoundingBoxLeft;
        const right2 = x + metrics.actualBoundingBoxRight;
        const top2 = y - metrics.actualBoundingBoxAscent;
        const bottom2 = y + metrics.actualBoundingBoxDescent;
        const yDecoration = opts.strikethrough ? (top2 + bottom2) / 2 : bottom2;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left2, yDecoration);
        ctx.lineTo(right2, yDecoration);
        ctx.stroke();
      }
    }
    function drawBackdrop(ctx, opts) {
      const oldColor = ctx.fillStyle;
      ctx.fillStyle = opts.color;
      ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
      ctx.fillStyle = oldColor;
    }
    function renderText(ctx, text, x, y, font, opts = {}) {
      const lines = isArray$1(text) ? text : [
        text
      ];
      const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
      let i, line;
      ctx.save();
      ctx.font = font.string;
      setRenderOpts(ctx, opts);
      for (i = 0; i < lines.length; ++i) {
        line = lines[i];
        if (opts.backdrop) {
          drawBackdrop(ctx, opts.backdrop);
        }
        if (stroke) {
          if (opts.strokeColor) {
            ctx.strokeStyle = opts.strokeColor;
          }
          if (!isNullOrUndef(opts.strokeWidth)) {
            ctx.lineWidth = opts.strokeWidth;
          }
          ctx.strokeText(line, x, y, opts.maxWidth);
        }
        ctx.fillText(line, x, y, opts.maxWidth);
        decorateText(ctx, x, y, line, opts);
        y += Number(font.lineHeight);
      }
      ctx.restore();
    }
    function addRoundedRectPath(ctx, rect) {
      const { x, y, w, h, radius } = rect;
      ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
      ctx.lineTo(x, y + h - radius.bottomLeft);
      ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
      ctx.lineTo(x + w - radius.bottomRight, y + h);
      ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
      ctx.lineTo(x + w, y + radius.topRight);
      ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
      ctx.lineTo(x + radius.topLeft, y);
    }
    const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
    const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
    function toLineHeight(value, size) {
      const matches = ("" + value).match(LINE_HEIGHT);
      if (!matches || matches[1] === "normal") {
        return size * 1.2;
      }
      value = +matches[2];
      switch (matches[3]) {
        case "px":
          return value;
        case "%":
          value /= 100;
          break;
      }
      return size * value;
    }
    const numberOrZero = (v) => +v || 0;
    function _readValueToProps(value, props) {
      const ret = {};
      const objProps = isObject$1(props);
      const keys2 = objProps ? Object.keys(props) : props;
      const read2 = isObject$1(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
      for (const prop of keys2) {
        ret[prop] = numberOrZero(read2(prop));
      }
      return ret;
    }
    function toTRBL(value) {
      return _readValueToProps(value, {
        top: "y",
        right: "x",
        bottom: "y",
        left: "x"
      });
    }
    function toTRBLCorners(value) {
      return _readValueToProps(value, [
        "topLeft",
        "topRight",
        "bottomLeft",
        "bottomRight"
      ]);
    }
    function toPadding(value) {
      const obj = toTRBL(value);
      obj.width = obj.left + obj.right;
      obj.height = obj.top + obj.bottom;
      return obj;
    }
    function toFont(options, fallback) {
      options = options || {};
      fallback = fallback || defaults$2.font;
      let size = valueOrDefault(options.size, fallback.size);
      if (typeof size === "string") {
        size = parseInt(size, 10);
      }
      let style = valueOrDefault(options.style, fallback.style);
      if (style && !("" + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = void 0;
      }
      const font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size,
        style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: ""
      };
      font.string = toFontString(font);
      return font;
    }
    function resolve(inputs, context, index2, info) {
      let i, ilen, value;
      for (i = 0, ilen = inputs.length; i < ilen; ++i) {
        value = inputs[i];
        if (value === void 0) {
          continue;
        }
        if (value !== void 0) {
          return value;
        }
      }
    }
    function _addGrace(minmax, grace, beginAtZero) {
      const { min: min2, max: max2 } = minmax;
      const change = toDimension(grace, (max2 - min2) / 2);
      const keepZero = (value, add2) => beginAtZero && value === 0 ? 0 : value + add2;
      return {
        min: keepZero(min2, -Math.abs(change)),
        max: keepZero(max2, change)
      };
    }
    function createContext(parentContext, context) {
      return Object.assign(Object.create(parentContext), context);
    }
    function _createResolver(scopes, prefixes = [
      ""
    ], rootScopes, fallback, getTarget = () => scopes[0]) {
      const finalRootScopes = rootScopes || scopes;
      if (typeof fallback === "undefined") {
        fallback = _resolve("_fallback", scopes);
      }
      const cache = {
        [Symbol.toStringTag]: "Object",
        _cacheable: true,
        _scopes: scopes,
        _rootScopes: finalRootScopes,
        _fallback: fallback,
        _getTarget: getTarget,
        override: (scope) => _createResolver([
          scope,
          ...scopes
        ], prefixes, finalRootScopes, fallback)
      };
      return new Proxy(cache, {
        /**
        * A trap for the delete operator.
        */
        deleteProperty(target, prop) {
          delete target[prop];
          delete target._keys;
          delete scopes[0][prop];
          return true;
        },
        /**
        * A trap for getting property values.
        */
        get(target, prop) {
          return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
        },
        /**
        * A trap for Object.getOwnPropertyDescriptor.
        * Also used by Object.hasOwnProperty.
        */
        getOwnPropertyDescriptor(target, prop) {
          return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        /**
        * A trap for Object.getPrototypeOf.
        */
        getPrototypeOf() {
          return Reflect.getPrototypeOf(scopes[0]);
        },
        /**
        * A trap for the in operator.
        */
        has(target, prop) {
          return getKeysFromAllScopes(target).includes(prop);
        },
        /**
        * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
        */
        ownKeys(target) {
          return getKeysFromAllScopes(target);
        },
        /**
        * A trap for setting property values.
        */
        set(target, prop, value) {
          const storage = target._storage || (target._storage = getTarget());
          target[prop] = storage[prop] = value;
          delete target._keys;
          return true;
        }
      });
    }
    function _attachContext(proxy, context, subProxy, descriptorDefaults) {
      const cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: /* @__PURE__ */ new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
        override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
      };
      return new Proxy(cache, {
        /**
        * A trap for the delete operator.
        */
        deleteProperty(target, prop) {
          delete target[prop];
          delete proxy[prop];
          return true;
        },
        /**
        * A trap for getting property values.
        */
        get(target, prop, receiver) {
          return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
        },
        /**
        * A trap for Object.getOwnPropertyDescriptor.
        * Also used by Object.hasOwnProperty.
        */
        getOwnPropertyDescriptor(target, prop) {
          return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
            enumerable: true,
            configurable: true
          } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        /**
        * A trap for Object.getPrototypeOf.
        */
        getPrototypeOf() {
          return Reflect.getPrototypeOf(proxy);
        },
        /**
        * A trap for the in operator.
        */
        has(target, prop) {
          return Reflect.has(proxy, prop);
        },
        /**
        * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
        */
        ownKeys() {
          return Reflect.ownKeys(proxy);
        },
        /**
        * A trap for setting property values.
        */
        set(target, prop, value) {
          proxy[prop] = value;
          delete target[prop];
          return true;
        }
      });
    }
    function _descriptors(proxy, defaults2 = {
      scriptable: true,
      indexable: true
    }) {
      const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
      return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction$1(_scriptable) ? _scriptable : () => _scriptable,
        isIndexable: isFunction$1(_indexable) ? _indexable : () => _indexable
      };
    }
    const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
    const needsSubResolver = (prop, value) => isObject$1(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
    function _cached(target, prop, resolve2) {
      if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
        return target[prop];
      }
      const value = resolve2();
      target[prop] = value;
      return value;
    }
    function _resolveWithContext(target, prop, receiver) {
      const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
      let value = _proxy[prop];
      if (isFunction$1(value) && descriptors2.isScriptable(prop)) {
        value = _resolveScriptable(prop, value, target, receiver);
      }
      if (isArray$1(value) && value.length) {
        value = _resolveArray(prop, value, target, descriptors2.isIndexable);
      }
      if (needsSubResolver(prop, value)) {
        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
      }
      return value;
    }
    function _resolveScriptable(prop, getValue, target, receiver) {
      const { _proxy, _context, _subProxy, _stack } = target;
      if (_stack.has(prop)) {
        throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
      }
      _stack.add(prop);
      let value = getValue(_context, _subProxy || receiver);
      _stack.delete(prop);
      if (needsSubResolver(prop, value)) {
        value = createSubResolver(_proxy._scopes, _proxy, prop, value);
      }
      return value;
    }
    function _resolveArray(prop, value, target, isIndexable) {
      const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
      if (typeof _context.index !== "undefined" && isIndexable(prop)) {
        return value[_context.index % value.length];
      } else if (isObject$1(value[0])) {
        const arr = value;
        const scopes = _proxy._scopes.filter((s) => s !== arr);
        value = [];
        for (const item of arr) {
          const resolver = createSubResolver(scopes, _proxy, prop, item);
          value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
        }
      }
      return value;
    }
    function resolveFallback(fallback, prop, value) {
      return isFunction$1(fallback) ? fallback(prop, value) : fallback;
    }
    const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
    function addScopes(set2, parentScopes, key, parentFallback, value) {
      for (const parent of parentScopes) {
        const scope = getScope(key, parent);
        if (scope) {
          set2.add(scope);
          const fallback = resolveFallback(scope._fallback, key, value);
          if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
            return fallback;
          }
        } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
          return null;
        }
      }
      return false;
    }
    function createSubResolver(parentScopes, resolver, prop, value) {
      const rootScopes = resolver._rootScopes;
      const fallback = resolveFallback(resolver._fallback, prop, value);
      const allScopes = [
        ...parentScopes,
        ...rootScopes
      ];
      const set2 = /* @__PURE__ */ new Set();
      set2.add(value);
      let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
      if (key === null) {
        return false;
      }
      if (typeof fallback !== "undefined" && fallback !== prop) {
        key = addScopesFromKey(set2, allScopes, fallback, key, value);
        if (key === null) {
          return false;
        }
      }
      return _createResolver(Array.from(set2), [
        ""
      ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
    }
    function addScopesFromKey(set2, allScopes, key, fallback, item) {
      while (key) {
        key = addScopes(set2, allScopes, key, fallback, item);
      }
      return key;
    }
    function subGetTarget(resolver, prop, value) {
      const parent = resolver._getTarget();
      if (!(prop in parent)) {
        parent[prop] = {};
      }
      const target = parent[prop];
      if (isArray$1(target) && isObject$1(value)) {
        return value;
      }
      return target || {};
    }
    function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
      let value;
      for (const prefix of prefixes) {
        value = _resolve(readKey(prefix, prop), scopes);
        if (typeof value !== "undefined") {
          return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
        }
      }
    }
    function _resolve(key, scopes) {
      for (const scope of scopes) {
        if (!scope) {
          continue;
        }
        const value = scope[key];
        if (typeof value !== "undefined") {
          return value;
        }
      }
    }
    function getKeysFromAllScopes(target) {
      let keys2 = target._keys;
      if (!keys2) {
        keys2 = target._keys = resolveKeysFromAllScopes(target._scopes);
      }
      return keys2;
    }
    function resolveKeysFromAllScopes(scopes) {
      const set2 = /* @__PURE__ */ new Set();
      for (const scope of scopes) {
        for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
          set2.add(key);
        }
      }
      return Array.from(set2);
    }
    const EPSILON = Number.EPSILON || 1e-14;
    const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
    const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
    function splineCurve(firstPoint, middlePoint, afterPoint, t) {
      const previous = firstPoint.skip ? middlePoint : firstPoint;
      const current = middlePoint;
      const next = afterPoint.skip ? middlePoint : afterPoint;
      const d01 = distanceBetweenPoints(current, previous);
      const d12 = distanceBetweenPoints(next, current);
      let s01 = d01 / (d01 + d12);
      let s12 = d12 / (d01 + d12);
      s01 = isNaN(s01) ? 0 : s01;
      s12 = isNaN(s12) ? 0 : s12;
      const fa = t * s01;
      const fb = t * s12;
      return {
        previous: {
          x: current.x - fa * (next.x - previous.x),
          y: current.y - fa * (next.y - previous.y)
        },
        next: {
          x: current.x + fb * (next.x - previous.x),
          y: current.y + fb * (next.y - previous.y)
        }
      };
    }
    function monotoneAdjust(points, deltaK, mK) {
      const pointsLen = points.length;
      let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (let i = 0; i < pointsLen - 1; ++i) {
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent || !pointAfter) {
          continue;
        }
        if (almostEquals(deltaK[i], 0, EPSILON)) {
          mK[i] = mK[i + 1] = 0;
          continue;
        }
        alphaK = mK[i] / deltaK[i];
        betaK = mK[i + 1] / deltaK[i];
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) {
          continue;
        }
        tauK = 3 / Math.sqrt(squaredMagnitude);
        mK[i] = alphaK * tauK * deltaK[i];
        mK[i + 1] = betaK * tauK * deltaK[i];
      }
    }
    function monotoneCompute(points, mK, indexAxis = "x") {
      const valueAxis = getValueAxis(indexAxis);
      const pointsLen = points.length;
      let delta, pointBefore, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (let i = 0; i < pointsLen; ++i) {
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
          continue;
        }
        const iPixel = pointCurrent[indexAxis];
        const vPixel = pointCurrent[valueAxis];
        if (pointBefore) {
          delta = (iPixel - pointBefore[indexAxis]) / 3;
          pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
          pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
        }
        if (pointAfter) {
          delta = (pointAfter[indexAxis] - iPixel) / 3;
          pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
          pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
        }
      }
    }
    function splineCurveMonotone(points, indexAxis = "x") {
      const valueAxis = getValueAxis(indexAxis);
      const pointsLen = points.length;
      const deltaK = Array(pointsLen).fill(0);
      const mK = Array(pointsLen);
      let i, pointBefore, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (i = 0; i < pointsLen; ++i) {
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
          continue;
        }
        if (pointAfter) {
          const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
          deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
        }
        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign$1(deltaK[i - 1]) !== sign$1(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
      }
      monotoneAdjust(points, deltaK, mK);
      monotoneCompute(points, mK, indexAxis);
    }
    function capControlPoint(pt, min2, max2) {
      return Math.max(Math.min(pt, max2), min2);
    }
    function capBezierPoints(points, area) {
      let i, ilen, point, inArea, inAreaPrev;
      let inAreaNext = _isPointInArea(points[0], area);
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        inAreaPrev = inArea;
        inArea = inAreaNext;
        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
        if (!inArea) {
          continue;
        }
        point = points[i];
        if (inAreaPrev) {
          point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
          point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
        }
        if (inAreaNext) {
          point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
          point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
        }
      }
    }
    function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
      let i, ilen, point, controlPoints;
      if (options.spanGaps) {
        points = points.filter((pt) => !pt.skip);
      }
      if (options.cubicInterpolationMode === "monotone") {
        splineCurveMonotone(points, indexAxis);
      } else {
        let prev = loop ? points[points.length - 1] : points[0];
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          point = points[i];
          controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
          point.cp1x = controlPoints.previous.x;
          point.cp1y = controlPoints.previous.y;
          point.cp2x = controlPoints.next.x;
          point.cp2y = controlPoints.next.y;
          prev = point;
        }
      }
      if (options.capBezierPoints) {
        capBezierPoints(points, area);
      }
    }
    function _isDomSupported() {
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function _getParentNode(domNode) {
      let parent = domNode.parentNode;
      if (parent && parent.toString() === "[object ShadowRoot]") {
        parent = parent.host;
      }
      return parent;
    }
    function parseMaxStyle(styleValue, node, parentProperty) {
      let valueInPixels;
      if (typeof styleValue === "string") {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf("%") !== -1) {
          valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
        }
      } else {
        valueInPixels = styleValue;
      }
      return valueInPixels;
    }
    const getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
    function getStyle(el, property) {
      return getComputedStyle(el).getPropertyValue(property);
    }
    const positions = [
      "top",
      "right",
      "bottom",
      "left"
    ];
    function getPositionedStyle(styles, style, suffix) {
      const result = {};
      suffix = suffix ? "-" + suffix : "";
      for (let i = 0; i < 4; i++) {
        const pos = positions[i];
        result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
      }
      result.width = result.left + result.right;
      result.height = result.top + result.bottom;
      return result;
    }
    const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
    function getCanvasPosition(e, canvas) {
      const touches = e.touches;
      const source = touches && touches.length ? touches[0] : e;
      const { offsetX, offsetY } = source;
      let box = false;
      let x, y;
      if (useOffsetPos(offsetX, offsetY, e.target)) {
        x = offsetX;
        y = offsetY;
      } else {
        const rect = canvas.getBoundingClientRect();
        x = source.clientX - rect.left;
        y = source.clientY - rect.top;
        box = true;
      }
      return {
        x,
        y,
        box
      };
    }
    function getRelativePosition(event, chart) {
      if ("native" in event) {
        return event;
      }
      const { canvas, currentDevicePixelRatio } = chart;
      const style = getComputedStyle(canvas);
      const borderBox = style.boxSizing === "border-box";
      const paddings = getPositionedStyle(style, "padding");
      const borders = getPositionedStyle(style, "border", "width");
      const { x, y, box } = getCanvasPosition(event, canvas);
      const xOffset = paddings.left + (box && borders.left);
      const yOffset = paddings.top + (box && borders.top);
      let { width, height } = chart;
      if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
      }
      return {
        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
      };
    }
    function getContainerSize(canvas, width, height) {
      let maxWidth, maxHeight;
      if (width === void 0 || height === void 0) {
        const container = canvas && _getParentNode(canvas);
        if (!container) {
          width = canvas.clientWidth;
          height = canvas.clientHeight;
        } else {
          const rect = container.getBoundingClientRect();
          const containerStyle = getComputedStyle(container);
          const containerBorder = getPositionedStyle(containerStyle, "border", "width");
          const containerPadding = getPositionedStyle(containerStyle, "padding");
          width = rect.width - containerPadding.width - containerBorder.width;
          height = rect.height - containerPadding.height - containerBorder.height;
          maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
          maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
        }
      }
      return {
        width,
        height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY
      };
    }
    const round1 = (v) => Math.round(v * 10) / 10;
    function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
      const style = getComputedStyle(canvas);
      const margins = getPositionedStyle(style, "margin");
      const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
      const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
      const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
      let { width, height } = containerSize;
      if (style.boxSizing === "content-box") {
        const borders = getPositionedStyle(style, "border", "width");
        const paddings = getPositionedStyle(style, "padding");
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
      }
      width = Math.max(0, width - margins.width);
      height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
      width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
      height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
      if (width && !height) {
        height = round1(width / 2);
      }
      const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
      if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
        height = containerSize.height;
        width = round1(Math.floor(height * aspectRatio));
      }
      return {
        width,
        height
      };
    }
    function retinaScale(chart, forceRatio, forceStyle) {
      const pixelRatio = forceRatio || 1;
      const deviceHeight = Math.floor(chart.height * pixelRatio);
      const deviceWidth = Math.floor(chart.width * pixelRatio);
      chart.height = Math.floor(chart.height);
      chart.width = Math.floor(chart.width);
      const canvas = chart.canvas;
      if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
        canvas.style.height = `${chart.height}px`;
        canvas.style.width = `${chart.width}px`;
      }
      if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
      }
      return false;
    }
    const supportsEventListenerOptions = function() {
      let passiveSupported = false;
      try {
        const options = {
          get passive() {
            passiveSupported = true;
            return false;
          }
        };
        if (_isDomSupported()) {
          window.addEventListener("test", null, options);
          window.removeEventListener("test", null, options);
        }
      } catch (e) {
      }
      return passiveSupported;
    }();
    function readUsedSize(element, property) {
      const value = getStyle(element, property);
      const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? +matches[1] : void 0;
    }
    function _pointInLine(p1, p2, t, mode) {
      return {
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y)
      };
    }
    function _steppedInterpolation(p1, p2, t, mode) {
      return {
        x: p1.x + t * (p2.x - p1.x),
        y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
      };
    }
    function _bezierInterpolation(p1, p2, t, mode) {
      const cp1 = {
        x: p1.cp2x,
        y: p1.cp2y
      };
      const cp2 = {
        x: p2.cp1x,
        y: p2.cp1y
      };
      const a = _pointInLine(p1, cp1, t);
      const b = _pointInLine(cp1, cp2, t);
      const c = _pointInLine(cp2, p2, t);
      const d = _pointInLine(a, b, t);
      const e = _pointInLine(b, c, t);
      return _pointInLine(d, e, t);
    }
    const getRightToLeftAdapter = function(rectX, width) {
      return {
        x(x) {
          return rectX + rectX + width - x;
        },
        setWidth(w) {
          width = w;
        },
        textAlign(align) {
          if (align === "center") {
            return align;
          }
          return align === "right" ? "left" : "right";
        },
        xPlus(x, value) {
          return x - value;
        },
        leftForLtr(x, itemWidth) {
          return x - itemWidth;
        }
      };
    };
    const getLeftToRightAdapter = function() {
      return {
        x(x) {
          return x;
        },
        setWidth(w) {
        },
        textAlign(align) {
          return align;
        },
        xPlus(x, value) {
          return x + value;
        },
        leftForLtr(x, _itemWidth) {
          return x;
        }
      };
    };
    function getRtlAdapter(rtl, rectX, width) {
      return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
    }
    function overrideTextDirection(ctx, direction) {
      let style, original;
      if (direction === "ltr" || direction === "rtl") {
        style = ctx.canvas.style;
        original = [
          style.getPropertyValue("direction"),
          style.getPropertyPriority("direction")
        ];
        style.setProperty("direction", direction, "important");
        ctx.prevTextDirection = original;
      }
    }
    function restoreTextDirection(ctx, original) {
      if (original !== void 0) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty("direction", original[0], original[1]);
      }
    }
    function propertyFn(property) {
      if (property === "angle") {
        return {
          between: _angleBetween,
          compare: _angleDiff,
          normalize: _normalizeAngle
        };
      }
      return {
        between: _isBetween,
        compare: (a, b) => a - b,
        normalize: (x) => x
      };
    }
    function normalizeSegment({ start: start2, end: end2, count, loop, style }) {
      return {
        start: start2 % count,
        end: end2 % count,
        loop: loop && (end2 - start2 + 1) % count === 0,
        style
      };
    }
    function getSegment(segment, points, bounds) {
      const { property, start: startBound, end: endBound } = bounds;
      const { between, normalize } = propertyFn(property);
      const count = points.length;
      let { start: start2, end: end2, loop } = segment;
      let i, ilen;
      if (loop) {
        start2 += count;
        end2 += count;
        for (i = 0, ilen = count; i < ilen; ++i) {
          if (!between(normalize(points[start2 % count][property]), startBound, endBound)) {
            break;
          }
          start2--;
          end2--;
        }
        start2 %= count;
        end2 %= count;
      }
      if (end2 < start2) {
        end2 += count;
      }
      return {
        start: start2,
        end: end2,
        loop,
        style: segment.style
      };
    }
    function _boundSegment(segment, points, bounds) {
      if (!bounds) {
        return [
          segment
        ];
      }
      const { property, start: startBound, end: endBound } = bounds;
      const count = points.length;
      const { compare, between, normalize } = propertyFn(property);
      const { start: start2, end: end2, loop, style } = getSegment(segment, points, bounds);
      const result = [];
      let inside = false;
      let subStart = null;
      let value, point, prevValue;
      const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
      const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
      const shouldStart = () => inside || startIsBefore();
      const shouldStop = () => !inside || endIsBefore();
      for (let i = start2, prev = start2; i <= end2; ++i) {
        point = points[i % count];
        if (point.skip) {
          continue;
        }
        value = normalize(point[property]);
        if (value === prevValue) {
          continue;
        }
        inside = between(value, startBound, endBound);
        if (subStart === null && shouldStart()) {
          subStart = compare(value, startBound) === 0 ? i : prev;
        }
        if (subStart !== null && shouldStop()) {
          result.push(normalizeSegment({
            start: subStart,
            end: i,
            loop,
            count,
            style
          }));
          subStart = null;
        }
        prev = i;
        prevValue = value;
      }
      if (subStart !== null) {
        result.push(normalizeSegment({
          start: subStart,
          end: end2,
          loop,
          count,
          style
        }));
      }
      return result;
    }
    function _boundSegments(line, bounds) {
      const result = [];
      const segments = line.segments;
      for (let i = 0; i < segments.length; i++) {
        const sub = _boundSegment(segments[i], line.points, bounds);
        if (sub.length) {
          result.push(...sub);
        }
      }
      return result;
    }
    function findStartAndEnd(points, count, loop, spanGaps) {
      let start2 = 0;
      let end2 = count - 1;
      if (loop && !spanGaps) {
        while (start2 < count && !points[start2].skip) {
          start2++;
        }
      }
      while (start2 < count && points[start2].skip) {
        start2++;
      }
      start2 %= count;
      if (loop) {
        end2 += start2;
      }
      while (end2 > start2 && points[end2 % count].skip) {
        end2--;
      }
      end2 %= count;
      return {
        start: start2,
        end: end2
      };
    }
    function solidSegments(points, start2, max2, loop) {
      const count = points.length;
      const result = [];
      let last = start2;
      let prev = points[start2];
      let end2;
      for (end2 = start2 + 1; end2 <= max2; ++end2) {
        const cur = points[end2 % count];
        if (cur.skip || cur.stop) {
          if (!prev.skip) {
            loop = false;
            result.push({
              start: start2 % count,
              end: (end2 - 1) % count,
              loop
            });
            start2 = last = cur.stop ? end2 : null;
          }
        } else {
          last = end2;
          if (prev.skip) {
            start2 = end2;
          }
        }
        prev = cur;
      }
      if (last !== null) {
        result.push({
          start: start2 % count,
          end: last % count,
          loop
        });
      }
      return result;
    }
    function _computeSegments(line, segmentOptions) {
      const points = line.points;
      const spanGaps = line.options.spanGaps;
      const count = points.length;
      if (!count) {
        return [];
      }
      const loop = !!line._loop;
      const { start: start2, end: end2 } = findStartAndEnd(points, count, loop, spanGaps);
      if (spanGaps === true) {
        return splitByStyles(line, [
          {
            start: start2,
            end: end2,
            loop
          }
        ], points, segmentOptions);
      }
      const max2 = end2 < start2 ? end2 + count : end2;
      const completeLoop = !!line._fullLoop && start2 === 0 && end2 === count - 1;
      return splitByStyles(line, solidSegments(points, start2, max2, completeLoop), points, segmentOptions);
    }
    function splitByStyles(line, segments, points, segmentOptions) {
      if (!segmentOptions || !segmentOptions.setContext || !points) {
        return segments;
      }
      return doSplitByStyles(line, segments, points, segmentOptions);
    }
    function doSplitByStyles(line, segments, points, segmentOptions) {
      const chartContext = line._chart.getContext();
      const baseStyle = readStyle(line.options);
      const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
      const count = points.length;
      const result = [];
      let prevStyle = baseStyle;
      let start2 = segments[0].start;
      let i = start2;
      function addStyle(s, e, l, st) {
        const dir = spanGaps ? -1 : 1;
        if (s === e) {
          return;
        }
        s += count;
        while (points[s % count].skip) {
          s -= dir;
        }
        while (points[e % count].skip) {
          e += dir;
        }
        if (s % count !== e % count) {
          result.push({
            start: s % count,
            end: e % count,
            loop: l,
            style: st
          });
          prevStyle = st;
          start2 = e % count;
        }
      }
      for (const segment of segments) {
        start2 = spanGaps ? start2 : segment.start;
        let prev = points[start2 % count];
        let style;
        for (i = start2 + 1; i <= segment.end; i++) {
          const pt = points[i % count];
          style = readStyle(segmentOptions.setContext(createContext(chartContext, {
            type: "segment",
            p0: prev,
            p1: pt,
            p0DataIndex: (i - 1) % count,
            p1DataIndex: i % count,
            datasetIndex
          })));
          if (styleChanged(style, prevStyle)) {
            addStyle(start2, i - 1, segment.loop, prevStyle);
          }
          prev = pt;
          prevStyle = style;
        }
        if (start2 < i - 1) {
          addStyle(start2, i - 1, segment.loop, prevStyle);
        }
      }
      return result;
    }
    function readStyle(options) {
      return {
        backgroundColor: options.backgroundColor,
        borderCapStyle: options.borderCapStyle,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderJoinStyle: options.borderJoinStyle,
        borderWidth: options.borderWidth,
        borderColor: options.borderColor
      };
    }
    function styleChanged(style, prevStyle) {
      if (!prevStyle) {
        return false;
      }
      const cache = [];
      const replacer = function(key, value) {
        if (!isPatternOrGradient(value)) {
          return value;
        }
        if (!cache.includes(value)) {
          cache.push(value);
        }
        return cache.indexOf(value);
      };
      return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
    }
    /*!
     * Chart.js v4.4.7
     * https://www.chartjs.org
     * (c) 2024 Chart.js Contributors
     * Released under the MIT License
     */
    class Animator {
      constructor() {
        this._request = null;
        this._charts = /* @__PURE__ */ new Map();
        this._running = false;
        this._lastDate = void 0;
      }
      _notify(chart, anims, date, type) {
        const callbacks = anims.listeners[type];
        const numSteps = anims.duration;
        callbacks.forEach((fn) => fn({
          chart,
          initial: anims.initial,
          numSteps,
          currentStep: Math.min(date - anims.start, numSteps)
        }));
      }
      _refresh() {
        if (this._request) {
          return;
        }
        this._running = true;
        this._request = requestAnimFrame.call(window, () => {
          this._update();
          this._request = null;
          if (this._running) {
            this._refresh();
          }
        });
      }
      _update(date = Date.now()) {
        let remaining = 0;
        this._charts.forEach((anims, chart) => {
          if (!anims.running || !anims.items.length) {
            return;
          }
          const items = anims.items;
          let i = items.length - 1;
          let draw2 = false;
          let item;
          for (; i >= 0; --i) {
            item = items[i];
            if (item._active) {
              if (item._total > anims.duration) {
                anims.duration = item._total;
              }
              item.tick(date);
              draw2 = true;
            } else {
              items[i] = items[items.length - 1];
              items.pop();
            }
          }
          if (draw2) {
            chart.draw();
            this._notify(chart, anims, date, "progress");
          }
          if (!items.length) {
            anims.running = false;
            this._notify(chart, anims, date, "complete");
            anims.initial = false;
          }
          remaining += items.length;
        });
        this._lastDate = date;
        if (remaining === 0) {
          this._running = false;
        }
      }
      _getAnims(chart) {
        const charts = this._charts;
        let anims = charts.get(chart);
        if (!anims) {
          anims = {
            running: false,
            initial: true,
            items: [],
            listeners: {
              complete: [],
              progress: []
            }
          };
          charts.set(chart, anims);
        }
        return anims;
      }
      listen(chart, event, cb) {
        this._getAnims(chart).listeners[event].push(cb);
      }
      add(chart, items) {
        if (!items || !items.length) {
          return;
        }
        this._getAnims(chart).items.push(...items);
      }
      has(chart) {
        return this._getAnims(chart).items.length > 0;
      }
      start(chart) {
        const anims = this._charts.get(chart);
        if (!anims) {
          return;
        }
        anims.running = true;
        anims.start = Date.now();
        anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
        this._refresh();
      }
      running(chart) {
        if (!this._running) {
          return false;
        }
        const anims = this._charts.get(chart);
        if (!anims || !anims.running || !anims.items.length) {
          return false;
        }
        return true;
      }
      stop(chart) {
        const anims = this._charts.get(chart);
        if (!anims || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i = items.length - 1;
        for (; i >= 0; --i) {
          items[i].cancel();
        }
        anims.items = [];
        this._notify(chart, anims, Date.now(), "complete");
      }
      remove(chart) {
        return this._charts.delete(chart);
      }
    }
    var animator = /* @__PURE__ */ new Animator();
    const transparent = "transparent";
    const interpolators = {
      boolean(from2, to2, factor) {
        return factor > 0.5 ? to2 : from2;
      },
      color(from2, to2, factor) {
        const c0 = color$1(from2 || transparent);
        const c1 = c0.valid && color$1(to2 || transparent);
        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
      },
      number(from2, to2, factor) {
        return from2 + (to2 - from2) * factor;
      }
    };
    class Animation {
      constructor(cfg, target, prop, to2) {
        const currentValue = target[prop];
        to2 = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        const from2 = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
        this._easing = effects[cfg.easing] || effects.linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from2;
        this._to = to2;
        this._promises = void 0;
      }
      active() {
        return this._active;
      }
      update(cfg, to2, date) {
        if (this._active) {
          this._notify(false);
          const currentValue = this._target[this._prop];
          const elapsed = date - this._start;
          const remain = this._duration - elapsed;
          this._start = date;
          this._duration = Math.floor(Math.max(remain, cfg.duration));
          this._total += elapsed;
          this._loop = !!cfg.loop;
          this._to = resolve([
            cfg.to,
            to2,
            currentValue,
            cfg.from
          ]);
          this._from = resolve([
            cfg.from,
            currentValue,
            to2
          ]);
        }
      }
      cancel() {
        if (this._active) {
          this.tick(Date.now());
          this._active = false;
          this._notify(false);
        }
      }
      tick(date) {
        const elapsed = date - this._start;
        const duration = this._duration;
        const prop = this._prop;
        const from2 = this._from;
        const loop = this._loop;
        const to2 = this._to;
        let factor;
        this._active = from2 !== to2 && (loop || elapsed < duration);
        if (!this._active) {
          this._target[prop] = to2;
          this._notify(true);
          return;
        }
        if (elapsed < 0) {
          this._target[prop] = from2;
          return;
        }
        factor = elapsed / duration % 2;
        factor = loop && factor > 1 ? 2 - factor : factor;
        factor = this._easing(Math.min(1, Math.max(0, factor)));
        this._target[prop] = this._fn(from2, to2, factor);
      }
      wait() {
        const promises = this._promises || (this._promises = []);
        return new Promise((res, rej) => {
          promises.push({
            res,
            rej
          });
        });
      }
      _notify(resolved) {
        const method = resolved ? "res" : "rej";
        const promises = this._promises || [];
        for (let i = 0; i < promises.length; i++) {
          promises[i][method]();
        }
      }
    }
    class Animations {
      constructor(chart, config) {
        this._chart = chart;
        this._properties = /* @__PURE__ */ new Map();
        this.configure(config);
      }
      configure(config) {
        if (!isObject$1(config)) {
          return;
        }
        const animationOptions = Object.keys(defaults$2.animation);
        const animatedProps = this._properties;
        Object.getOwnPropertyNames(config).forEach((key) => {
          const cfg = config[key];
          if (!isObject$1(cfg)) {
            return;
          }
          const resolved = {};
          for (const option of animationOptions) {
            resolved[option] = cfg[option];
          }
          (isArray$1(cfg.properties) && cfg.properties || [
            key
          ]).forEach((prop) => {
            if (prop === key || !animatedProps.has(prop)) {
              animatedProps.set(prop, resolved);
            }
          });
        });
      }
      _animateOptions(target, values) {
        const newOptions = values.options;
        const options = resolveTargetOptions(target, newOptions);
        if (!options) {
          return [];
        }
        const animations = this._createAnimations(options, newOptions);
        if (newOptions.$shared) {
          awaitAll(target.options.$animations, newOptions).then(() => {
            target.options = newOptions;
          }, () => {
          });
        }
        return animations;
      }
      _createAnimations(target, values) {
        const animatedProps = this._properties;
        const animations = [];
        const running = target.$animations || (target.$animations = {});
        const props = Object.keys(values);
        const date = Date.now();
        let i;
        for (i = props.length - 1; i >= 0; --i) {
          const prop = props[i];
          if (prop.charAt(0) === "$") {
            continue;
          }
          if (prop === "options") {
            animations.push(...this._animateOptions(target, values));
            continue;
          }
          const value = values[prop];
          let animation = running[prop];
          const cfg = animatedProps.get(prop);
          if (animation) {
            if (cfg && animation.active()) {
              animation.update(cfg, value, date);
              continue;
            } else {
              animation.cancel();
            }
          }
          if (!cfg || !cfg.duration) {
            target[prop] = value;
            continue;
          }
          running[prop] = animation = new Animation(cfg, target, prop, value);
          animations.push(animation);
        }
        return animations;
      }
      update(target, values) {
        if (this._properties.size === 0) {
          Object.assign(target, values);
          return;
        }
        const animations = this._createAnimations(target, values);
        if (animations.length) {
          animator.add(this._chart, animations);
          return true;
        }
      }
    }
    function awaitAll(animations, properties) {
      const running = [];
      const keys2 = Object.keys(properties);
      for (let i = 0; i < keys2.length; i++) {
        const anim = animations[keys2[i]];
        if (anim && anim.active()) {
          running.push(anim.wait());
        }
      }
      return Promise.all(running);
    }
    function resolveTargetOptions(target, newOptions) {
      if (!newOptions) {
        return;
      }
      let options = target.options;
      if (!options) {
        target.options = newOptions;
        return;
      }
      if (options.$shared) {
        target.options = options = Object.assign({}, options, {
          $shared: false,
          $animations: {}
        });
      }
      return options;
    }
    function scaleClip(scale, allowedOverflow) {
      const opts = scale && scale.options || {};
      const reverse = opts.reverse;
      const min2 = opts.min === void 0 ? allowedOverflow : 0;
      const max2 = opts.max === void 0 ? allowedOverflow : 0;
      return {
        start: reverse ? max2 : min2,
        end: reverse ? min2 : max2
      };
    }
    function defaultClip(xScale, yScale, allowedOverflow) {
      if (allowedOverflow === false) {
        return false;
      }
      const x = scaleClip(xScale, allowedOverflow);
      const y = scaleClip(yScale, allowedOverflow);
      return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
      };
    }
    function toClip(value) {
      let t, r, b, l;
      if (isObject$1(value)) {
        t = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
      } else {
        t = r = b = l = value;
      }
      return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        disabled: value === false
      };
    }
    function getSortedDatasetIndices(chart, filterVisible) {
      const keys2 = [];
      const metasets = chart._getSortedDatasetMetas(filterVisible);
      let i, ilen;
      for (i = 0, ilen = metasets.length; i < ilen; ++i) {
        keys2.push(metasets[i].index);
      }
      return keys2;
    }
    function applyStack(stack, value, dsIndex, options = {}) {
      const keys2 = stack.keys;
      const singleMode = options.mode === "single";
      let i, ilen, datasetIndex, otherValue;
      if (value === null) {
        return;
      }
      let found = false;
      for (i = 0, ilen = keys2.length; i < ilen; ++i) {
        datasetIndex = +keys2[i];
        if (datasetIndex === dsIndex) {
          found = true;
          if (options.all) {
            continue;
          }
          break;
        }
        otherValue = stack.values[datasetIndex];
        if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign$1(value) === sign$1(otherValue))) {
          value += otherValue;
        }
      }
      if (!found && !options.all) {
        return 0;
      }
      return value;
    }
    function convertObjectDataToArray(data, meta) {
      const { iScale, vScale } = meta;
      const iAxisKey = iScale.axis === "x" ? "x" : "y";
      const vAxisKey = vScale.axis === "x" ? "x" : "y";
      const keys2 = Object.keys(data);
      const adata = new Array(keys2.length);
      let i, ilen, key;
      for (i = 0, ilen = keys2.length; i < ilen; ++i) {
        key = keys2[i];
        adata[i] = {
          [iAxisKey]: key,
          [vAxisKey]: data[key]
        };
      }
      return adata;
    }
    function isStacked(scale, meta) {
      const stacked = scale && scale.options.stacked;
      return stacked || stacked === void 0 && meta.stack !== void 0;
    }
    function getStackKey(indexScale, valueScale, meta) {
      return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
    }
    function getUserBounds(scale) {
      const { min: min2, max: max2, minDefined, maxDefined } = scale.getUserBounds();
      return {
        min: minDefined ? min2 : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max2 : Number.POSITIVE_INFINITY
      };
    }
    function getOrCreateStack(stacks, stackKey, indexValue) {
      const subStack = stacks[stackKey] || (stacks[stackKey] = {});
      return subStack[indexValue] || (subStack[indexValue] = {});
    }
    function getLastIndexInStack(stack, vScale, positive, type) {
      for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
        const value = stack[meta.index];
        if (positive && value > 0 || !positive && value < 0) {
          return meta.index;
        }
      }
      return null;
    }
    function updateStacks(controller, parsed) {
      const { chart, _cachedMeta: meta } = controller;
      const stacks = chart._stacks || (chart._stacks = {});
      const { iScale, vScale, index: datasetIndex } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const key = getStackKey(iScale, vScale, meta);
      const ilen = parsed.length;
      let stack;
      for (let i = 0; i < ilen; ++i) {
        const item = parsed[i];
        const { [iAxis]: index2, [vAxis]: value } = item;
        const itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
        const visualValues = stack._visualValues || (stack._visualValues = {});
        visualValues[datasetIndex] = value;
      }
    }
    function getFirstScaleId(chart, axis) {
      const scales = chart.scales;
      return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
    }
    function createDatasetContext(parent, index2) {
      return createContext(parent, {
        active: false,
        dataset: void 0,
        datasetIndex: index2,
        index: index2,
        mode: "default",
        type: "dataset"
      });
    }
    function createDataContext(parent, index2, element) {
      return createContext(parent, {
        active: false,
        dataIndex: index2,
        parsed: void 0,
        raw: void 0,
        element,
        index: index2,
        mode: "default",
        type: "data"
      });
    }
    function clearStacks(meta, items) {
      const datasetIndex = meta.controller.index;
      const axis = meta.vScale && meta.vScale.axis;
      if (!axis) {
        return;
      }
      items = items || meta._parsed;
      for (const parsed of items) {
        const stacks = parsed._stacks;
        if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
          return;
        }
        delete stacks[axis][datasetIndex];
        if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
          delete stacks[axis]._visualValues[datasetIndex];
        }
      }
    }
    const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
    const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
    const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
      keys: getSortedDatasetIndices(chart, true),
      values: null
    };
    class DatasetController {
      constructor(chart, datasetIndex) {
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = void 0;
        this._parsing = false;
        this._data = void 0;
        this._objectData = void 0;
        this._sharedOptions = void 0;
        this._drawStart = void 0;
        this._drawCount = void 0;
        this.enableOptionSharing = false;
        this.supportsDecimation = false;
        this.$context = void 0;
        this._syncList = [];
        this.datasetElementType = new.target.datasetElementType;
        this.dataElementType = new.target.dataElementType;
        this.initialize();
      }
      initialize() {
        const meta = this._cachedMeta;
        this.configure();
        this.linkScales();
        meta._stacked = isStacked(meta.vScale, meta);
        this.addElements();
        if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
          console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
        }
      }
      updateIndex(datasetIndex) {
        if (this.index !== datasetIndex) {
          clearStacks(this._cachedMeta);
        }
        this.index = datasetIndex;
      }
      linkScales() {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
        const indexAxis = meta.indexAxis;
        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
        meta.xScale = this.getScaleForId(xid);
        meta.yScale = this.getScaleForId(yid);
        meta.rScale = this.getScaleForId(rid);
        meta.iScale = this.getScaleForId(iid);
        meta.vScale = this.getScaleForId(vid);
      }
      getDataset() {
        return this.chart.data.datasets[this.index];
      }
      getMeta() {
        return this.chart.getDatasetMeta(this.index);
      }
      getScaleForId(scaleID) {
        return this.chart.scales[scaleID];
      }
      _getOtherScale(scale) {
        const meta = this._cachedMeta;
        return scale === meta.iScale ? meta.vScale : meta.iScale;
      }
      reset() {
        this._update("reset");
      }
      _destroy() {
        const meta = this._cachedMeta;
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
        if (meta._stacked) {
          clearStacks(meta);
        }
      }
      _dataCheck() {
        const dataset = this.getDataset();
        const data = dataset.data || (dataset.data = []);
        const _data = this._data;
        if (isObject$1(data)) {
          const meta = this._cachedMeta;
          this._data = convertObjectDataToArray(data, meta);
        } else if (_data !== data) {
          if (_data) {
            unlistenArrayEvents(_data, this);
            const meta = this._cachedMeta;
            clearStacks(meta);
            meta._parsed = [];
          }
          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, this);
          }
          this._syncList = [];
          this._data = data;
        }
      }
      addElements() {
        const meta = this._cachedMeta;
        this._dataCheck();
        if (this.datasetElementType) {
          meta.dataset = new this.datasetElementType();
        }
      }
      buildOrUpdateElements(resetNewElements) {
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        let stackChanged = false;
        this._dataCheck();
        const oldStacked = meta._stacked;
        meta._stacked = isStacked(meta.vScale, meta);
        if (meta.stack !== dataset.stack) {
          stackChanged = true;
          clearStacks(meta);
          meta.stack = dataset.stack;
        }
        this._resyncElements(resetNewElements);
        if (stackChanged || oldStacked !== meta._stacked) {
          updateStacks(this, meta._parsed);
          meta._stacked = isStacked(meta.vScale, meta);
        }
      }
      configure() {
        const config = this.chart.config;
        const scopeKeys = config.datasetScopeKeys(this._type);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
        this.options = config.createResolver(scopes, this.getContext());
        this._parsing = this.options.parsing;
        this._cachedDataOpts = {};
      }
      parse(start2, count) {
        const { _cachedMeta: meta, _data: data } = this;
        const { iScale, _stacked } = meta;
        const iAxis = iScale.axis;
        let sorted = start2 === 0 && count === data.length ? true : meta._sorted;
        let prev = start2 > 0 && meta._parsed[start2 - 1];
        let i, cur, parsed;
        if (this._parsing === false) {
          meta._parsed = data;
          meta._sorted = true;
          parsed = data;
        } else {
          if (isArray$1(data[start2])) {
            parsed = this.parseArrayData(meta, data, start2, count);
          } else if (isObject$1(data[start2])) {
            parsed = this.parseObjectData(meta, data, start2, count);
          } else {
            parsed = this.parsePrimitiveData(meta, data, start2, count);
          }
          const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
          for (i = 0; i < count; ++i) {
            meta._parsed[i + start2] = cur = parsed[i];
            if (sorted) {
              if (isNotInOrderComparedToPrev()) {
                sorted = false;
              }
              prev = cur;
            }
          }
          meta._sorted = sorted;
        }
        if (_stacked) {
          updateStacks(this, parsed);
        }
      }
      parsePrimitiveData(meta, data, start2, count) {
        const { iScale, vScale } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = new Array(count);
        let i, ilen, index2;
        for (i = 0, ilen = count; i < ilen; ++i) {
          index2 = i + start2;
          parsed[i] = {
            [iAxis]: singleScale || iScale.parse(labels[index2], index2),
            [vAxis]: vScale.parse(data[index2], index2)
          };
        }
        return parsed;
      }
      parseArrayData(meta, data, start2, count) {
        const { xScale, yScale } = meta;
        const parsed = new Array(count);
        let i, ilen, index2, item;
        for (i = 0, ilen = count; i < ilen; ++i) {
          index2 = i + start2;
          item = data[index2];
          parsed[i] = {
            x: xScale.parse(item[0], index2),
            y: yScale.parse(item[1], index2)
          };
        }
        return parsed;
      }
      parseObjectData(meta, data, start2, count) {
        const { xScale, yScale } = meta;
        const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index2, item;
        for (i = 0, ilen = count; i < ilen; ++i) {
          index2 = i + start2;
          item = data[index2];
          parsed[i] = {
            x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
            y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
          };
        }
        return parsed;
      }
      getParsed(index2) {
        return this._cachedMeta._parsed[index2];
      }
      getDataElement(index2) {
        return this._cachedMeta.data[index2];
      }
      applyStack(scale, parsed, mode) {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const value = parsed[scale.axis];
        const stack = {
          keys: getSortedDatasetIndices(chart, true),
          values: parsed._stacks[scale.axis]._visualValues
        };
        return applyStack(stack, value, meta.index, {
          mode
        });
      }
      updateRangeFromParsed(range2, scale, parsed, stack) {
        const parsedValue = parsed[scale.axis];
        let value = parsedValue === null ? NaN : parsedValue;
        const values = stack && parsed._stacks[scale.axis];
        if (stack && values) {
          stack.values = values;
          value = applyStack(stack, parsedValue, this._cachedMeta.index);
        }
        range2.min = Math.min(range2.min, value);
        range2.max = Math.max(range2.max, value);
      }
      getMinMax(scale, canStack) {
        const meta = this._cachedMeta;
        const _parsed = meta._parsed;
        const sorted = meta._sorted && scale === meta.iScale;
        const ilen = _parsed.length;
        const otherScale = this._getOtherScale(scale);
        const stack = createStack(canStack, meta, this.chart);
        const range2 = {
          min: Number.POSITIVE_INFINITY,
          max: Number.NEGATIVE_INFINITY
        };
        const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
        let i, parsed;
        function _skip() {
          parsed = _parsed[i];
          const otherValue = parsed[otherScale.axis];
          return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
        }
        for (i = 0; i < ilen; ++i) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range2, scale, parsed, stack);
          if (sorted) {
            break;
          }
        }
        if (sorted) {
          for (i = ilen - 1; i >= 0; --i) {
            if (_skip()) {
              continue;
            }
            this.updateRangeFromParsed(range2, scale, parsed, stack);
            break;
          }
        }
        return range2;
      }
      getAllParsedValues(scale) {
        const parsed = this._cachedMeta._parsed;
        const values = [];
        let i, ilen, value;
        for (i = 0, ilen = parsed.length; i < ilen; ++i) {
          value = parsed[i][scale.axis];
          if (isNumberFinite(value)) {
            values.push(value);
          }
        }
        return values;
      }
      getMaxOverflow() {
        return false;
      }
      getLabelAndValue(index2) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const parsed = this.getParsed(index2);
        return {
          label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
          value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
        };
      }
      _update(mode) {
        const meta = this._cachedMeta;
        this.update(mode || "default");
        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
      }
      update(mode) {
      }
      draw() {
        const ctx = this._ctx;
        const chart = this.chart;
        const meta = this._cachedMeta;
        const elements = meta.data || [];
        const area = chart.chartArea;
        const active = [];
        const start2 = this._drawStart || 0;
        const count = this._drawCount || elements.length - start2;
        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
        let i;
        if (meta.dataset) {
          meta.dataset.draw(ctx, area, start2, count);
        }
        for (i = start2; i < start2 + count; ++i) {
          const element = elements[i];
          if (element.hidden) {
            continue;
          }
          if (element.active && drawActiveElementsOnTop) {
            active.push(element);
          } else {
            element.draw(ctx, area);
          }
        }
        for (i = 0; i < active.length; ++i) {
          active[i].draw(ctx, area);
        }
      }
      getStyle(index2, active) {
        const mode = active ? "active" : "default";
        return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
      }
      getContext(index2, active, mode) {
        const dataset = this.getDataset();
        let context;
        if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
          const element = this._cachedMeta.data[index2];
          context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
          context.parsed = this.getParsed(index2);
          context.raw = dataset.data[index2];
          context.index = context.dataIndex = index2;
        } else {
          context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
          context.dataset = dataset;
          context.index = context.datasetIndex = this.index;
        }
        context.active = !!active;
        context.mode = mode;
        return context;
      }
      resolveDatasetElementOptions(mode) {
        return this._resolveElementOptions(this.datasetElementType.id, mode);
      }
      resolveDataElementOptions(index2, mode) {
        return this._resolveElementOptions(this.dataElementType.id, mode, index2);
      }
      _resolveElementOptions(elementType, mode = "default", index2) {
        const active = mode === "active";
        const cache = this._cachedDataOpts;
        const cacheKey = elementType + "-" + mode;
        const cached = cache[cacheKey];
        const sharing = this.enableOptionSharing && defined(index2);
        if (cached) {
          return cloneIfNotShared(cached, sharing);
        }
        const config = this.chart.config;
        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
        const prefixes = active ? [
          `${elementType}Hover`,
          "hover",
          elementType,
          ""
        ] : [
          elementType,
          ""
        ];
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        const names2 = Object.keys(defaults$2.elements[elementType]);
        const context = () => this.getContext(index2, active, mode);
        const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
        if (values.$shared) {
          values.$shared = sharing;
          cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
        }
        return values;
      }
      _resolveAnimations(index2, transition, active) {
        const chart = this.chart;
        const cache = this._cachedDataOpts;
        const cacheKey = `animation-${transition}`;
        const cached = cache[cacheKey];
        if (cached) {
          return cached;
        }
        let options;
        if (chart.options.animation !== false) {
          const config = this.chart.config;
          const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
          options = config.createResolver(scopes, this.getContext(index2, active, transition));
        }
        const animations = new Animations(chart, options && options.animations);
        if (options && options._cacheable) {
          cache[cacheKey] = Object.freeze(animations);
        }
        return animations;
      }
      getSharedOptions(options) {
        if (!options.$shared) {
          return;
        }
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
      }
      includeOptions(mode, sharedOptions) {
        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
      }
      _getSharedOptions(start2, mode) {
        const firstOpts = this.resolveDataElementOptions(start2, mode);
        const previouslySharedOptions = this._sharedOptions;
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
        return {
          sharedOptions,
          includeOptions
        };
      }
      updateElement(element, index2, properties, mode) {
        if (isDirectUpdateMode(mode)) {
          Object.assign(element, properties);
        } else {
          this._resolveAnimations(index2, mode).update(element, properties);
        }
      }
      updateSharedOptions(sharedOptions, mode, newOptions) {
        if (sharedOptions && !isDirectUpdateMode(mode)) {
          this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
        }
      }
      _setStyle(element, index2, mode, active) {
        element.active = active;
        const options = this.getStyle(index2, active);
        this._resolveAnimations(index2, mode, active).update(element, {
          options: !active && this.getSharedOptions(options) || options
        });
      }
      removeHoverStyle(element, datasetIndex, index2) {
        this._setStyle(element, index2, "active", false);
      }
      setHoverStyle(element, datasetIndex, index2) {
        this._setStyle(element, index2, "active", true);
      }
      _removeDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
          this._setStyle(element, void 0, "active", false);
        }
      }
      _setDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
          this._setStyle(element, void 0, "active", true);
        }
      }
      _resyncElements(resetNewElements) {
        const data = this._data;
        const elements = this._cachedMeta.data;
        for (const [method, arg1, arg2] of this._syncList) {
          this[method](arg1, arg2);
        }
        this._syncList = [];
        const numMeta = elements.length;
        const numData = data.length;
        const count = Math.min(numData, numMeta);
        if (count) {
          this.parse(0, count);
        }
        if (numData > numMeta) {
          this._insertElements(numMeta, numData - numMeta, resetNewElements);
        } else if (numData < numMeta) {
          this._removeElements(numData, numMeta - numData);
        }
      }
      _insertElements(start2, count, resetNewElements = true) {
        const meta = this._cachedMeta;
        const data = meta.data;
        const end2 = start2 + count;
        let i;
        const move = (arr) => {
          arr.length += count;
          for (i = arr.length - 1; i >= end2; i--) {
            arr[i] = arr[i - count];
          }
        };
        move(data);
        for (i = start2; i < end2; ++i) {
          data[i] = new this.dataElementType();
        }
        if (this._parsing) {
          move(meta._parsed);
        }
        this.parse(start2, count);
        if (resetNewElements) {
          this.updateElements(data, start2, count, "reset");
        }
      }
      updateElements(element, start2, count, mode) {
      }
      _removeElements(start2, count) {
        const meta = this._cachedMeta;
        if (this._parsing) {
          const removed = meta._parsed.splice(start2, count);
          if (meta._stacked) {
            clearStacks(meta, removed);
          }
        }
        meta.data.splice(start2, count);
      }
      _sync(args) {
        if (this._parsing) {
          this._syncList.push(args);
        } else {
          const [method, arg1, arg2] = args;
          this[method](arg1, arg2);
        }
        this.chart._dataChanges.push([
          this.index,
          ...args
        ]);
      }
      _onDataPush() {
        const count = arguments.length;
        this._sync([
          "_insertElements",
          this.getDataset().data.length - count,
          count
        ]);
      }
      _onDataPop() {
        this._sync([
          "_removeElements",
          this._cachedMeta.data.length - 1,
          1
        ]);
      }
      _onDataShift() {
        this._sync([
          "_removeElements",
          0,
          1
        ]);
      }
      _onDataSplice(start2, count) {
        if (count) {
          this._sync([
            "_removeElements",
            start2,
            count
          ]);
        }
        const newCount = arguments.length - 2;
        if (newCount) {
          this._sync([
            "_insertElements",
            start2,
            newCount
          ]);
        }
      }
      _onDataUnshift() {
        this._sync([
          "_insertElements",
          0,
          arguments.length
        ]);
      }
    }
    __publicField(DatasetController, "defaults", {});
    __publicField(DatasetController, "datasetElementType", null);
    __publicField(DatasetController, "dataElementType", null);
    class LineController extends DatasetController {
      initialize() {
        this.enableOptionSharing = true;
        this.supportsDecimation = true;
        super.initialize();
      }
      update(mode) {
        const meta = this._cachedMeta;
        const { dataset: line, data: points = [], _dataset } = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start: start2, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
        this._drawStart = start2;
        this._drawCount = count;
        if (_scaleRangesChanged(meta)) {
          start2 = 0;
          count = points.length;
        }
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
        this.updateElements(points, start2, count, mode);
      }
      updateElements(points, start2, count, mode) {
        const reset = mode === "reset";
        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
        const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps, segment } = this.options;
        const maxGapLength = isNumber$1(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
        const end2 = start2 + count;
        const pointsCount = points.length;
        let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
        for (let i = 0; i < pointsCount; ++i) {
          const point = points[i];
          const properties = directUpdate ? point : {};
          if (i < start2 || i >= end2) {
            properties.skip = true;
            continue;
          }
          const parsed = this.getParsed(i);
          const nullData = isNullOrUndef(parsed[vAxis]);
          const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
          const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
          properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
          properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
          if (segment) {
            properties.parsed = parsed;
            properties.raw = _dataset.data[i];
          }
          if (includeOptions) {
            properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
          }
          if (!directUpdate) {
            this.updateElement(point, i, properties, mode);
          }
          prevParsed = parsed;
        }
      }
      getMaxOverflow() {
        const meta = this._cachedMeta;
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        const data = meta.data || [];
        if (!data.length) {
          return border;
        }
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
      }
      draw() {
        const meta = this._cachedMeta;
        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
        super.draw();
      }
    }
    __publicField(LineController, "id", "line");
    __publicField(LineController, "defaults", {
      datasetElementType: "line",
      dataElementType: "point",
      showLine: true,
      spanGaps: false
    });
    __publicField(LineController, "overrides", {
      scales: {
        _index_: {
          type: "category"
        },
        _value_: {
          type: "linear"
        }
      }
    });
    function abstract() {
      throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
    }
    class DateAdapterBase {
      constructor(options) {
        __publicField(this, "options");
        this.options = options || {};
      }
      /**
      * Override default date adapter methods.
      * Accepts type parameter to define options type.
      * @example
      * Chart._adapters._date.override<{myAdapterOption: string}>({
      *   init() {
      *     console.log(this.options.myAdapterOption);
      *   }
      * })
      */
      static override(members) {
        Object.assign(DateAdapterBase.prototype, members);
      }
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      init() {
      }
      formats() {
        return abstract();
      }
      parse() {
        return abstract();
      }
      format() {
        return abstract();
      }
      add() {
        return abstract();
      }
      diff() {
        return abstract();
      }
      startOf() {
        return abstract();
      }
      endOf() {
        return abstract();
      }
    }
    var adapters = {
      _date: DateAdapterBase
    };
    function binarySearch(metaset, axis, value, intersect) {
      const { controller, data, _sorted } = metaset;
      const iScale = controller._cachedMeta.iScale;
      if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
        if (!intersect) {
          return lookupMethod(data, axis, value);
        } else if (controller._sharedOptions) {
          const el = data[0];
          const range2 = typeof el.getRange === "function" && el.getRange(axis);
          if (range2) {
            const start2 = lookupMethod(data, axis, value - range2);
            const end2 = lookupMethod(data, axis, value + range2);
            return {
              lo: start2.lo,
              hi: end2.hi
            };
          }
        }
      }
      return {
        lo: 0,
        hi: data.length - 1
      };
    }
    function evaluateInteractionItems(chart, axis, position, handler, intersect) {
      const metasets = chart.getSortedVisibleDatasetMetas();
      const value = position[axis];
      for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
        const { index: index2, data } = metasets[i];
        const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
        for (let j = lo; j <= hi; ++j) {
          const element = data[j];
          if (!element.skip) {
            handler(element, index2, j);
          }
        }
      }
    }
    function getDistanceMetricForAxis(axis) {
      const useX = axis.indexOf("x") !== -1;
      const useY = axis.indexOf("y") !== -1;
      return function(pt1, pt2) {
        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }
    function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
      const items = [];
      if (!includeInvisible && !chart.isPointInArea(position)) {
        return items;
      }
      const evaluationFunc = function(element, datasetIndex, index2) {
        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
          return;
        }
        if (element.inRange(position.x, position.y, useFinalPosition)) {
          items.push({
            element,
            datasetIndex,
            index: index2
          });
        }
      };
      evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
      return items;
    }
    function getNearestRadialItems(chart, position, axis, useFinalPosition) {
      let items = [];
      function evaluationFunc(element, datasetIndex, index2) {
        const { startAngle, endAngle } = element.getProps([
          "startAngle",
          "endAngle"
        ], useFinalPosition);
        const { angle } = getAngleFromPoint(element, {
          x: position.x,
          y: position.y
        });
        if (_angleBetween(angle, startAngle, endAngle)) {
          items.push({
            element,
            datasetIndex,
            index: index2
          });
        }
      }
      evaluateInteractionItems(chart, axis, position, evaluationFunc);
      return items;
    }
    function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
      let items = [];
      const distanceMetric = getDistanceMetricForAxis(axis);
      let minDistance = Number.POSITIVE_INFINITY;
      function evaluationFunc(element, datasetIndex, index2) {
        const inRange = element.inRange(position.x, position.y, useFinalPosition);
        if (intersect && !inRange) {
          return;
        }
        const center = element.getCenterPoint(useFinalPosition);
        const pointInArea = !!includeInvisible || chart.isPointInArea(center);
        if (!pointInArea && !inRange) {
          return;
        }
        const distance = distanceMetric(position, center);
        if (distance < minDistance) {
          items = [
            {
              element,
              datasetIndex,
              index: index2
            }
          ];
          minDistance = distance;
        } else if (distance === minDistance) {
          items.push({
            element,
            datasetIndex,
            index: index2
          });
        }
      }
      evaluateInteractionItems(chart, axis, position, evaluationFunc);
      return items;
    }
    function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
      if (!includeInvisible && !chart.isPointInArea(position)) {
        return [];
      }
      return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
    }
    function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
      const items = [];
      const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
      let intersectsItem = false;
      evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
          items.push({
            element,
            datasetIndex,
            index: index2
          });
          intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
        }
      });
      if (intersect && !intersectsItem) {
        return [];
      }
      return items;
    }
    var Interaction = {
      evaluateInteractionItems,
      modes: {
        index(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "x";
          const includeInvisible = options.includeInvisible || false;
          const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
          const elements = [];
          if (!items.length) {
            return [];
          }
          chart.getSortedVisibleDatasetMetas().forEach((meta) => {
            const index2 = items[0].index;
            const element = meta.data[index2];
            if (element && !element.skip) {
              elements.push({
                element,
                datasetIndex: meta.index,
                index: index2
              });
            }
          });
          return elements;
        },
        dataset(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "xy";
          const includeInvisible = options.includeInvisible || false;
          let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
          if (items.length > 0) {
            const datasetIndex = items[0].datasetIndex;
            const data = chart.getDatasetMeta(datasetIndex).data;
            items = [];
            for (let i = 0; i < data.length; ++i) {
              items.push({
                element: data[i],
                datasetIndex,
                index: i
              });
            }
          }
          return items;
        },
        point(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "xy";
          const includeInvisible = options.includeInvisible || false;
          return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
        },
        nearest(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || "xy";
          const includeInvisible = options.includeInvisible || false;
          return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
        },
        x(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
        },
        y(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
        }
      }
    };
    const STATIC_POSITIONS = [
      "left",
      "top",
      "right",
      "bottom"
    ];
    function filterByPosition(array, position) {
      return array.filter((v) => v.pos === position);
    }
    function filterDynamicPositionByAxis(array, axis) {
      return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
    }
    function sortByWeight(array, reverse) {
      return array.sort((a, b) => {
        const v0 = reverse ? b : a;
        const v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
      });
    }
    function wrapBoxes(boxes) {
      const layoutBoxes = [];
      let i, ilen, box, pos, stack, stackWeight;
      for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
        box = boxes[i];
        ({ position: pos, options: { stack, stackWeight = 1 } } = box);
        layoutBoxes.push({
          index: i,
          box,
          pos,
          horizontal: box.isHorizontal(),
          weight: box.weight,
          stack: stack && pos + stack,
          stackWeight
        });
      }
      return layoutBoxes;
    }
    function buildStacks(layouts2) {
      const stacks = {};
      for (const wrap of layouts2) {
        const { stack, pos, stackWeight } = wrap;
        if (!stack || !STATIC_POSITIONS.includes(pos)) {
          continue;
        }
        const _stack = stacks[stack] || (stacks[stack] = {
          count: 0,
          placed: 0,
          weight: 0,
          size: 0
        });
        _stack.count++;
        _stack.weight += stackWeight;
      }
      return stacks;
    }
    function setLayoutDims(layouts2, params) {
      const stacks = buildStacks(layouts2);
      const { vBoxMaxWidth, hBoxMaxHeight } = params;
      let i, ilen, layout;
      for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
        layout = layouts2[i];
        const { fullSize } = layout.box;
        const stack = stacks[layout.stack];
        const factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
          layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
          layout.height = hBoxMaxHeight;
        } else {
          layout.width = vBoxMaxWidth;
          layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
      }
      return stacks;
    }
    function buildLayoutBoxes(boxes) {
      const layoutBoxes = wrapBoxes(boxes);
      const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
      const left2 = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
      const right2 = sortByWeight(filterByPosition(layoutBoxes, "right"));
      const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
      const bottom2 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
      const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
      const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
      return {
        fullSize,
        leftAndTop: left2.concat(top2),
        rightAndBottom: right2.concat(centerVertical).concat(bottom2).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, "chartArea"),
        vertical: left2.concat(right2).concat(centerVertical),
        horizontal: top2.concat(bottom2).concat(centerHorizontal)
      };
    }
    function getCombinedMax(maxPadding, chartArea, a, b) {
      return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
    }
    function updateMaxPadding(maxPadding, boxPadding) {
      maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
      maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
      maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
      maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
    }
    function updateDims(chartArea, params, layout, stacks) {
      const { pos, box } = layout;
      const maxPadding = chartArea.maxPadding;
      if (!isObject$1(pos)) {
        if (layout.size) {
          chartArea[pos] -= layout.size;
        }
        const stack = stacks[layout.stack] || {
          size: 0,
          count: 1
        };
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea[pos] += layout.size;
      }
      if (box.getPadding) {
        updateMaxPadding(maxPadding, box.getPadding());
      }
      const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
      const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
      const widthChanged = newWidth !== chartArea.w;
      const heightChanged = newHeight !== chartArea.h;
      chartArea.w = newWidth;
      chartArea.h = newHeight;
      return layout.horizontal ? {
        same: widthChanged,
        other: heightChanged
      } : {
        same: heightChanged,
        other: widthChanged
      };
    }
    function handleMaxPadding(chartArea) {
      const maxPadding = chartArea.maxPadding;
      function updatePos(pos) {
        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
      }
      chartArea.y += updatePos("top");
      chartArea.x += updatePos("left");
      updatePos("right");
      updatePos("bottom");
    }
    function getMargins(horizontal, chartArea) {
      const maxPadding = chartArea.maxPadding;
      function marginForPositions(positions2) {
        const margin = {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
        positions2.forEach((pos) => {
          margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
      }
      return horizontal ? marginForPositions([
        "left",
        "right"
      ]) : marginForPositions([
        "top",
        "bottom"
      ]);
    }
    function fitBoxes(boxes, chartArea, params, stacks) {
      const refitBoxes = [];
      let i, ilen, layout, box, refit, changed;
      for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
        layout = boxes[i];
        box = layout.box;
        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
        const { same, other } = updateDims(chartArea, params, layout, stacks);
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) {
          refitBoxes.push(layout);
        }
      }
      return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
    }
    function setBoxDims(box, left2, top2, width, height) {
      box.top = top2;
      box.left = left2;
      box.right = left2 + width;
      box.bottom = top2 + height;
      box.width = width;
      box.height = height;
    }
    function placeBoxes(boxes, chartArea, params, stacks) {
      const userPadding = params.padding;
      let { x, y } = chartArea;
      for (const layout of boxes) {
        const box = layout.box;
        const stack = stacks[layout.stack] || {
          count: 1,
          placed: 0,
          weight: 1
        };
        const weight = layout.stackWeight / stack.weight || 1;
        if (layout.horizontal) {
          const width = chartArea.w * weight;
          const height = stack.size || box.height;
          if (defined(stack.start)) {
            y = stack.start;
          }
          if (box.fullSize) {
            setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
          } else {
            setBoxDims(box, chartArea.left + stack.placed, y, width, height);
          }
          stack.start = y;
          stack.placed += width;
          y = box.bottom;
        } else {
          const height = chartArea.h * weight;
          const width = stack.size || box.width;
          if (defined(stack.start)) {
            x = stack.start;
          }
          if (box.fullSize) {
            setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
          } else {
            setBoxDims(box, x, chartArea.top + stack.placed, width, height);
          }
          stack.start = x;
          stack.placed += height;
          x = box.right;
        }
      }
      chartArea.x = x;
      chartArea.y = y;
    }
    var layouts = {
      addBox(chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        }
        item.fullSize = item.fullSize || false;
        item.position = item.position || "top";
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
          return [
            {
              z: 0,
              draw(chartArea) {
                item.draw(chartArea);
              }
            }
          ];
        };
        chart.boxes.push(item);
      },
      removeBox(chart, layoutItem) {
        const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index2 !== -1) {
          chart.boxes.splice(index2, 1);
        }
      },
      configure(chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
      },
      update(chart, width, height, minPadding) {
        if (!chart) {
          return;
        }
        const padding = toPadding(chart.options.layout.padding);
        const availableWidth = Math.max(width - padding.width, 0);
        const availableHeight = Math.max(height - padding.height, 0);
        const boxes = buildLayoutBoxes(chart.boxes);
        const verticalBoxes = boxes.vertical;
        const horizontalBoxes = boxes.horizontal;
        each(chart.boxes, (box) => {
          if (typeof box.beforeLayout === "function") {
            box.beforeLayout();
          }
        });
        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
        const params = Object.freeze({
          outerWidth: width,
          outerHeight: height,
          padding,
          availableWidth,
          availableHeight,
          vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
          hBoxMaxHeight: availableHeight / 2
        });
        const maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, toPadding(minPadding));
        const chartArea = Object.assign({
          maxPadding,
          w: availableWidth,
          h: availableHeight,
          x: padding.left,
          y: padding.top
        }, padding);
        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea, params, stacks);
        fitBoxes(verticalBoxes, chartArea, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
          fitBoxes(verticalBoxes, chartArea, params, stacks);
        }
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
        chart.chartArea = {
          left: chartArea.left,
          top: chartArea.top,
          right: chartArea.left + chartArea.w,
          bottom: chartArea.top + chartArea.h,
          height: chartArea.h,
          width: chartArea.w
        };
        each(boxes.chartArea, (layout) => {
          const box = layout.box;
          Object.assign(box, chart.chartArea);
          box.update(chartArea.w, chartArea.h, {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          });
        });
      }
    };
    class BasePlatform {
      acquireContext(canvas, aspectRatio) {
      }
      releaseContext(context) {
        return false;
      }
      addEventListener(chart, type, listener) {
      }
      removeEventListener(chart, type, listener) {
      }
      getDevicePixelRatio() {
        return 1;
      }
      getMaximumSize(element, width, height, aspectRatio) {
        width = Math.max(0, width || element.width);
        height = height || element.height;
        return {
          width,
          height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
        };
      }
      isAttached(canvas) {
        return true;
      }
      updateConfig(config) {
      }
    }
    class BasicPlatform extends BasePlatform {
      acquireContext(item) {
        return item && item.getContext && item.getContext("2d") || null;
      }
      updateConfig(config) {
        config.options.animation = false;
      }
    }
    const EXPANDO_KEY = "$chartjs";
    const EVENT_TYPES = {
      touchstart: "mousedown",
      touchmove: "mousemove",
      touchend: "mouseup",
      pointerenter: "mouseenter",
      pointerdown: "mousedown",
      pointermove: "mousemove",
      pointerup: "mouseup",
      pointerleave: "mouseout",
      pointerout: "mouseout"
    };
    const isNullOrEmpty = (value) => value === null || value === "";
    function initCanvas(canvas, aspectRatio) {
      const style = canvas.style;
      const renderHeight = canvas.getAttribute("height");
      const renderWidth = canvas.getAttribute("width");
      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      };
      style.display = style.display || "block";
      style.boxSizing = style.boxSizing || "border-box";
      if (isNullOrEmpty(renderWidth)) {
        const displayWidth = readUsedSize(canvas, "width");
        if (displayWidth !== void 0) {
          canvas.width = displayWidth;
        }
      }
      if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === "") {
          canvas.height = canvas.width / (aspectRatio || 2);
        } else {
          const displayHeight = readUsedSize(canvas, "height");
          if (displayHeight !== void 0) {
            canvas.height = displayHeight;
          }
        }
      }
      return canvas;
    }
    const eventListenerOptions = supportsEventListenerOptions ? {
      passive: true
    } : false;
    function addListener(node, type, listener) {
      if (node) {
        node.addEventListener(type, listener, eventListenerOptions);
      }
    }
    function removeListener(chart, type, listener) {
      if (chart && chart.canvas) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
      }
    }
    function fromNativeEvent(event, chart) {
      const type = EVENT_TYPES[event.type] || event.type;
      const { x, y } = getRelativePosition(event, chart);
      return {
        type,
        chart,
        native: event,
        x: x !== void 0 ? x : null,
        y: y !== void 0 ? y : null
      };
    }
    function nodeListContains(nodeList, canvas) {
      for (const node of nodeList) {
        if (node === canvas || node.contains(canvas)) {
          return true;
        }
      }
    }
    function createAttachObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const observer = new MutationObserver((entries) => {
        let trigger = false;
        for (const entry of entries) {
          trigger = trigger || nodeListContains(entry.addedNodes, canvas);
          trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
        }
        if (trigger) {
          listener();
        }
      });
      observer.observe(document, {
        childList: true,
        subtree: true
      });
      return observer;
    }
    function createDetachObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const observer = new MutationObserver((entries) => {
        let trigger = false;
        for (const entry of entries) {
          trigger = trigger || nodeListContains(entry.removedNodes, canvas);
          trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
        }
        if (trigger) {
          listener();
        }
      });
      observer.observe(document, {
        childList: true,
        subtree: true
      });
      return observer;
    }
    const drpListeningCharts = /* @__PURE__ */ new Map();
    let oldDevicePixelRatio = 0;
    function onWindowResize() {
      const dpr = window.devicePixelRatio;
      if (dpr === oldDevicePixelRatio) {
        return;
      }
      oldDevicePixelRatio = dpr;
      drpListeningCharts.forEach((resize, chart) => {
        if (chart.currentDevicePixelRatio !== dpr) {
          resize();
        }
      });
    }
    function listenDevicePixelRatioChanges(chart, resize) {
      if (!drpListeningCharts.size) {
        window.addEventListener("resize", onWindowResize);
      }
      drpListeningCharts.set(chart, resize);
    }
    function unlistenDevicePixelRatioChanges(chart) {
      drpListeningCharts.delete(chart);
      if (!drpListeningCharts.size) {
        window.removeEventListener("resize", onWindowResize);
      }
    }
    function createResizeObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const container = canvas && _getParentNode(canvas);
      if (!container) {
        return;
      }
      const resize = throttled((width, height) => {
        const w = container.clientWidth;
        listener(width, height);
        if (w < container.clientWidth) {
          listener();
        }
      }, window);
      const observer = new ResizeObserver((entries) => {
        const entry = entries[0];
        const width = entry.contentRect.width;
        const height = entry.contentRect.height;
        if (width === 0 && height === 0) {
          return;
        }
        resize(width, height);
      });
      observer.observe(container);
      listenDevicePixelRatioChanges(chart, resize);
      return observer;
    }
    function releaseObserver(chart, type, observer) {
      if (observer) {
        observer.disconnect();
      }
      if (type === "resize") {
        unlistenDevicePixelRatioChanges(chart);
      }
    }
    function createProxyAndListen(chart, type, listener) {
      const canvas = chart.canvas;
      const proxy = throttled((event) => {
        if (chart.ctx !== null) {
          listener(fromNativeEvent(event, chart));
        }
      }, chart);
      addListener(canvas, type, proxy);
      return proxy;
    }
    class DomPlatform extends BasePlatform {
      acquireContext(canvas, aspectRatio) {
        const context = canvas && canvas.getContext && canvas.getContext("2d");
        if (context && context.canvas === canvas) {
          initCanvas(canvas, aspectRatio);
          return context;
        }
        return null;
      }
      releaseContext(context) {
        const canvas = context.canvas;
        if (!canvas[EXPANDO_KEY]) {
          return false;
        }
        const initial = canvas[EXPANDO_KEY].initial;
        [
          "height",
          "width"
        ].forEach((prop) => {
          const value = initial[prop];
          if (isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        const style = initial.style || {};
        Object.keys(style).forEach((key) => {
          canvas.style[key] = style[key];
        });
        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
        return true;
      }
      addEventListener(chart, type, listener) {
        this.removeEventListener(chart, type);
        const proxies = chart.$proxies || (chart.$proxies = {});
        const handlers = {
          attach: createAttachObserver,
          detach: createDetachObserver,
          resize: createResizeObserver
        };
        const handler = handlers[type] || createProxyAndListen;
        proxies[type] = handler(chart, type, listener);
      }
      removeEventListener(chart, type) {
        const proxies = chart.$proxies || (chart.$proxies = {});
        const proxy = proxies[type];
        if (!proxy) {
          return;
        }
        const handlers = {
          attach: releaseObserver,
          detach: releaseObserver,
          resize: releaseObserver
        };
        const handler = handlers[type] || removeListener;
        handler(chart, type, proxy);
        proxies[type] = void 0;
      }
      getDevicePixelRatio() {
        return window.devicePixelRatio;
      }
      getMaximumSize(canvas, width, height, aspectRatio) {
        return getMaximumSize(canvas, width, height, aspectRatio);
      }
      isAttached(canvas) {
        const container = canvas && _getParentNode(canvas);
        return !!(container && container.isConnected);
      }
    }
    function _detectPlatform(canvas) {
      if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
        return BasicPlatform;
      }
      return DomPlatform;
    }
    let Element$1 = (_a = class {
      constructor() {
        __publicField(this, "x");
        __publicField(this, "y");
        __publicField(this, "active", false);
        __publicField(this, "options");
        __publicField(this, "$animations");
      }
      tooltipPosition(useFinalPosition) {
        const { x, y } = this.getProps([
          "x",
          "y"
        ], useFinalPosition);
        return {
          x,
          y
        };
      }
      hasValue() {
        return isNumber$1(this.x) && isNumber$1(this.y);
      }
      getProps(props, final) {
        const anims = this.$animations;
        if (!final || !anims) {
          return this;
        }
        const ret = {};
        props.forEach((prop) => {
          ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
        });
        return ret;
      }
    }, __publicField(_a, "defaults", {}), __publicField(_a, "defaultRoutes"), _a);
    function autoSkip(scale, ticks) {
      const tickOpts = scale.options.ticks;
      const determinedMaxTicks = determineMaxTicks(scale);
      const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
      const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
      const numMajorIndices = majorIndices.length;
      const first = majorIndices[0];
      const last = majorIndices[numMajorIndices - 1];
      const newTicks = [];
      if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
      }
      const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
      if (numMajorIndices > 0) {
        let i, ilen;
        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
          skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
        }
        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return newTicks;
      }
      skip(ticks, newTicks, spacing);
      return newTicks;
    }
    function determineMaxTicks(scale) {
      const offset2 = scale.options.offset;
      const tickLength = scale._tickSize();
      const maxScale = scale._length / tickLength + (offset2 ? 0 : 1);
      const maxChart = scale._maxLength / tickLength;
      return Math.floor(Math.min(maxScale, maxChart));
    }
    function calculateSpacing(majorIndices, ticks, ticksLimit) {
      const evenMajorSpacing = getEvenSpacing(majorIndices);
      const spacing = ticks.length / ticksLimit;
      if (!evenMajorSpacing) {
        return Math.max(spacing, 1);
      }
      const factors = _factorize(evenMajorSpacing);
      for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
        const factor = factors[i];
        if (factor > spacing) {
          return factor;
        }
      }
      return Math.max(spacing, 1);
    }
    function getMajorIndices(ticks) {
      const result = [];
      let i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        if (ticks[i].major) {
          result.push(i);
        }
      }
      return result;
    }
    function skipMajors(ticks, newTicks, majorIndices, spacing) {
      let count = 0;
      let next = majorIndices[0];
      let i;
      spacing = Math.ceil(spacing);
      for (i = 0; i < ticks.length; i++) {
        if (i === next) {
          newTicks.push(ticks[i]);
          count++;
          next = majorIndices[count * spacing];
        }
      }
    }
    function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
      const start2 = valueOrDefault(majorStart, 0);
      const end2 = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
      let count = 0;
      let length, i, next;
      spacing = Math.ceil(spacing);
      if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
      }
      next = start2;
      while (next < 0) {
        count++;
        next = Math.round(start2 + count * spacing);
      }
      for (i = Math.max(start2, 0); i < end2; i++) {
        if (i === next) {
          newTicks.push(ticks[i]);
          count++;
          next = Math.round(start2 + count * spacing);
        }
      }
    }
    function getEvenSpacing(arr) {
      const len = arr.length;
      let i, diff2;
      if (len < 2) {
        return false;
      }
      for (diff2 = arr[0], i = 1; i < len; ++i) {
        if (arr[i] - arr[i - 1] !== diff2) {
          return false;
        }
      }
      return diff2;
    }
    const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
    const offsetFromEdge = (scale, edge, offset2) => edge === "top" || edge === "left" ? scale[edge] + offset2 : scale[edge] - offset2;
    const getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
    function sample(arr, numItems) {
      const result = [];
      const increment = arr.length / numItems;
      const len = arr.length;
      let i = 0;
      for (; i < len; i += increment) {
        result.push(arr[Math.floor(i)]);
      }
      return result;
    }
    function getPixelForGridLine(scale, index2, offsetGridLines) {
      const length = scale.ticks.length;
      const validIndex = Math.min(index2, length - 1);
      const start2 = scale._startPixel;
      const end2 = scale._endPixel;
      const epsilon = 1e-6;
      let lineValue = scale.getPixelForTick(validIndex);
      let offset2;
      if (offsetGridLines) {
        if (length === 1) {
          offset2 = Math.max(lineValue - start2, end2 - lineValue);
        } else if (index2 === 0) {
          offset2 = (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          offset2 = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
        }
        lineValue += validIndex < index2 ? offset2 : -offset2;
        if (lineValue < start2 - epsilon || lineValue > end2 + epsilon) {
          return;
        }
      }
      return lineValue;
    }
    function garbageCollect(caches, length) {
      each(caches, (cache) => {
        const gc = cache.gc;
        const gcLen = gc.length / 2;
        let i;
        if (gcLen > length) {
          for (i = 0; i < gcLen; ++i) {
            delete cache.data[gc[i]];
          }
          gc.splice(0, gcLen);
        }
      });
    }
    function getTickMarkLength(options) {
      return options.drawTicks ? options.tickLength : 0;
    }
    function getTitleHeight(options, fallback) {
      if (!options.display) {
        return 0;
      }
      const font = toFont(options.font, fallback);
      const padding = toPadding(options.padding);
      const lines = isArray$1(options.text) ? options.text.length : 1;
      return lines * font.lineHeight + padding.height;
    }
    function createScaleContext(parent, scale) {
      return createContext(parent, {
        scale,
        type: "scale"
      });
    }
    function createTickContext(parent, index2, tick) {
      return createContext(parent, {
        tick,
        index: index2,
        type: "tick"
      });
    }
    function titleAlign(align, position, reverse) {
      let ret = _toLeftRightCenter(align);
      if (reverse && position !== "right" || !reverse && position === "right") {
        ret = reverseAlign(ret);
      }
      return ret;
    }
    function titleArgs(scale, offset2, position, align) {
      const { top: top2, left: left2, bottom: bottom2, right: right2, chart } = scale;
      const { chartArea, scales } = chart;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      const height = bottom2 - top2;
      const width = right2 - left2;
      if (scale.isHorizontal()) {
        titleX = _alignStartEnd(align, left2, right2);
        if (isObject$1(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          titleY = scales[positionAxisID].getPixelForValue(value) + height - offset2;
        } else if (position === "center") {
          titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
        } else {
          titleY = offsetFromEdge(scale, position, offset2);
        }
        maxWidth = right2 - left2;
      } else {
        if (isObject$1(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          titleX = scales[positionAxisID].getPixelForValue(value) - width + offset2;
        } else if (position === "center") {
          titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
        } else {
          titleX = offsetFromEdge(scale, position, offset2);
        }
        titleY = _alignStartEnd(align, bottom2, top2);
        rotation = position === "left" ? -HALF_PI : HALF_PI;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    class Scale extends Element$1 {
      constructor(cfg) {
        super();
        this.id = cfg.id;
        this.type = cfg.type;
        this.options = void 0;
        this.ctx = cfg.ctx;
        this.chart = cfg.chart;
        this.top = void 0;
        this.bottom = void 0;
        this.left = void 0;
        this.right = void 0;
        this.width = void 0;
        this.height = void 0;
        this._margins = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        };
        this.maxWidth = void 0;
        this.maxHeight = void 0;
        this.paddingTop = void 0;
        this.paddingBottom = void 0;
        this.paddingLeft = void 0;
        this.paddingRight = void 0;
        this.axis = void 0;
        this.labelRotation = void 0;
        this.min = void 0;
        this.max = void 0;
        this._range = void 0;
        this.ticks = [];
        this._gridLineItems = null;
        this._labelItems = null;
        this._labelSizes = null;
        this._length = 0;
        this._maxLength = 0;
        this._longestTextCache = {};
        this._startPixel = void 0;
        this._endPixel = void 0;
        this._reversePixels = false;
        this._userMax = void 0;
        this._userMin = void 0;
        this._suggestedMax = void 0;
        this._suggestedMin = void 0;
        this._ticksLength = 0;
        this._borderValue = 0;
        this._cache = {};
        this._dataLimitsCached = false;
        this.$context = void 0;
      }
      init(options) {
        this.options = options.setContext(this.getContext());
        this.axis = options.axis;
        this._userMin = this.parse(options.min);
        this._userMax = this.parse(options.max);
        this._suggestedMin = this.parse(options.suggestedMin);
        this._suggestedMax = this.parse(options.suggestedMax);
      }
      parse(raw, index2) {
        return raw;
      }
      getUserBounds() {
        let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
        return {
          min: finiteOrDefault(_userMin, _suggestedMin),
          max: finiteOrDefault(_userMax, _suggestedMax),
          minDefined: isNumberFinite(_userMin),
          maxDefined: isNumberFinite(_userMax)
        };
      }
      getMinMax(canStack) {
        let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
        let range2;
        if (minDefined && maxDefined) {
          return {
            min: min2,
            max: max2
          };
        }
        const metas = this.getMatchingVisibleMetas();
        for (let i = 0, ilen = metas.length; i < ilen; ++i) {
          range2 = metas[i].controller.getMinMax(this, canStack);
          if (!minDefined) {
            min2 = Math.min(min2, range2.min);
          }
          if (!maxDefined) {
            max2 = Math.max(max2, range2.max);
          }
        }
        min2 = maxDefined && min2 > max2 ? max2 : min2;
        max2 = minDefined && min2 > max2 ? min2 : max2;
        return {
          min: finiteOrDefault(min2, finiteOrDefault(max2, min2)),
          max: finiteOrDefault(max2, finiteOrDefault(min2, max2))
        };
      }
      getPadding() {
        return {
          left: this.paddingLeft || 0,
          top: this.paddingTop || 0,
          right: this.paddingRight || 0,
          bottom: this.paddingBottom || 0
        };
      }
      getTicks() {
        return this.ticks;
      }
      getLabels() {
        const data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
      }
      getLabelItems(chartArea = this.chart.chartArea) {
        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
        return items;
      }
      beforeLayout() {
        this._cache = {};
        this._dataLimitsCached = false;
      }
      beforeUpdate() {
        callback(this.options.beforeUpdate, [
          this
        ]);
      }
      update(maxWidth, maxHeight, margins) {
        const { beginAtZero, grace, ticks: tickOpts } = this.options;
        const sampleSize = tickOpts.sampleSize;
        this.beforeUpdate();
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins = Object.assign({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        this.ticks = null;
        this._labelSizes = null;
        this._gridLineItems = null;
        this._labelItems = null;
        this.beforeSetDimensions();
        this.setDimensions();
        this.afterSetDimensions();
        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
        if (!this._dataLimitsCached) {
          this.beforeDataLimits();
          this.determineDataLimits();
          this.afterDataLimits();
          this._range = _addGrace(this, grace, beginAtZero);
          this._dataLimitsCached = true;
        }
        this.beforeBuildTicks();
        this.ticks = this.buildTicks() || [];
        this.afterBuildTicks();
        const samplingEnabled = sampleSize < this.ticks.length;
        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
        this.configure();
        this.beforeCalculateLabelRotation();
        this.calculateLabelRotation();
        this.afterCalculateLabelRotation();
        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
          this.ticks = autoSkip(this, this.ticks);
          this._labelSizes = null;
          this.afterAutoSkip();
        }
        if (samplingEnabled) {
          this._convertTicksToLabels(this.ticks);
        }
        this.beforeFit();
        this.fit();
        this.afterFit();
        this.afterUpdate();
      }
      configure() {
        let reversePixels = this.options.reverse;
        let startPixel, endPixel;
        if (this.isHorizontal()) {
          startPixel = this.left;
          endPixel = this.right;
        } else {
          startPixel = this.top;
          endPixel = this.bottom;
          reversePixels = !reversePixels;
        }
        this._startPixel = startPixel;
        this._endPixel = endPixel;
        this._reversePixels = reversePixels;
        this._length = endPixel - startPixel;
        this._alignToPixels = this.options.alignToPixels;
      }
      afterUpdate() {
        callback(this.options.afterUpdate, [
          this
        ]);
      }
      beforeSetDimensions() {
        callback(this.options.beforeSetDimensions, [
          this
        ]);
      }
      setDimensions() {
        if (this.isHorizontal()) {
          this.width = this.maxWidth;
          this.left = 0;
          this.right = this.width;
        } else {
          this.height = this.maxHeight;
          this.top = 0;
          this.bottom = this.height;
        }
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.paddingRight = 0;
        this.paddingBottom = 0;
      }
      afterSetDimensions() {
        callback(this.options.afterSetDimensions, [
          this
        ]);
      }
      _callHooks(name) {
        this.chart.notifyPlugins(name, this.getContext());
        callback(this.options[name], [
          this
        ]);
      }
      beforeDataLimits() {
        this._callHooks("beforeDataLimits");
      }
      determineDataLimits() {
      }
      afterDataLimits() {
        this._callHooks("afterDataLimits");
      }
      beforeBuildTicks() {
        this._callHooks("beforeBuildTicks");
      }
      buildTicks() {
        return [];
      }
      afterBuildTicks() {
        this._callHooks("afterBuildTicks");
      }
      beforeTickToLabelConversion() {
        callback(this.options.beforeTickToLabelConversion, [
          this
        ]);
      }
      generateTickLabels(ticks) {
        const tickOpts = this.options.ticks;
        let i, ilen, tick;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
          tick = ticks[i];
          tick.label = callback(tickOpts.callback, [
            tick.value,
            i,
            ticks
          ], this);
        }
      }
      afterTickToLabelConversion() {
        callback(this.options.afterTickToLabelConversion, [
          this
        ]);
      }
      beforeCalculateLabelRotation() {
        callback(this.options.beforeCalculateLabelRotation, [
          this
        ]);
      }
      calculateLabelRotation() {
        const options = this.options;
        const tickOpts = options.ticks;
        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
        const minRotation = tickOpts.minRotation || 0;
        const maxRotation = tickOpts.maxRotation;
        let labelRotation = minRotation;
        let tickWidth, maxHeight, maxLabelDiagonal;
        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
          this.labelRotation = minRotation;
          return;
        }
        const labelSizes = this._getLabelSizes();
        const maxLabelWidth = labelSizes.widest.width;
        const maxLabelHeight = labelSizes.highest.height;
        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
          tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
          maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
          maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
          labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
          labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        this.labelRotation = labelRotation;
      }
      afterCalculateLabelRotation() {
        callback(this.options.afterCalculateLabelRotation, [
          this
        ]);
      }
      afterAutoSkip() {
      }
      beforeFit() {
        callback(this.options.beforeFit, [
          this
        ]);
      }
      fit() {
        const minSize = {
          width: 0,
          height: 0
        };
        const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
        const display = this._isVisible();
        const isHorizontal = this.isHorizontal();
        if (display) {
          const titleHeight = getTitleHeight(titleOpts, chart.options.font);
          if (isHorizontal) {
            minSize.width = this.maxWidth;
            minSize.height = getTickMarkLength(gridOpts) + titleHeight;
          } else {
            minSize.height = this.maxHeight;
            minSize.width = getTickMarkLength(gridOpts) + titleHeight;
          }
          if (tickOpts.display && this.ticks.length) {
            const { first, last, widest, highest } = this._getLabelSizes();
            const tickPadding = tickOpts.padding * 2;
            const angleRadians = toRadians(this.labelRotation);
            const cos = Math.cos(angleRadians);
            const sin = Math.sin(angleRadians);
            if (isHorizontal) {
              const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
              minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
            } else {
              const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
              minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
            }
            this._calculatePadding(first, last, sin, cos);
          }
        }
        this._handleMargins();
        if (isHorizontal) {
          this.width = this._length = chart.width - this._margins.left - this._margins.right;
          this.height = minSize.height;
        } else {
          this.width = minSize.width;
          this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
        }
      }
      _calculatePadding(first, last, sin, cos) {
        const { ticks: { align, padding }, position } = this.options;
        const isRotated = this.labelRotation !== 0;
        const labelsBelowTicks = position !== "top" && this.axis === "x";
        if (this.isHorizontal()) {
          const offsetLeft = this.getPixelForTick(0) - this.left;
          const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
          let paddingLeft = 0;
          let paddingRight = 0;
          if (isRotated) {
            if (labelsBelowTicks) {
              paddingLeft = cos * first.width;
              paddingRight = sin * last.height;
            } else {
              paddingLeft = sin * first.height;
              paddingRight = cos * last.width;
            }
          } else if (align === "start") {
            paddingRight = last.width;
          } else if (align === "end") {
            paddingLeft = first.width;
          } else if (align !== "inner") {
            paddingLeft = first.width / 2;
            paddingRight = last.width / 2;
          }
          this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
          this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
        } else {
          let paddingTop = last.height / 2;
          let paddingBottom = first.height / 2;
          if (align === "start") {
            paddingTop = 0;
            paddingBottom = first.height;
          } else if (align === "end") {
            paddingTop = last.height;
            paddingBottom = 0;
          }
          this.paddingTop = paddingTop + padding;
          this.paddingBottom = paddingBottom + padding;
        }
      }
      _handleMargins() {
        if (this._margins) {
          this._margins.left = Math.max(this.paddingLeft, this._margins.left);
          this._margins.top = Math.max(this.paddingTop, this._margins.top);
          this._margins.right = Math.max(this.paddingRight, this._margins.right);
          this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
        }
      }
      afterFit() {
        callback(this.options.afterFit, [
          this
        ]);
      }
      isHorizontal() {
        const { axis, position } = this.options;
        return position === "top" || position === "bottom" || axis === "x";
      }
      isFullSize() {
        return this.options.fullSize;
      }
      _convertTicksToLabels(ticks) {
        this.beforeTickToLabelConversion();
        this.generateTickLabels(ticks);
        let i, ilen;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
          if (isNullOrUndef(ticks[i].label)) {
            ticks.splice(i, 1);
            ilen--;
            i--;
          }
        }
        this.afterTickToLabelConversion();
      }
      _getLabelSizes() {
        let labelSizes = this._labelSizes;
        if (!labelSizes) {
          const sampleSize = this.options.ticks.sampleSize;
          let ticks = this.ticks;
          if (sampleSize < ticks.length) {
            ticks = sample(ticks, sampleSize);
          }
          this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
        }
        return labelSizes;
      }
      _computeLabelSizes(ticks, length, maxTicksLimit) {
        const { ctx, _longestTextCache: caches } = this;
        const widths = [];
        const heights = [];
        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
        let widestLabelSize = 0;
        let highestLabelSize = 0;
        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
        for (i = 0; i < length; i += increment) {
          label = ticks[i].label;
          tickFont = this._resolveTickFontOptions(i);
          ctx.font = fontString = tickFont.string;
          cache = caches[fontString] = caches[fontString] || {
            data: {},
            gc: []
          };
          lineHeight = tickFont.lineHeight;
          width = height = 0;
          if (!isNullOrUndef(label) && !isArray$1(label)) {
            width = _measureText(ctx, cache.data, cache.gc, width, label);
            height = lineHeight;
          } else if (isArray$1(label)) {
            for (j = 0, jlen = label.length; j < jlen; ++j) {
              nestedLabel = label[j];
              if (!isNullOrUndef(nestedLabel) && !isArray$1(nestedLabel)) {
                width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                height += lineHeight;
              }
            }
          }
          widths.push(width);
          heights.push(height);
          widestLabelSize = Math.max(width, widestLabelSize);
          highestLabelSize = Math.max(height, highestLabelSize);
        }
        garbageCollect(caches, length);
        const widest = widths.indexOf(widestLabelSize);
        const highest = heights.indexOf(highestLabelSize);
        const valueAt = (idx) => ({
          width: widths[idx] || 0,
          height: heights[idx] || 0
        });
        return {
          first: valueAt(0),
          last: valueAt(length - 1),
          widest: valueAt(widest),
          highest: valueAt(highest),
          widths,
          heights
        };
      }
      getLabelForValue(value) {
        return value;
      }
      getPixelForValue(value, index2) {
        return NaN;
      }
      getValueForPixel(pixel) {
      }
      getPixelForTick(index2) {
        const ticks = this.ticks;
        if (index2 < 0 || index2 > ticks.length - 1) {
          return null;
        }
        return this.getPixelForValue(ticks[index2].value);
      }
      getPixelForDecimal(decimal) {
        if (this._reversePixels) {
          decimal = 1 - decimal;
        }
        const pixel = this._startPixel + decimal * this._length;
        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
      }
      getDecimalForPixel(pixel) {
        const decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
      }
      getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
      }
      getBaseValue() {
        const { min: min2, max: max2 } = this;
        return min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
      }
      getContext(index2) {
        const ticks = this.ticks || [];
        if (index2 >= 0 && index2 < ticks.length) {
          const tick = ticks[index2];
          return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
        }
        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
      }
      _tickSize() {
        const optionTicks = this.options.ticks;
        const rot = toRadians(this.labelRotation);
        const cos = Math.abs(Math.cos(rot));
        const sin = Math.abs(Math.sin(rot));
        const labelSizes = this._getLabelSizes();
        const padding = optionTicks.autoSkipPadding || 0;
        const w = labelSizes ? labelSizes.widest.width + padding : 0;
        const h = labelSizes ? labelSizes.highest.height + padding : 0;
        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      }
      _isVisible() {
        const display = this.options.display;
        if (display !== "auto") {
          return !!display;
        }
        return this.getMatchingVisibleMetas().length > 0;
      }
      _computeGridLineItems(chartArea) {
        const axis = this.axis;
        const chart = this.chart;
        const options = this.options;
        const { grid, position, border } = options;
        const offset2 = grid.offset;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const ticksLength = ticks.length + (offset2 ? 1 : 0);
        const tl = getTickMarkLength(grid);
        const items = [];
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = borderOpts.display ? borderOpts.width : 0;
        const axisHalfWidth = axisWidth / 2;
        const alignBorderValue = function(pixel) {
          return _alignPixel(chart, pixel, axisWidth);
        };
        let borderValue, i, lineValue, alignedLineValue;
        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
        if (position === "top") {
          borderValue = alignBorderValue(this.bottom);
          ty1 = this.bottom - tl;
          ty2 = borderValue - axisHalfWidth;
          y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
          y2 = chartArea.bottom;
        } else if (position === "bottom") {
          borderValue = alignBorderValue(this.top);
          y1 = chartArea.top;
          y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
          ty1 = borderValue + axisHalfWidth;
          ty2 = this.top + tl;
        } else if (position === "left") {
          borderValue = alignBorderValue(this.right);
          tx1 = this.right - tl;
          tx2 = borderValue - axisHalfWidth;
          x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
          x2 = chartArea.right;
        } else if (position === "right") {
          borderValue = alignBorderValue(this.left);
          x1 = chartArea.left;
          x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
          tx1 = borderValue + axisHalfWidth;
          tx2 = this.left + tl;
        } else if (axis === "x") {
          if (position === "center") {
            borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
          } else if (isObject$1(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
          }
          y1 = chartArea.top;
          y2 = chartArea.bottom;
          ty1 = borderValue + axisHalfWidth;
          ty2 = ty1 + tl;
        } else if (axis === "y") {
          if (position === "center") {
            borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
          } else if (isObject$1(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
          }
          tx1 = borderValue - axisHalfWidth;
          tx2 = tx1 - tl;
          x1 = chartArea.left;
          x2 = chartArea.right;
        }
        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
        const step = Math.max(1, Math.ceil(ticksLength / limit));
        for (i = 0; i < ticksLength; i += step) {
          const context = this.getContext(i);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          const lineWidth = optsAtIndex.lineWidth;
          const lineColor = optsAtIndex.color;
          const borderDash = optsAtIndexBorder.dash || [];
          const borderDashOffset = optsAtIndexBorder.dashOffset;
          const tickWidth = optsAtIndex.tickWidth;
          const tickColor = optsAtIndex.tickColor;
          const tickBorderDash = optsAtIndex.tickBorderDash || [];
          const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
          lineValue = getPixelForGridLine(this, i, offset2);
          if (lineValue === void 0) {
            continue;
          }
          alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
          if (isHorizontal) {
            tx1 = tx2 = x1 = x2 = alignedLineValue;
          } else {
            ty1 = ty2 = y1 = y2 = alignedLineValue;
          }
          items.push({
            tx1,
            ty1,
            tx2,
            ty2,
            x1,
            y1,
            x2,
            y2,
            width: lineWidth,
            color: lineColor,
            borderDash,
            borderDashOffset,
            tickWidth,
            tickColor,
            tickBorderDash,
            tickBorderDashOffset
          });
        }
        this._ticksLength = ticksLength;
        this._borderValue = borderValue;
        return items;
      }
      _computeLabelItems(chartArea) {
        const axis = this.axis;
        const options = this.options;
        const { position, ticks: optionTicks } = options;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const { align, crossAlign, padding, mirror } = optionTicks;
        const tl = getTickMarkLength(options.grid);
        const tickAndPadding = tl + padding;
        const hTickAndPadding = mirror ? -padding : tickAndPadding;
        const rotation = -toRadians(this.labelRotation);
        const items = [];
        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
        let textBaseline = "middle";
        if (position === "top") {
          y = this.bottom - hTickAndPadding;
          textAlign = this._getXAxisLabelAlignment();
        } else if (position === "bottom") {
          y = this.top + hTickAndPadding;
          textAlign = this._getXAxisLabelAlignment();
        } else if (position === "left") {
          const ret = this._getYAxisLabelAlignment(tl);
          textAlign = ret.textAlign;
          x = ret.x;
        } else if (position === "right") {
          const ret = this._getYAxisLabelAlignment(tl);
          textAlign = ret.textAlign;
          x = ret.x;
        } else if (axis === "x") {
          if (position === "center") {
            y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
          } else if (isObject$1(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
          }
          textAlign = this._getXAxisLabelAlignment();
        } else if (axis === "y") {
          if (position === "center") {
            x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
          } else if (isObject$1(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            x = this.chart.scales[positionAxisID].getPixelForValue(value);
          }
          textAlign = this._getYAxisLabelAlignment(tl).textAlign;
        }
        if (axis === "y") {
          if (align === "start") {
            textBaseline = "top";
          } else if (align === "end") {
            textBaseline = "bottom";
          }
        }
        const labelSizes = this._getLabelSizes();
        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          tick = ticks[i];
          label = tick.label;
          const optsAtIndex = optionTicks.setContext(this.getContext(i));
          pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
          font = this._resolveTickFontOptions(i);
          lineHeight = font.lineHeight;
          lineCount = isArray$1(label) ? label.length : 1;
          const halfCount = lineCount / 2;
          const color2 = optsAtIndex.color;
          const strokeColor = optsAtIndex.textStrokeColor;
          const strokeWidth = optsAtIndex.textStrokeWidth;
          let tickTextAlign = textAlign;
          if (isHorizontal) {
            x = pixel;
            if (textAlign === "inner") {
              if (i === ilen - 1) {
                tickTextAlign = !this.options.reverse ? "right" : "left";
              } else if (i === 0) {
                tickTextAlign = !this.options.reverse ? "left" : "right";
              } else {
                tickTextAlign = "center";
              }
            }
            if (position === "top") {
              if (crossAlign === "near" || rotation !== 0) {
                textOffset = -lineCount * lineHeight + lineHeight / 2;
              } else if (crossAlign === "center") {
                textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
              } else {
                textOffset = -labelSizes.highest.height + lineHeight / 2;
              }
            } else {
              if (crossAlign === "near" || rotation !== 0) {
                textOffset = lineHeight / 2;
              } else if (crossAlign === "center") {
                textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
              } else {
                textOffset = labelSizes.highest.height - lineCount * lineHeight;
              }
            }
            if (mirror) {
              textOffset *= -1;
            }
            if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
              x += lineHeight / 2 * Math.sin(rotation);
            }
          } else {
            y = pixel;
            textOffset = (1 - lineCount) * lineHeight / 2;
          }
          let backdrop;
          if (optsAtIndex.showLabelBackdrop) {
            const labelPadding = toPadding(optsAtIndex.backdropPadding);
            const height = labelSizes.heights[i];
            const width = labelSizes.widths[i];
            let top2 = textOffset - labelPadding.top;
            let left2 = 0 - labelPadding.left;
            switch (textBaseline) {
              case "middle":
                top2 -= height / 2;
                break;
              case "bottom":
                top2 -= height;
                break;
            }
            switch (textAlign) {
              case "center":
                left2 -= width / 2;
                break;
              case "right":
                left2 -= width;
                break;
              case "inner":
                if (i === ilen - 1) {
                  left2 -= width;
                } else if (i > 0) {
                  left2 -= width / 2;
                }
                break;
            }
            backdrop = {
              left: left2,
              top: top2,
              width: width + labelPadding.width,
              height: height + labelPadding.height,
              color: optsAtIndex.backdropColor
            };
          }
          items.push({
            label,
            font,
            textOffset,
            options: {
              rotation,
              color: color2,
              strokeColor,
              strokeWidth,
              textAlign: tickTextAlign,
              textBaseline,
              translation: [
                x,
                y
              ],
              backdrop
            }
          });
        }
        return items;
      }
      _getXAxisLabelAlignment() {
        const { position, ticks } = this.options;
        const rotation = -toRadians(this.labelRotation);
        if (rotation) {
          return position === "top" ? "left" : "right";
        }
        let align = "center";
        if (ticks.align === "start") {
          align = "left";
        } else if (ticks.align === "end") {
          align = "right";
        } else if (ticks.align === "inner") {
          align = "inner";
        }
        return align;
      }
      _getYAxisLabelAlignment(tl) {
        const { position, ticks: { crossAlign, mirror, padding } } = this.options;
        const labelSizes = this._getLabelSizes();
        const tickAndPadding = tl + padding;
        const widest = labelSizes.widest.width;
        let textAlign;
        let x;
        if (position === "left") {
          if (mirror) {
            x = this.right + padding;
            if (crossAlign === "near") {
              textAlign = "left";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x += widest / 2;
            } else {
              textAlign = "right";
              x += widest;
            }
          } else {
            x = this.right - tickAndPadding;
            if (crossAlign === "near") {
              textAlign = "right";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x -= widest / 2;
            } else {
              textAlign = "left";
              x = this.left;
            }
          }
        } else if (position === "right") {
          if (mirror) {
            x = this.left + padding;
            if (crossAlign === "near") {
              textAlign = "right";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x -= widest / 2;
            } else {
              textAlign = "left";
              x -= widest;
            }
          } else {
            x = this.left + tickAndPadding;
            if (crossAlign === "near") {
              textAlign = "left";
            } else if (crossAlign === "center") {
              textAlign = "center";
              x += widest / 2;
            } else {
              textAlign = "right";
              x = this.right;
            }
          }
        } else {
          textAlign = "right";
        }
        return {
          textAlign,
          x
        };
      }
      _computeLabelArea() {
        if (this.options.ticks.mirror) {
          return;
        }
        const chart = this.chart;
        const position = this.options.position;
        if (position === "left" || position === "right") {
          return {
            top: 0,
            left: this.left,
            bottom: chart.height,
            right: this.right
          };
        }
        if (position === "top" || position === "bottom") {
          return {
            top: this.top,
            left: 0,
            bottom: this.bottom,
            right: chart.width
          };
        }
      }
      drawBackground() {
        const { ctx, options: { backgroundColor }, left: left2, top: top2, width, height } = this;
        if (backgroundColor) {
          ctx.save();
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(left2, top2, width, height);
          ctx.restore();
        }
      }
      getLineWidthForValue(value) {
        const grid = this.options.grid;
        if (!this._isVisible() || !grid.display) {
          return 0;
        }
        const ticks = this.ticks;
        const index2 = ticks.findIndex((t) => t.value === value);
        if (index2 >= 0) {
          const opts = grid.setContext(this.getContext(index2));
          return opts.lineWidth;
        }
        return 0;
      }
      drawGrid(chartArea) {
        const grid = this.options.grid;
        const ctx = this.ctx;
        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
        let i, ilen;
        const drawLine = (p1, p2, style) => {
          if (!style.width || !style.color) {
            return;
          }
          ctx.save();
          ctx.lineWidth = style.width;
          ctx.strokeStyle = style.color;
          ctx.setLineDash(style.borderDash || []);
          ctx.lineDashOffset = style.borderDashOffset;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
          ctx.restore();
        };
        if (grid.display) {
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            const item = items[i];
            if (grid.drawOnChartArea) {
              drawLine({
                x: item.x1,
                y: item.y1
              }, {
                x: item.x2,
                y: item.y2
              }, item);
            }
            if (grid.drawTicks) {
              drawLine({
                x: item.tx1,
                y: item.ty1
              }, {
                x: item.tx2,
                y: item.ty2
              }, {
                color: item.tickColor,
                width: item.tickWidth,
                borderDash: item.tickBorderDash,
                borderDashOffset: item.tickBorderDashOffset
              });
            }
          }
        }
      }
      drawBorder() {
        const { chart, ctx, options: { border, grid } } = this;
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = border.display ? borderOpts.width : 0;
        if (!axisWidth) {
          return;
        }
        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
        const borderValue = this._borderValue;
        let x1, x2, y1, y2;
        if (this.isHorizontal()) {
          x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
          x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
          y1 = y2 = borderValue;
        } else {
          y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
          y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
          x1 = x2 = borderValue;
        }
        ctx.save();
        ctx.lineWidth = borderOpts.width;
        ctx.strokeStyle = borderOpts.color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
      }
      drawLabels(chartArea) {
        const optionTicks = this.options.ticks;
        if (!optionTicks.display) {
          return;
        }
        const ctx = this.ctx;
        const area = this._computeLabelArea();
        if (area) {
          clipArea(ctx, area);
        }
        const items = this.getLabelItems(chartArea);
        for (const item of items) {
          const renderTextOptions = item.options;
          const tickFont = item.font;
          const label = item.label;
          const y = item.textOffset;
          renderText(ctx, label, 0, y, tickFont, renderTextOptions);
        }
        if (area) {
          unclipArea(ctx);
        }
      }
      drawTitle() {
        const { ctx, options: { position, title, reverse } } = this;
        if (!title.display) {
          return;
        }
        const font = toFont(title.font);
        const padding = toPadding(title.padding);
        const align = title.align;
        let offset2 = font.lineHeight / 2;
        if (position === "bottom" || position === "center" || isObject$1(position)) {
          offset2 += padding.bottom;
          if (isArray$1(title.text)) {
            offset2 += font.lineHeight * (title.text.length - 1);
          }
        } else {
          offset2 += padding.top;
        }
        const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
        renderText(ctx, title.text, 0, 0, font, {
          color: title.color,
          maxWidth,
          rotation,
          textAlign: titleAlign(align, position, reverse),
          textBaseline: "middle",
          translation: [
            titleX,
            titleY
          ]
        });
      }
      draw(chartArea) {
        if (!this._isVisible()) {
          return;
        }
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawBorder();
        this.drawTitle();
        this.drawLabels(chartArea);
      }
      _layers() {
        const opts = this.options;
        const tz = opts.ticks && opts.ticks.z || 0;
        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
        const bz = valueOrDefault(opts.border && opts.border.z, 0);
        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
          return [
            {
              z: tz,
              draw: (chartArea) => {
                this.draw(chartArea);
              }
            }
          ];
        }
        return [
          {
            z: gz,
            draw: (chartArea) => {
              this.drawBackground();
              this.drawGrid(chartArea);
              this.drawTitle();
            }
          },
          {
            z: bz,
            draw: () => {
              this.drawBorder();
            }
          },
          {
            z: tz,
            draw: (chartArea) => {
              this.drawLabels(chartArea);
            }
          }
        ];
      }
      getMatchingVisibleMetas(type) {
        const metas = this.chart.getSortedVisibleDatasetMetas();
        const axisID = this.axis + "AxisID";
        const result = [];
        let i, ilen;
        for (i = 0, ilen = metas.length; i < ilen; ++i) {
          const meta = metas[i];
          if (meta[axisID] === this.id && (!type || meta.type === type)) {
            result.push(meta);
          }
        }
        return result;
      }
      _resolveTickFontOptions(index2) {
        const opts = this.options.ticks.setContext(this.getContext(index2));
        return toFont(opts.font);
      }
      _maxDigits() {
        const fontSize = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / fontSize;
      }
    }
    class TypedRegistry {
      constructor(type, scope, override) {
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = /* @__PURE__ */ Object.create(null);
      }
      isForType(type) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
      }
      register(item) {
        const proto2 = Object.getPrototypeOf(item);
        let parentScope;
        if (isIChartComponent(proto2)) {
          parentScope = this.register(proto2);
        }
        const items = this.items;
        const id = item.id;
        const scope = this.scope + "." + id;
        if (!id) {
          throw new Error("class does not have id: " + item);
        }
        if (id in items) {
          return scope;
        }
        items[id] = item;
        registerDefaults(item, scope, parentScope);
        if (this.override) {
          defaults$2.override(item.id, item.overrides);
        }
        return scope;
      }
      get(id) {
        return this.items[id];
      }
      unregister(item) {
        const items = this.items;
        const id = item.id;
        const scope = this.scope;
        if (id in items) {
          delete items[id];
        }
        if (scope && id in defaults$2[scope]) {
          delete defaults$2[scope][id];
          if (this.override) {
            delete overrides[id];
          }
        }
      }
    }
    function registerDefaults(item, scope, parentScope) {
      const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
        parentScope ? defaults$2.get(parentScope) : {},
        defaults$2.get(scope),
        item.defaults
      ]);
      defaults$2.set(scope, itemDefaults);
      if (item.defaultRoutes) {
        routeDefaults(scope, item.defaultRoutes);
      }
      if (item.descriptors) {
        defaults$2.describe(scope, item.descriptors);
      }
    }
    function routeDefaults(scope, routes) {
      Object.keys(routes).forEach((property) => {
        const propertyParts = property.split(".");
        const sourceName = propertyParts.pop();
        const sourceScope = [
          scope
        ].concat(propertyParts).join(".");
        const parts = routes[property].split(".");
        const targetName = parts.pop();
        const targetScope = parts.join(".");
        defaults$2.route(sourceScope, sourceName, targetScope, targetName);
      });
    }
    function isIChartComponent(proto2) {
      return "id" in proto2 && "defaults" in proto2;
    }
    class Registry {
      constructor() {
        this.controllers = new TypedRegistry(DatasetController, "datasets", true);
        this.elements = new TypedRegistry(Element$1, "elements");
        this.plugins = new TypedRegistry(Object, "plugins");
        this.scales = new TypedRegistry(Scale, "scales");
        this._typedRegistries = [
          this.controllers,
          this.scales,
          this.elements
        ];
      }
      add(...args) {
        this._each("register", args);
      }
      remove(...args) {
        this._each("unregister", args);
      }
      addControllers(...args) {
        this._each("register", args, this.controllers);
      }
      addElements(...args) {
        this._each("register", args, this.elements);
      }
      addPlugins(...args) {
        this._each("register", args, this.plugins);
      }
      addScales(...args) {
        this._each("register", args, this.scales);
      }
      getController(id) {
        return this._get(id, this.controllers, "controller");
      }
      getElement(id) {
        return this._get(id, this.elements, "element");
      }
      getPlugin(id) {
        return this._get(id, this.plugins, "plugin");
      }
      getScale(id) {
        return this._get(id, this.scales, "scale");
      }
      removeControllers(...args) {
        this._each("unregister", args, this.controllers);
      }
      removeElements(...args) {
        this._each("unregister", args, this.elements);
      }
      removePlugins(...args) {
        this._each("unregister", args, this.plugins);
      }
      removeScales(...args) {
        this._each("unregister", args, this.scales);
      }
      _each(method, args, typedRegistry) {
        [
          ...args
        ].forEach((arg) => {
          const reg = typedRegistry || this._getRegistryForType(arg);
          if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
            this._exec(method, reg, arg);
          } else {
            each(arg, (item) => {
              const itemReg = typedRegistry || this._getRegistryForType(item);
              this._exec(method, itemReg, item);
            });
          }
        });
      }
      _exec(method, registry2, component) {
        const camelMethod = _capitalize(method);
        callback(component["before" + camelMethod], [], component);
        registry2[method](component);
        callback(component["after" + camelMethod], [], component);
      }
      _getRegistryForType(type) {
        for (let i = 0; i < this._typedRegistries.length; i++) {
          const reg = this._typedRegistries[i];
          if (reg.isForType(type)) {
            return reg;
          }
        }
        return this.plugins;
      }
      _get(id, typedRegistry, type) {
        const item = typedRegistry.get(id);
        if (item === void 0) {
          throw new Error('"' + id + '" is not a registered ' + type + ".");
        }
        return item;
      }
    }
    var registry = /* @__PURE__ */ new Registry();
    class PluginService {
      constructor() {
        this._init = [];
      }
      notify(chart, hook, args, filter) {
        if (hook === "beforeInit") {
          this._init = this._createDescriptors(chart, true);
          this._notify(this._init, chart, "install");
        }
        const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
        const result = this._notify(descriptors2, chart, hook, args);
        if (hook === "afterDestroy") {
          this._notify(descriptors2, chart, "stop");
          this._notify(this._init, chart, "uninstall");
        }
        return result;
      }
      _notify(descriptors2, chart, hook, args) {
        args = args || {};
        for (const descriptor of descriptors2) {
          const plugin2 = descriptor.plugin;
          const method = plugin2[hook];
          const params = [
            chart,
            args,
            descriptor.options
          ];
          if (callback(method, params, plugin2) === false && args.cancelable) {
            return false;
          }
        }
        return true;
      }
      invalidate() {
        if (!isNullOrUndef(this._cache)) {
          this._oldCache = this._cache;
          this._cache = void 0;
        }
      }
      _descriptors(chart) {
        if (this._cache) {
          return this._cache;
        }
        const descriptors2 = this._cache = this._createDescriptors(chart);
        this._notifyStateChanges(chart);
        return descriptors2;
      }
      _createDescriptors(chart, all) {
        const config = chart && chart.config;
        const options = valueOrDefault(config.options && config.options.plugins, {});
        const plugins = allPlugins(config);
        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
      }
      _notifyStateChanges(chart) {
        const previousDescriptors = this._oldCache || [];
        const descriptors2 = this._cache;
        const diff2 = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
        this._notify(diff2(previousDescriptors, descriptors2), chart, "stop");
        this._notify(diff2(descriptors2, previousDescriptors), chart, "start");
      }
    }
    function allPlugins(config) {
      const localIds = {};
      const plugins = [];
      const keys2 = Object.keys(registry.plugins.items);
      for (let i = 0; i < keys2.length; i++) {
        plugins.push(registry.getPlugin(keys2[i]));
      }
      const local = config.plugins || [];
      for (let i = 0; i < local.length; i++) {
        const plugin2 = local[i];
        if (plugins.indexOf(plugin2) === -1) {
          plugins.push(plugin2);
          localIds[plugin2.id] = true;
        }
      }
      return {
        plugins,
        localIds
      };
    }
    function getOpts(options, all) {
      if (!all && options === false) {
        return null;
      }
      if (options === true) {
        return {};
      }
      return options;
    }
    function createDescriptors(chart, { plugins, localIds }, options, all) {
      const result = [];
      const context = chart.getContext();
      for (const plugin2 of plugins) {
        const id = plugin2.id;
        const opts = getOpts(options[id], all);
        if (opts === null) {
          continue;
        }
        result.push({
          plugin: plugin2,
          options: pluginOpts(chart.config, {
            plugin: plugin2,
            local: localIds[id]
          }, opts, context)
        });
      }
      return result;
    }
    function pluginOpts(config, { plugin: plugin2, local }, opts, context) {
      const keys2 = config.pluginScopeKeys(plugin2);
      const scopes = config.getOptionScopes(opts, keys2);
      if (local && plugin2.defaults) {
        scopes.push(plugin2.defaults);
      }
      return config.createResolver(scopes, context, [
        ""
      ], {
        scriptable: false,
        indexable: false,
        allKeys: true
      });
    }
    function getIndexAxis(type, options) {
      const datasetDefaults = defaults$2.datasets[type] || {};
      const datasetOptions = (options.datasets || {})[type] || {};
      return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
    }
    function getAxisFromDefaultScaleID(id, indexAxis) {
      let axis = id;
      if (id === "_index_") {
        axis = indexAxis;
      } else if (id === "_value_") {
        axis = indexAxis === "x" ? "y" : "x";
      }
      return axis;
    }
    function getDefaultScaleIDFromAxis(axis, indexAxis) {
      return axis === indexAxis ? "_index_" : "_value_";
    }
    function idMatchesAxis(id) {
      if (id === "x" || id === "y" || id === "r") {
        return id;
      }
    }
    function axisFromPosition(position) {
      if (position === "top" || position === "bottom") {
        return "x";
      }
      if (position === "left" || position === "right") {
        return "y";
      }
    }
    function determineAxis(id, ...scaleOptions) {
      if (idMatchesAxis(id)) {
        return id;
      }
      for (const opts of scaleOptions) {
        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
        if (axis) {
          return axis;
        }
      }
      throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
    }
    function getAxisFromDataset(id, axis, dataset) {
      if (dataset[axis + "AxisID"] === id) {
        return {
          axis
        };
      }
    }
    function retrieveAxisFromDatasets(id, config) {
      if (config.data && config.data.datasets) {
        const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
        if (boundDs.length) {
          return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
        }
      }
      return {};
    }
    function mergeScaleConfig(config, options) {
      const chartDefaults = overrides[config.type] || {
        scales: {}
      };
      const configScales = options.scales || {};
      const chartIndexAxis = getIndexAxis(config.type, options);
      const scales = /* @__PURE__ */ Object.create(null);
      Object.keys(configScales).forEach((id) => {
        const scaleConf = configScales[id];
        if (!isObject$1(scaleConf)) {
          return console.error(`Invalid scale configuration for scale: ${id}`);
        }
        if (scaleConf._proxy) {
          return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
        }
        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults$2.scales[scaleConf.type]);
        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        const defaultScaleOptions = chartDefaults.scales || {};
        scales[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
          {
            axis
          },
          scaleConf,
          defaultScaleOptions[axis],
          defaultScaleOptions[defaultId]
        ]);
      });
      config.data.datasets.forEach((dataset) => {
        const type = dataset.type || config.type;
        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        const datasetDefaults = overrides[type] || {};
        const defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach((defaultID) => {
          const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
          const id = dataset[axis + "AxisID"] || axis;
          scales[id] = scales[id] || /* @__PURE__ */ Object.create(null);
          mergeIf(scales[id], [
            {
              axis
            },
            configScales[id],
            defaultScaleOptions[defaultID]
          ]);
        });
      });
      Object.keys(scales).forEach((key) => {
        const scale = scales[key];
        mergeIf(scale, [
          defaults$2.scales[scale.type],
          defaults$2.scale
        ]);
      });
      return scales;
    }
    function initOptions(config) {
      const options = config.options || (config.options = {});
      options.plugins = valueOrDefault(options.plugins, {});
      options.scales = mergeScaleConfig(config, options);
    }
    function initData(data) {
      data = data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      return data;
    }
    function initConfig(config) {
      config = config || {};
      config.data = initData(config.data);
      initOptions(config);
      return config;
    }
    const keyCache = /* @__PURE__ */ new Map();
    const keysCached = /* @__PURE__ */ new Set();
    function cachedKeys(cacheKey, generate) {
      let keys2 = keyCache.get(cacheKey);
      if (!keys2) {
        keys2 = generate();
        keyCache.set(cacheKey, keys2);
        keysCached.add(keys2);
      }
      return keys2;
    }
    const addIfFound = (set2, obj, key) => {
      const opts = resolveObjectKey(obj, key);
      if (opts !== void 0) {
        set2.add(opts);
      }
    };
    class Config {
      constructor(config) {
        this._config = initConfig(config);
        this._scopeCache = /* @__PURE__ */ new Map();
        this._resolverCache = /* @__PURE__ */ new Map();
      }
      get platform() {
        return this._config.platform;
      }
      get type() {
        return this._config.type;
      }
      set type(type) {
        this._config.type = type;
      }
      get data() {
        return this._config.data;
      }
      set data(data) {
        this._config.data = initData(data);
      }
      get options() {
        return this._config.options;
      }
      set options(options) {
        this._config.options = options;
      }
      get plugins() {
        return this._config.plugins;
      }
      update() {
        const config = this._config;
        this.clearCache();
        initOptions(config);
      }
      clearCache() {
        this._scopeCache.clear();
        this._resolverCache.clear();
      }
      datasetScopeKeys(datasetType) {
        return cachedKeys(datasetType, () => [
          [
            `datasets.${datasetType}`,
            ""
          ]
        ]);
      }
      datasetAnimationScopeKeys(datasetType, transition) {
        return cachedKeys(`${datasetType}.transition.${transition}`, () => [
          [
            `datasets.${datasetType}.transitions.${transition}`,
            `transitions.${transition}`
          ],
          [
            `datasets.${datasetType}`,
            ""
          ]
        ]);
      }
      datasetElementScopeKeys(datasetType, elementType) {
        return cachedKeys(`${datasetType}-${elementType}`, () => [
          [
            `datasets.${datasetType}.elements.${elementType}`,
            `datasets.${datasetType}`,
            `elements.${elementType}`,
            ""
          ]
        ]);
      }
      pluginScopeKeys(plugin2) {
        const id = plugin2.id;
        const type = this.type;
        return cachedKeys(`${type}-plugin-${id}`, () => [
          [
            `plugins.${id}`,
            ...plugin2.additionalOptionScopes || []
          ]
        ]);
      }
      _cachedScopes(mainScope, resetCache) {
        const _scopeCache = this._scopeCache;
        let cache = _scopeCache.get(mainScope);
        if (!cache || resetCache) {
          cache = /* @__PURE__ */ new Map();
          _scopeCache.set(mainScope, cache);
        }
        return cache;
      }
      getOptionScopes(mainScope, keyLists, resetCache) {
        const { options, type } = this;
        const cache = this._cachedScopes(mainScope, resetCache);
        const cached = cache.get(keyLists);
        if (cached) {
          return cached;
        }
        const scopes = /* @__PURE__ */ new Set();
        keyLists.forEach((keys2) => {
          if (mainScope) {
            scopes.add(mainScope);
            keys2.forEach((key) => addIfFound(scopes, mainScope, key));
          }
          keys2.forEach((key) => addIfFound(scopes, options, key));
          keys2.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
          keys2.forEach((key) => addIfFound(scopes, defaults$2, key));
          keys2.forEach((key) => addIfFound(scopes, descriptors, key));
        });
        const array = Array.from(scopes);
        if (array.length === 0) {
          array.push(/* @__PURE__ */ Object.create(null));
        }
        if (keysCached.has(keyLists)) {
          cache.set(keyLists, array);
        }
        return array;
      }
      chartOptionScopes() {
        const { options, type } = this;
        return [
          options,
          overrides[type] || {},
          defaults$2.datasets[type] || {},
          {
            type
          },
          defaults$2,
          descriptors
        ];
      }
      resolveNamedOptions(scopes, names2, context, prefixes = [
        ""
      ]) {
        const result = {
          $shared: true
        };
        const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
        let options = resolver;
        if (needContext(resolver, names2)) {
          result.$shared = false;
          context = isFunction$1(context) ? context() : context;
          const subResolver = this.createResolver(scopes, context, subPrefixes);
          options = _attachContext(resolver, context, subResolver);
        }
        for (const prop of names2) {
          result[prop] = options[prop];
        }
        return result;
      }
      createResolver(scopes, context, prefixes = [
        ""
      ], descriptorDefaults) {
        const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
        return isObject$1(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
      }
    }
    function getResolver(resolverCache, scopes, prefixes) {
      let cache = resolverCache.get(scopes);
      if (!cache) {
        cache = /* @__PURE__ */ new Map();
        resolverCache.set(scopes, cache);
      }
      const cacheKey = prefixes.join();
      let cached = cache.get(cacheKey);
      if (!cached) {
        const resolver = _createResolver(scopes, prefixes);
        cached = {
          resolver,
          subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
        };
        cache.set(cacheKey, cached);
      }
      return cached;
    }
    const hasFunction = (value) => isObject$1(value) && Object.getOwnPropertyNames(value).some((key) => isFunction$1(value[key]));
    function needContext(proxy, names2) {
      const { isScriptable, isIndexable } = _descriptors(proxy);
      for (const prop of names2) {
        const scriptable = isScriptable(prop);
        const indexable = isIndexable(prop);
        const value = (indexable || scriptable) && proxy[prop];
        if (scriptable && (isFunction$1(value) || hasFunction(value)) || indexable && isArray$1(value)) {
          return true;
        }
      }
      return false;
    }
    var version = "4.4.7";
    const KNOWN_POSITIONS = [
      "top",
      "bottom",
      "left",
      "right",
      "chartArea"
    ];
    function positionIsHorizontal(position, axis) {
      return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
    }
    function compare2Level(l1, l2) {
      return function(a, b) {
        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
      };
    }
    function onAnimationsComplete(context) {
      const chart = context.chart;
      const animationOptions = chart.options.animation;
      chart.notifyPlugins("afterRender");
      callback(animationOptions && animationOptions.onComplete, [
        context
      ], chart);
    }
    function onAnimationProgress(context) {
      const chart = context.chart;
      const animationOptions = chart.options.animation;
      callback(animationOptions && animationOptions.onProgress, [
        context
      ], chart);
    }
    function getCanvas(item) {
      if (_isDomSupported() && typeof item === "string") {
        item = document.getElementById(item);
      } else if (item && item.length) {
        item = item[0];
      }
      if (item && item.canvas) {
        item = item.canvas;
      }
      return item;
    }
    const instances = {};
    const getChart = (key) => {
      const canvas = getCanvas(key);
      return Object.values(instances).filter((c) => c.canvas === canvas).pop();
    };
    function moveNumericKeys(obj, start2, move) {
      const keys2 = Object.keys(obj);
      for (const key of keys2) {
        const intKey = +key;
        if (intKey >= start2) {
          const value = obj[key];
          delete obj[key];
          if (move > 0 || intKey > start2) {
            obj[intKey + move] = value;
          }
        }
      }
    }
    function determineLastEvent(e, lastEvent, inChartArea, isClick) {
      if (!inChartArea || e.type === "mouseout") {
        return null;
      }
      if (isClick) {
        return lastEvent;
      }
      return e;
    }
    function getSizeForArea(scale, chartArea, field) {
      return scale.options.clip ? scale[field] : chartArea[field];
    }
    function getDatasetArea(meta, chartArea) {
      const { xScale, yScale } = meta;
      if (xScale && yScale) {
        return {
          left: getSizeForArea(xScale, chartArea, "left"),
          right: getSizeForArea(xScale, chartArea, "right"),
          top: getSizeForArea(yScale, chartArea, "top"),
          bottom: getSizeForArea(yScale, chartArea, "bottom")
        };
      }
      return chartArea;
    }
    class Chart {
      static register(...items) {
        registry.add(...items);
        invalidatePlugins();
      }
      static unregister(...items) {
        registry.remove(...items);
        invalidatePlugins();
      }
      constructor(item, userConfig) {
        const config = this.config = new Config(userConfig);
        const initialCanvas = getCanvas(item);
        const existingChart = getChart(initialCanvas);
        if (existingChart) {
          throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
        }
        const options = config.createResolver(config.chartOptionScopes(), this.getContext());
        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config);
        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        const canvas = context && context.canvas;
        const height = canvas && canvas.height;
        const width = canvas && canvas.width;
        this.id = uid();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = void 0;
        this.boxes = [];
        this.currentDevicePixelRatio = void 0;
        this.chartArea = void 0;
        this._active = [];
        this._lastEvent = void 0;
        this._listeners = {};
        this._responsiveListeners = void 0;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = void 0;
        this.$context = void 0;
        this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
        this._dataChanges = [];
        instances[this.id] = this;
        if (!context || !canvas) {
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }
        animator.listen(this, "complete", onAnimationsComplete);
        animator.listen(this, "progress", onAnimationProgress);
        this._initialize();
        if (this.attached) {
          this.update();
        }
      }
      get aspectRatio() {
        const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
        if (!isNullOrUndef(aspectRatio)) {
          return aspectRatio;
        }
        if (maintainAspectRatio && _aspectRatio) {
          return _aspectRatio;
        }
        return height ? width / height : null;
      }
      get data() {
        return this.config.data;
      }
      set data(data) {
        this.config.data = data;
      }
      get options() {
        return this._options;
      }
      set options(options) {
        this.config.options = options;
      }
      get registry() {
        return registry;
      }
      _initialize() {
        this.notifyPlugins("beforeInit");
        if (this.options.responsive) {
          this.resize();
        } else {
          retinaScale(this, this.options.devicePixelRatio);
        }
        this.bindEvents();
        this.notifyPlugins("afterInit");
        return this;
      }
      clear() {
        clearCanvas(this.canvas, this.ctx);
        return this;
      }
      stop() {
        animator.stop(this);
        return this;
      }
      resize(width, height) {
        if (!animator.running(this)) {
          this._resize(width, height);
        } else {
          this._resizeBeforeDraw = {
            width,
            height
          };
        }
      }
      _resize(width, height) {
        const options = this.options;
        const canvas = this.canvas;
        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
        const mode = this.width ? "resize" : "attach";
        this.width = newSize.width;
        this.height = newSize.height;
        this._aspectRatio = this.aspectRatio;
        if (!retinaScale(this, newRatio, true)) {
          return;
        }
        this.notifyPlugins("resize", {
          size: newSize
        });
        callback(options.onResize, [
          this,
          newSize
        ], this);
        if (this.attached) {
          if (this._doResize(mode)) {
            this.render();
          }
        }
      }
      ensureScalesHaveIDs() {
        const options = this.options;
        const scalesOptions = options.scales || {};
        each(scalesOptions, (axisOptions, axisID) => {
          axisOptions.id = axisID;
        });
      }
      buildOrUpdateScales() {
        const options = this.options;
        const scaleOpts = options.scales;
        const scales = this.scales;
        const updated = Object.keys(scales).reduce((obj, id) => {
          obj[id] = false;
          return obj;
        }, {});
        let items = [];
        if (scaleOpts) {
          items = items.concat(Object.keys(scaleOpts).map((id) => {
            const scaleOptions = scaleOpts[id];
            const axis = determineAxis(id, scaleOptions);
            const isRadial = axis === "r";
            const isHorizontal = axis === "x";
            return {
              options: scaleOptions,
              dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
              dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
            };
          }));
        }
        each(items, (item) => {
          const scaleOptions = item.options;
          const id = scaleOptions.id;
          const axis = determineAxis(id, scaleOptions);
          const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
          if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }
          updated[id] = true;
          let scale = null;
          if (id in scales && scales[id].type === scaleType) {
            scale = scales[id];
          } else {
            const scaleClass = registry.getScale(scaleType);
            scale = new scaleClass({
              id,
              type: scaleType,
              ctx: this.ctx,
              chart: this
            });
            scales[scale.id] = scale;
          }
          scale.init(scaleOptions, options);
        });
        each(updated, (hasUpdated, id) => {
          if (!hasUpdated) {
            delete scales[id];
          }
        });
        each(scales, (scale) => {
          layouts.configure(this, scale, scale.options);
          layouts.addBox(this, scale);
        });
      }
      _updateMetasets() {
        const metasets = this._metasets;
        const numData = this.data.datasets.length;
        const numMeta = metasets.length;
        metasets.sort((a, b) => a.index - b.index);
        if (numMeta > numData) {
          for (let i = numData; i < numMeta; ++i) {
            this._destroyDatasetMeta(i);
          }
          metasets.splice(numData, numMeta - numData);
        }
        this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
      }
      _removeUnreferencedMetasets() {
        const { _metasets: metasets, data: { datasets } } = this;
        if (metasets.length > datasets.length) {
          delete this._stacks;
        }
        metasets.forEach((meta, index2) => {
          if (datasets.filter((x) => x === meta._dataset).length === 0) {
            this._destroyDatasetMeta(index2);
          }
        });
      }
      buildOrUpdateControllers() {
        const newControllers = [];
        const datasets = this.data.datasets;
        let i, ilen;
        this._removeUnreferencedMetasets();
        for (i = 0, ilen = datasets.length; i < ilen; i++) {
          const dataset = datasets[i];
          let meta = this.getDatasetMeta(i);
          const type = dataset.type || this.config.type;
          if (meta.type && meta.type !== type) {
            this._destroyDatasetMeta(i);
            meta = this.getDatasetMeta(i);
          }
          meta.type = type;
          meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
          meta.order = dataset.order || 0;
          meta.index = i;
          meta.label = "" + dataset.label;
          meta.visible = this.isDatasetVisible(i);
          if (meta.controller) {
            meta.controller.updateIndex(i);
            meta.controller.linkScales();
          } else {
            const ControllerClass = registry.getController(type);
            const { datasetElementType, dataElementType } = defaults$2.datasets[type];
            Object.assign(ControllerClass, {
              dataElementType: registry.getElement(dataElementType),
              datasetElementType: datasetElementType && registry.getElement(datasetElementType)
            });
            meta.controller = new ControllerClass(this, i);
            newControllers.push(meta.controller);
          }
        }
        this._updateMetasets();
        return newControllers;
      }
      _resetElements() {
        each(this.data.datasets, (dataset, datasetIndex) => {
          this.getDatasetMeta(datasetIndex).controller.reset();
        }, this);
      }
      reset() {
        this._resetElements();
        this.notifyPlugins("reset");
      }
      update(mode) {
        const config = this.config;
        config.update();
        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
        const animsDisabled = this._animationsDisabled = !options.animation;
        this._updateScales();
        this._checkEventBindings();
        this._updateHiddenIndices();
        this._plugins.invalidate();
        if (this.notifyPlugins("beforeUpdate", {
          mode,
          cancelable: true
        }) === false) {
          return;
        }
        const newControllers = this.buildOrUpdateControllers();
        this.notifyPlugins("beforeElementsUpdate");
        let minPadding = 0;
        for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
          const { controller } = this.getDatasetMeta(i);
          const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
          controller.buildOrUpdateElements(reset);
          minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
        }
        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
        this._updateLayout(minPadding);
        if (!animsDisabled) {
          each(newControllers, (controller) => {
            controller.reset();
          });
        }
        this._updateDatasets(mode);
        this.notifyPlugins("afterUpdate", {
          mode
        });
        this._layers.sort(compare2Level("z", "_idx"));
        const { _active, _lastEvent } = this;
        if (_lastEvent) {
          this._eventHandler(_lastEvent, true);
        } else if (_active.length) {
          this._updateHoverStyles(_active, _active, true);
        }
        this.render();
      }
      _updateScales() {
        each(this.scales, (scale) => {
          layouts.removeBox(this, scale);
        });
        this.ensureScalesHaveIDs();
        this.buildOrUpdateScales();
      }
      _checkEventBindings() {
        const options = this.options;
        const existingEvents = new Set(Object.keys(this._listeners));
        const newEvents = new Set(options.events);
        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
          this.unbindEvents();
          this.bindEvents();
        }
      }
      _updateHiddenIndices() {
        const { _hiddenIndices } = this;
        const changes = this._getUniformDataChanges() || [];
        for (const { method, start: start2, count } of changes) {
          const move = method === "_removeElements" ? -count : count;
          moveNumericKeys(_hiddenIndices, start2, move);
        }
      }
      _getUniformDataChanges() {
        const _dataChanges = this._dataChanges;
        if (!_dataChanges || !_dataChanges.length) {
          return;
        }
        this._dataChanges = [];
        const datasetCount = this.data.datasets.length;
        const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
        const changeSet = makeSet(0);
        for (let i = 1; i < datasetCount; i++) {
          if (!setsEqual(changeSet, makeSet(i))) {
            return;
          }
        }
        return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
          method: a[1],
          start: +a[2],
          count: +a[3]
        }));
      }
      _updateLayout(minPadding) {
        if (this.notifyPlugins("beforeLayout", {
          cancelable: true
        }) === false) {
          return;
        }
        layouts.update(this, this.width, this.height, minPadding);
        const area = this.chartArea;
        const noArea = area.width <= 0 || area.height <= 0;
        this._layers = [];
        each(this.boxes, (box) => {
          if (noArea && box.position === "chartArea") {
            return;
          }
          if (box.configure) {
            box.configure();
          }
          this._layers.push(...box._layers());
        }, this);
        this._layers.forEach((item, index2) => {
          item._idx = index2;
        });
        this.notifyPlugins("afterLayout");
      }
      _updateDatasets(mode) {
        if (this.notifyPlugins("beforeDatasetsUpdate", {
          mode,
          cancelable: true
        }) === false) {
          return;
        }
        for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          this.getDatasetMeta(i).controller.configure();
        }
        for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          this._updateDataset(i, isFunction$1(mode) ? mode({
            datasetIndex: i
          }) : mode);
        }
        this.notifyPlugins("afterDatasetsUpdate", {
          mode
        });
      }
      _updateDataset(index2, mode) {
        const meta = this.getDatasetMeta(index2);
        const args = {
          meta,
          index: index2,
          mode,
          cancelable: true
        };
        if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
          return;
        }
        meta.controller._update(mode);
        args.cancelable = false;
        this.notifyPlugins("afterDatasetUpdate", args);
      }
      render() {
        if (this.notifyPlugins("beforeRender", {
          cancelable: true
        }) === false) {
          return;
        }
        if (animator.has(this)) {
          if (this.attached && !animator.running(this)) {
            animator.start(this);
          }
        } else {
          this.draw();
          onAnimationsComplete({
            chart: this
          });
        }
      }
      draw() {
        let i;
        if (this._resizeBeforeDraw) {
          const { width, height } = this._resizeBeforeDraw;
          this._resizeBeforeDraw = null;
          this._resize(width, height);
        }
        this.clear();
        if (this.width <= 0 || this.height <= 0) {
          return;
        }
        if (this.notifyPlugins("beforeDraw", {
          cancelable: true
        }) === false) {
          return;
        }
        const layers = this._layers;
        for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
          layers[i].draw(this.chartArea);
        }
        this._drawDatasets();
        for (; i < layers.length; ++i) {
          layers[i].draw(this.chartArea);
        }
        this.notifyPlugins("afterDraw");
      }
      _getSortedDatasetMetas(filterVisible) {
        const metasets = this._sortedMetasets;
        const result = [];
        let i, ilen;
        for (i = 0, ilen = metasets.length; i < ilen; ++i) {
          const meta = metasets[i];
          if (!filterVisible || meta.visible) {
            result.push(meta);
          }
        }
        return result;
      }
      getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
      }
      _drawDatasets() {
        if (this.notifyPlugins("beforeDatasetsDraw", {
          cancelable: true
        }) === false) {
          return;
        }
        const metasets = this.getSortedVisibleDatasetMetas();
        for (let i = metasets.length - 1; i >= 0; --i) {
          this._drawDataset(metasets[i]);
        }
        this.notifyPlugins("afterDatasetsDraw");
      }
      _drawDataset(meta) {
        const ctx = this.ctx;
        const clip = meta._clip;
        const useClip = !clip.disabled;
        const area = getDatasetArea(meta, this.chartArea);
        const args = {
          meta,
          index: meta.index,
          cancelable: true
        };
        if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
          return;
        }
        if (useClip) {
          clipArea(ctx, {
            left: clip.left === false ? 0 : area.left - clip.left,
            right: clip.right === false ? this.width : area.right + clip.right,
            top: clip.top === false ? 0 : area.top - clip.top,
            bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
          });
        }
        meta.controller.draw();
        if (useClip) {
          unclipArea(ctx);
        }
        args.cancelable = false;
        this.notifyPlugins("afterDatasetDraw", args);
      }
      isPointInArea(point) {
        return _isPointInArea(point, this.chartArea, this._minPadding);
      }
      getElementsAtEventForMode(e, mode, options, useFinalPosition) {
        const method = Interaction.modes[mode];
        if (typeof method === "function") {
          return method(this, e, options, useFinalPosition);
        }
        return [];
      }
      getDatasetMeta(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        const metasets = this._metasets;
        let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
        if (!meta) {
          meta = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: dataset && dataset.order || 0,
            index: datasetIndex,
            _dataset: dataset,
            _parsed: [],
            _sorted: false
          };
          metasets.push(meta);
        }
        return meta;
      }
      getContext() {
        return this.$context || (this.$context = createContext(null, {
          chart: this,
          type: "chart"
        }));
      }
      getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
      }
      isDatasetVisible(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        if (!dataset) {
          return false;
        }
        const meta = this.getDatasetMeta(datasetIndex);
        return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
      }
      setDatasetVisibility(datasetIndex, visible) {
        const meta = this.getDatasetMeta(datasetIndex);
        meta.hidden = !visible;
      }
      toggleDataVisibility(index2) {
        this._hiddenIndices[index2] = !this._hiddenIndices[index2];
      }
      getDataVisibility(index2) {
        return !this._hiddenIndices[index2];
      }
      _updateVisibility(datasetIndex, dataIndex, visible) {
        const mode = visible ? "show" : "hide";
        const meta = this.getDatasetMeta(datasetIndex);
        const anims = meta.controller._resolveAnimations(void 0, mode);
        if (defined(dataIndex)) {
          meta.data[dataIndex].hidden = !visible;
          this.update();
        } else {
          this.setDatasetVisibility(datasetIndex, visible);
          anims.update(meta, {
            visible
          });
          this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
        }
      }
      hide(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, false);
      }
      show(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, true);
      }
      _destroyDatasetMeta(datasetIndex) {
        const meta = this._metasets[datasetIndex];
        if (meta && meta.controller) {
          meta.controller._destroy();
        }
        delete this._metasets[datasetIndex];
      }
      _stop() {
        let i, ilen;
        this.stop();
        animator.remove(this);
        for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          this._destroyDatasetMeta(i);
        }
      }
      destroy() {
        this.notifyPlugins("beforeDestroy");
        const { canvas, ctx } = this;
        this._stop();
        this.config.clearCache();
        if (canvas) {
          this.unbindEvents();
          clearCanvas(canvas, ctx);
          this.platform.releaseContext(ctx);
          this.canvas = null;
          this.ctx = null;
        }
        delete instances[this.id];
        this.notifyPlugins("afterDestroy");
      }
      toBase64Image(...args) {
        return this.canvas.toDataURL(...args);
      }
      bindEvents() {
        this.bindUserEvents();
        if (this.options.responsive) {
          this.bindResponsiveEvents();
        } else {
          this.attached = true;
        }
      }
      bindUserEvents() {
        const listeners = this._listeners;
        const platform = this.platform;
        const _add = (type, listener2) => {
          platform.addEventListener(this, type, listener2);
          listeners[type] = listener2;
        };
        const listener = (e, x, y) => {
          e.offsetX = x;
          e.offsetY = y;
          this._eventHandler(e);
        };
        each(this.options.events, (type) => _add(type, listener));
      }
      bindResponsiveEvents() {
        if (!this._responsiveListeners) {
          this._responsiveListeners = {};
        }
        const listeners = this._responsiveListeners;
        const platform = this.platform;
        const _add = (type, listener2) => {
          platform.addEventListener(this, type, listener2);
          listeners[type] = listener2;
        };
        const _remove = (type, listener2) => {
          if (listeners[type]) {
            platform.removeEventListener(this, type, listener2);
            delete listeners[type];
          }
        };
        const listener = (width, height) => {
          if (this.canvas) {
            this.resize(width, height);
          }
        };
        let detached;
        const attached = () => {
          _remove("attach", attached);
          this.attached = true;
          this.resize();
          _add("resize", listener);
          _add("detach", detached);
        };
        detached = () => {
          this.attached = false;
          _remove("resize", listener);
          this._stop();
          this._resize(0, 0);
          _add("attach", attached);
        };
        if (platform.isAttached(this.canvas)) {
          attached();
        } else {
          detached();
        }
      }
      unbindEvents() {
        each(this._listeners, (listener, type) => {
          this.platform.removeEventListener(this, type, listener);
        });
        this._listeners = {};
        each(this._responsiveListeners, (listener, type) => {
          this.platform.removeEventListener(this, type, listener);
        });
        this._responsiveListeners = void 0;
      }
      updateHoverStyle(items, mode, enabled) {
        const prefix = enabled ? "set" : "remove";
        let meta, item, i, ilen;
        if (mode === "dataset") {
          meta = this.getDatasetMeta(items[0].datasetIndex);
          meta.controller["_" + prefix + "DatasetHoverStyle"]();
        }
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          item = items[i];
          const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
          if (controller) {
            controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
          }
        }
      }
      getActiveElements() {
        return this._active || [];
      }
      setActiveElements(activeElements) {
        const lastActive = this._active || [];
        const active = activeElements.map(({ datasetIndex, index: index2 }) => {
          const meta = this.getDatasetMeta(datasetIndex);
          if (!meta) {
            throw new Error("No dataset found at index " + datasetIndex);
          }
          return {
            datasetIndex,
            element: meta.data[index2],
            index: index2
          };
        });
        const changed = !_elementsEqual(active, lastActive);
        if (changed) {
          this._active = active;
          this._lastEvent = null;
          this._updateHoverStyles(active, lastActive);
        }
      }
      notifyPlugins(hook, args, filter) {
        return this._plugins.notify(this, hook, args, filter);
      }
      isPluginEnabled(pluginId) {
        return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
      }
      _updateHoverStyles(active, lastActive, replay) {
        const hoverOptions = this.options.hover;
        const diff2 = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
        const deactivated = diff2(lastActive, active);
        const activated = replay ? active : diff2(active, lastActive);
        if (deactivated.length) {
          this.updateHoverStyle(deactivated, hoverOptions.mode, false);
        }
        if (activated.length && hoverOptions.mode) {
          this.updateHoverStyle(activated, hoverOptions.mode, true);
        }
      }
      _eventHandler(e, replay) {
        const args = {
          event: e,
          replay,
          cancelable: true,
          inChartArea: this.isPointInArea(e)
        };
        const eventFilter = (plugin2) => (plugin2.options.events || this.options.events).includes(e.native.type);
        if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
          return;
        }
        const changed = this._handleEvent(e, replay, args.inChartArea);
        args.cancelable = false;
        this.notifyPlugins("afterEvent", args, eventFilter);
        if (changed || args.changed) {
          this.render();
        }
        return this;
      }
      _handleEvent(e, replay, inChartArea) {
        const { _active: lastActive = [], options } = this;
        const useFinalPosition = replay;
        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
        const isClick = _isClickEvent(e);
        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
        if (inChartArea) {
          this._lastEvent = null;
          callback(options.onHover, [
            e,
            active,
            this
          ], this);
          if (isClick) {
            callback(options.onClick, [
              e,
              active,
              this
            ], this);
          }
        }
        const changed = !_elementsEqual(active, lastActive);
        if (changed || replay) {
          this._active = active;
          this._updateHoverStyles(active, lastActive, replay);
        }
        this._lastEvent = lastEvent;
        return changed;
      }
      _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
        if (e.type === "mouseout") {
          return [];
        }
        if (!inChartArea) {
          return lastActive;
        }
        const hoverOptions = this.options.hover;
        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
      }
    }
    __publicField(Chart, "defaults", defaults$2);
    __publicField(Chart, "instances", instances);
    __publicField(Chart, "overrides", overrides);
    __publicField(Chart, "registry", registry);
    __publicField(Chart, "version", version);
    __publicField(Chart, "getChart", getChart);
    function invalidatePlugins() {
      return each(Chart.instances, (chart) => chart._plugins.invalidate());
    }
    function setStyle(ctx, options, style = options) {
      ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
      ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
      ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
      ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
      ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
      ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
    }
    function lineTo(ctx, previous, target) {
      ctx.lineTo(target.x, target.y);
    }
    function getLineMethod(options) {
      if (options.stepped) {
        return _steppedLineTo;
      }
      if (options.tension || options.cubicInterpolationMode === "monotone") {
        return _bezierCurveTo;
      }
      return lineTo;
    }
    function pathVars(points, segment, params = {}) {
      const count = points.length;
      const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
      const { start: segmentStart, end: segmentEnd } = segment;
      const start2 = Math.max(paramsStart, segmentStart);
      const end2 = Math.min(paramsEnd, segmentEnd);
      const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
      return {
        count,
        start: start2,
        loop: segment.loop,
        ilen: end2 < start2 && !outside ? count + end2 - start2 : end2 - start2
      };
    }
    function pathSegment(ctx, line, segment, params) {
      const { points, options } = line;
      const { count, start: start2, loop, ilen } = pathVars(points, segment, params);
      const lineMethod = getLineMethod(options);
      let { move = true, reverse } = params || {};
      let i, point, prev;
      for (i = 0; i <= ilen; ++i) {
        point = points[(start2 + (reverse ? ilen - i : i)) % count];
        if (point.skip) {
          continue;
        } else if (move) {
          ctx.moveTo(point.x, point.y);
          move = false;
        } else {
          lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        prev = point;
      }
      if (loop) {
        point = points[(start2 + (reverse ? ilen : 0)) % count];
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      return !!loop;
    }
    function fastPathSegment(ctx, line, segment, params) {
      const points = line.points;
      const { count, start: start2, ilen } = pathVars(points, segment, params);
      const { move = true, reverse } = params || {};
      let avgX = 0;
      let countX = 0;
      let i, point, prevX, minY, maxY, lastY;
      const pointIndex = (index2) => (start2 + (reverse ? ilen - index2 : index2)) % count;
      const drawX = () => {
        if (minY !== maxY) {
          ctx.lineTo(avgX, maxY);
          ctx.lineTo(avgX, minY);
          ctx.lineTo(avgX, lastY);
        }
      };
      if (move) {
        point = points[pointIndex(0)];
        ctx.moveTo(point.x, point.y);
      }
      for (i = 0; i <= ilen; ++i) {
        point = points[pointIndex(i)];
        if (point.skip) {
          continue;
        }
        const x = point.x;
        const y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
          if (y < minY) {
            minY = y;
          } else if (y > maxY) {
            maxY = y;
          }
          avgX = (countX * avgX + x) / ++countX;
        } else {
          drawX();
          ctx.lineTo(x, y);
          prevX = truncX;
          countX = 0;
          minY = maxY = y;
        }
        lastY = y;
      }
      drawX();
    }
    function _getSegmentMethod(line) {
      const opts = line.options;
      const borderDash = opts.borderDash && opts.borderDash.length;
      const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
      return useFastPath ? fastPathSegment : pathSegment;
    }
    function _getInterpolationMethod(options) {
      if (options.stepped) {
        return _steppedInterpolation;
      }
      if (options.tension || options.cubicInterpolationMode === "monotone") {
        return _bezierInterpolation;
      }
      return _pointInLine;
    }
    function strokePathWithCache(ctx, line, start2, count) {
      let path = line._path;
      if (!path) {
        path = line._path = new Path2D();
        if (line.path(path, start2, count)) {
          path.closePath();
        }
      }
      setStyle(ctx, line.options);
      ctx.stroke(path);
    }
    function strokePathDirect(ctx, line, start2, count) {
      const { segments, options } = line;
      const segmentMethod = _getSegmentMethod(line);
      for (const segment of segments) {
        setStyle(ctx, options, segment.style);
        ctx.beginPath();
        if (segmentMethod(ctx, line, segment, {
          start: start2,
          end: start2 + count - 1
        })) {
          ctx.closePath();
        }
        ctx.stroke();
      }
    }
    const usePath2D = typeof Path2D === "function";
    function draw(ctx, line, start2, count) {
      if (usePath2D && !line.options.segment) {
        strokePathWithCache(ctx, line, start2, count);
      } else {
        strokePathDirect(ctx, line, start2, count);
      }
    }
    class LineElement extends Element$1 {
      constructor(cfg) {
        super();
        this.animated = true;
        this.options = void 0;
        this._chart = void 0;
        this._loop = void 0;
        this._fullLoop = void 0;
        this._path = void 0;
        this._points = void 0;
        this._segments = void 0;
        this._decimated = false;
        this._pointsUpdated = false;
        this._datasetIndex = void 0;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      updateControlPoints(chartArea, indexAxis) {
        const options = this.options;
        if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
          const loop = options.spanGaps ? this._loop : this._fullLoop;
          _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
          this._pointsUpdated = true;
        }
      }
      set points(points) {
        this._points = points;
        delete this._segments;
        delete this._path;
        this._pointsUpdated = false;
      }
      get points() {
        return this._points;
      }
      get segments() {
        return this._segments || (this._segments = _computeSegments(this, this.options.segment));
      }
      first() {
        const segments = this.segments;
        const points = this.points;
        return segments.length && points[segments[0].start];
      }
      last() {
        const segments = this.segments;
        const points = this.points;
        const count = segments.length;
        return count && points[segments[count - 1].end];
      }
      interpolate(point, property) {
        const options = this.options;
        const value = point[property];
        const points = this.points;
        const segments = _boundSegments(this, {
          property,
          start: value,
          end: value
        });
        if (!segments.length) {
          return;
        }
        const result = [];
        const _interpolate = _getInterpolationMethod(options);
        let i, ilen;
        for (i = 0, ilen = segments.length; i < ilen; ++i) {
          const { start: start2, end: end2 } = segments[i];
          const p1 = points[start2];
          const p2 = points[end2];
          if (p1 === p2) {
            result.push(p1);
            continue;
          }
          const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
          const interpolated = _interpolate(p1, p2, t, options.stepped);
          interpolated[property] = point[property];
          result.push(interpolated);
        }
        return result.length === 1 ? result[0] : result;
      }
      pathSegment(ctx, segment, params) {
        const segmentMethod = _getSegmentMethod(this);
        return segmentMethod(ctx, this, segment, params);
      }
      path(ctx, start2, count) {
        const segments = this.segments;
        const segmentMethod = _getSegmentMethod(this);
        let loop = this._loop;
        start2 = start2 || 0;
        count = count || this.points.length - start2;
        for (const segment of segments) {
          loop &= segmentMethod(ctx, this, segment, {
            start: start2,
            end: start2 + count - 1
          });
        }
        return !!loop;
      }
      draw(ctx, chartArea, start2, count) {
        const options = this.options || {};
        const points = this.points || [];
        if (points.length && options.borderWidth) {
          ctx.save();
          draw(ctx, this, start2, count);
          ctx.restore();
        }
        if (this.animated) {
          this._pointsUpdated = false;
          this._path = void 0;
        }
      }
    }
    __publicField(LineElement, "id", "line");
    __publicField(LineElement, "defaults", {
      borderCapStyle: "butt",
      borderDash: [],
      borderDashOffset: 0,
      borderJoinStyle: "miter",
      borderWidth: 3,
      capBezierPoints: true,
      cubicInterpolationMode: "default",
      fill: false,
      spanGaps: false,
      stepped: false,
      tension: 0
    });
    __publicField(LineElement, "defaultRoutes", {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    });
    __publicField(LineElement, "descriptors", {
      _scriptable: true,
      _indexable: (name) => name !== "borderDash" && name !== "fill"
    });
    function inRange$1(el, pos, axis, useFinalPosition) {
      const options = el.options;
      const { [axis]: value } = el.getProps([
        axis
      ], useFinalPosition);
      return Math.abs(pos - value) < options.radius + options.hitRadius;
    }
    class PointElement extends Element$1 {
      constructor(cfg) {
        super();
        __publicField(this, "parsed");
        __publicField(this, "skip");
        __publicField(this, "stop");
        this.options = void 0;
        this.parsed = void 0;
        this.skip = void 0;
        this.stop = void 0;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      inRange(mouseX, mouseY, useFinalPosition) {
        const options = this.options;
        const { x, y } = this.getProps([
          "x",
          "y"
        ], useFinalPosition);
        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
      }
      inXRange(mouseX, useFinalPosition) {
        return inRange$1(this, mouseX, "x", useFinalPosition);
      }
      inYRange(mouseY, useFinalPosition) {
        return inRange$1(this, mouseY, "y", useFinalPosition);
      }
      getCenterPoint(useFinalPosition) {
        const { x, y } = this.getProps([
          "x",
          "y"
        ], useFinalPosition);
        return {
          x,
          y
        };
      }
      size(options) {
        options = options || this.options || {};
        let radius = options.radius || 0;
        radius = Math.max(radius, radius && options.hoverRadius || 0);
        const borderWidth = radius && options.borderWidth || 0;
        return (radius + borderWidth) * 2;
      }
      draw(ctx, area) {
        const options = this.options;
        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
          return;
        }
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.fillStyle = options.backgroundColor;
        drawPoint(ctx, options, this.x, this.y);
      }
      getRange() {
        const options = this.options || {};
        return options.radius + options.hitRadius;
      }
    }
    __publicField(PointElement, "id", "point");
    /**
    * @type {any}
    */
    __publicField(PointElement, "defaults", {
      borderWidth: 1,
      hitRadius: 1,
      hoverBorderWidth: 1,
      hoverRadius: 4,
      pointStyle: "circle",
      radius: 3,
      rotation: 0
    });
    /**
    * @type {any}
    */
    __publicField(PointElement, "defaultRoutes", {
      backgroundColor: "backgroundColor",
      borderColor: "borderColor"
    });
    function _segments(line, target, property) {
      const segments = line.segments;
      const points = line.points;
      const tpoints = target.points;
      const parts = [];
      for (const segment of segments) {
        let { start: start2, end: end2 } = segment;
        end2 = _findSegmentEnd(start2, end2, points);
        const bounds = _getBounds(property, points[start2], points[end2], segment.loop);
        if (!target.segments) {
          parts.push({
            source: segment,
            target: bounds,
            start: points[start2],
            end: points[end2]
          });
          continue;
        }
        const targetSegments = _boundSegments(target, bounds);
        for (const tgt of targetSegments) {
          const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
          const fillSources = _boundSegment(segment, points, subBounds);
          for (const fillSource of fillSources) {
            parts.push({
              source: fillSource,
              target: tgt,
              start: {
                [property]: _getEdge(bounds, subBounds, "start", Math.max)
              },
              end: {
                [property]: _getEdge(bounds, subBounds, "end", Math.min)
              }
            });
          }
        }
      }
      return parts;
    }
    function _getBounds(property, first, last, loop) {
      if (loop) {
        return;
      }
      let start2 = first[property];
      let end2 = last[property];
      if (property === "angle") {
        start2 = _normalizeAngle(start2);
        end2 = _normalizeAngle(end2);
      }
      return {
        property,
        start: start2,
        end: end2
      };
    }
    function _pointsFromSegments(boundary, line) {
      const { x = null, y = null } = boundary || {};
      const linePoints = line.points;
      const points = [];
      line.segments.forEach(({ start: start2, end: end2 }) => {
        end2 = _findSegmentEnd(start2, end2, linePoints);
        const first = linePoints[start2];
        const last = linePoints[end2];
        if (y !== null) {
          points.push({
            x: first.x,
            y
          });
          points.push({
            x: last.x,
            y
          });
        } else if (x !== null) {
          points.push({
            x,
            y: first.y
          });
          points.push({
            x,
            y: last.y
          });
        }
      });
      return points;
    }
    function _findSegmentEnd(start2, end2, points) {
      for (; end2 > start2; end2--) {
        const point = points[end2];
        if (!isNaN(point.x) && !isNaN(point.y)) {
          break;
        }
      }
      return end2;
    }
    function _getEdge(a, b, prop, fn) {
      if (a && b) {
        return fn(a[prop], b[prop]);
      }
      return a ? a[prop] : b ? b[prop] : 0;
    }
    function _createBoundaryLine(boundary, line) {
      let points = [];
      let _loop = false;
      if (isArray$1(boundary)) {
        _loop = true;
        points = boundary;
      } else {
        points = _pointsFromSegments(boundary, line);
      }
      return points.length ? new LineElement({
        points,
        options: {
          tension: 0
        },
        _loop,
        _fullLoop: _loop
      }) : null;
    }
    function _shouldApplyFill(source) {
      return source && source.fill !== false;
    }
    function _resolveTarget(sources, index2, propagate) {
      const source = sources[index2];
      let fill2 = source.fill;
      const visited = [
        index2
      ];
      let target;
      if (!propagate) {
        return fill2;
      }
      while (fill2 !== false && visited.indexOf(fill2) === -1) {
        if (!isNumberFinite(fill2)) {
          return fill2;
        }
        target = sources[fill2];
        if (!target) {
          return false;
        }
        if (target.visible) {
          return fill2;
        }
        visited.push(fill2);
        fill2 = target.fill;
      }
      return false;
    }
    function _decodeFill(line, index2, count) {
      const fill2 = parseFillOption(line);
      if (isObject$1(fill2)) {
        return isNaN(fill2.value) ? false : fill2;
      }
      let target = parseFloat(fill2);
      if (isNumberFinite(target) && Math.floor(target) === target) {
        return decodeTargetIndex(fill2[0], index2, target, count);
      }
      return [
        "origin",
        "start",
        "end",
        "stack",
        "shape"
      ].indexOf(fill2) >= 0 && fill2;
    }
    function decodeTargetIndex(firstCh, index2, target, count) {
      if (firstCh === "-" || firstCh === "+") {
        target = index2 + target;
      }
      if (target === index2 || target < 0 || target >= count) {
        return false;
      }
      return target;
    }
    function _getTargetPixel(fill2, scale) {
      let pixel = null;
      if (fill2 === "start") {
        pixel = scale.bottom;
      } else if (fill2 === "end") {
        pixel = scale.top;
      } else if (isObject$1(fill2)) {
        pixel = scale.getPixelForValue(fill2.value);
      } else if (scale.getBasePixel) {
        pixel = scale.getBasePixel();
      }
      return pixel;
    }
    function _getTargetValue(fill2, scale, startValue) {
      let value;
      if (fill2 === "start") {
        value = startValue;
      } else if (fill2 === "end") {
        value = scale.options.reverse ? scale.min : scale.max;
      } else if (isObject$1(fill2)) {
        value = fill2.value;
      } else {
        value = scale.getBaseValue();
      }
      return value;
    }
    function parseFillOption(line) {
      const options = line.options;
      const fillOption = options.fill;
      let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
      if (fill2 === void 0) {
        fill2 = !!options.backgroundColor;
      }
      if (fill2 === false || fill2 === null) {
        return false;
      }
      if (fill2 === true) {
        return "origin";
      }
      return fill2;
    }
    function _buildStackLine(source) {
      const { scale, index: index2, line } = source;
      const points = [];
      const segments = line.segments;
      const sourcePoints = line.points;
      const linesBelow = getLinesBelow(scale, index2);
      linesBelow.push(_createBoundaryLine({
        x: null,
        y: scale.bottom
      }, line));
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        for (let j = segment.start; j <= segment.end; j++) {
          addPointsBelow(points, sourcePoints[j], linesBelow);
        }
      }
      return new LineElement({
        points,
        options: {}
      });
    }
    function getLinesBelow(scale, index2) {
      const below = [];
      const metas = scale.getMatchingVisibleMetas("line");
      for (let i = 0; i < metas.length; i++) {
        const meta = metas[i];
        if (meta.index === index2) {
          break;
        }
        if (!meta.hidden) {
          below.unshift(meta.dataset);
        }
      }
      return below;
    }
    function addPointsBelow(points, sourcePoint, linesBelow) {
      const postponed = [];
      for (let j = 0; j < linesBelow.length; j++) {
        const line = linesBelow[j];
        const { first, last, point } = findPoint(line, sourcePoint, "x");
        if (!point || first && last) {
          continue;
        }
        if (first) {
          postponed.unshift(point);
        } else {
          points.push(point);
          if (!last) {
            break;
          }
        }
      }
      points.push(...postponed);
    }
    function findPoint(line, sourcePoint, property) {
      const point = line.interpolate(sourcePoint, property);
      if (!point) {
        return {};
      }
      const pointValue = point[property];
      const segments = line.segments;
      const linePoints = line.points;
      let first = false;
      let last = false;
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const firstValue = linePoints[segment.start][property];
        const lastValue = linePoints[segment.end][property];
        if (_isBetween(pointValue, firstValue, lastValue)) {
          first = pointValue === firstValue;
          last = pointValue === lastValue;
          break;
        }
      }
      return {
        first,
        last,
        point
      };
    }
    class simpleArc {
      constructor(opts) {
        this.x = opts.x;
        this.y = opts.y;
        this.radius = opts.radius;
      }
      pathSegment(ctx, bounds, opts) {
        const { x, y, radius } = this;
        bounds = bounds || {
          start: 0,
          end: TAU
        };
        ctx.arc(x, y, radius, bounds.end, bounds.start, true);
        return !opts.bounds;
      }
      interpolate(point) {
        const { x, y, radius } = this;
        const angle = point.angle;
        return {
          x: x + Math.cos(angle) * radius,
          y: y + Math.sin(angle) * radius,
          angle
        };
      }
    }
    function _getTarget(source) {
      const { chart, fill: fill2, line } = source;
      if (isNumberFinite(fill2)) {
        return getLineByIndex(chart, fill2);
      }
      if (fill2 === "stack") {
        return _buildStackLine(source);
      }
      if (fill2 === "shape") {
        return true;
      }
      const boundary = computeBoundary(source);
      if (boundary instanceof simpleArc) {
        return boundary;
      }
      return _createBoundaryLine(boundary, line);
    }
    function getLineByIndex(chart, index2) {
      const meta = chart.getDatasetMeta(index2);
      const visible = meta && chart.isDatasetVisible(index2);
      return visible ? meta.dataset : null;
    }
    function computeBoundary(source) {
      const scale = source.scale || {};
      if (scale.getPointPositionForValue) {
        return computeCircularBoundary(source);
      }
      return computeLinearBoundary(source);
    }
    function computeLinearBoundary(source) {
      const { scale = {}, fill: fill2 } = source;
      const pixel = _getTargetPixel(fill2, scale);
      if (isNumberFinite(pixel)) {
        const horizontal = scale.isHorizontal();
        return {
          x: horizontal ? pixel : null,
          y: horizontal ? null : pixel
        };
      }
      return null;
    }
    function computeCircularBoundary(source) {
      const { scale, fill: fill2 } = source;
      const options = scale.options;
      const length = scale.getLabels().length;
      const start2 = options.reverse ? scale.max : scale.min;
      const value = _getTargetValue(fill2, scale, start2);
      const target = [];
      if (options.grid.circular) {
        const center = scale.getPointPositionForValue(0, start2);
        return new simpleArc({
          x: center.x,
          y: center.y,
          radius: scale.getDistanceFromCenterForValue(value)
        });
      }
      for (let i = 0; i < length; ++i) {
        target.push(scale.getPointPositionForValue(i, value));
      }
      return target;
    }
    function _drawfill(ctx, source, area) {
      const target = _getTarget(source);
      const { line, scale, axis } = source;
      const lineOpts = line.options;
      const fillOption = lineOpts.fill;
      const color2 = lineOpts.backgroundColor;
      const { above = color2, below = color2 } = fillOption || {};
      if (target && line.points.length) {
        clipArea(ctx, area);
        doFill(ctx, {
          line,
          target,
          above,
          below,
          area,
          scale,
          axis
        });
        unclipArea(ctx);
      }
    }
    function doFill(ctx, cfg) {
      const { line, target, above, below, area, scale } = cfg;
      const property = line._loop ? "angle" : cfg.axis;
      ctx.save();
      if (property === "x" && below !== above) {
        clipVertical(ctx, target, area.top);
        fill(ctx, {
          line,
          target,
          color: above,
          scale,
          property
        });
        ctx.restore();
        ctx.save();
        clipVertical(ctx, target, area.bottom);
      }
      fill(ctx, {
        line,
        target,
        color: below,
        scale,
        property
      });
      ctx.restore();
    }
    function clipVertical(ctx, target, clipY) {
      const { segments, points } = target;
      let first = true;
      let lineLoop = false;
      ctx.beginPath();
      for (const segment of segments) {
        const { start: start2, end: end2 } = segment;
        const firstPoint = points[start2];
        const lastPoint = points[_findSegmentEnd(start2, end2, points)];
        if (first) {
          ctx.moveTo(firstPoint.x, firstPoint.y);
          first = false;
        } else {
          ctx.lineTo(firstPoint.x, clipY);
          ctx.lineTo(firstPoint.x, firstPoint.y);
        }
        lineLoop = !!target.pathSegment(ctx, segment, {
          move: lineLoop
        });
        if (lineLoop) {
          ctx.closePath();
        } else {
          ctx.lineTo(lastPoint.x, clipY);
        }
      }
      ctx.lineTo(target.first().x, clipY);
      ctx.closePath();
      ctx.clip();
    }
    function fill(ctx, cfg) {
      const { line, target, property, color: color2, scale } = cfg;
      const segments = _segments(line, target, property);
      for (const { source: src2, target: tgt, start: start2, end: end2 } of segments) {
        const { style: { backgroundColor = color2 } = {} } = src2;
        const notShape = target !== true;
        ctx.save();
        ctx.fillStyle = backgroundColor;
        clipBounds(ctx, scale, notShape && _getBounds(property, start2, end2));
        ctx.beginPath();
        const lineLoop = !!line.pathSegment(ctx, src2);
        let loop;
        if (notShape) {
          if (lineLoop) {
            ctx.closePath();
          } else {
            interpolatedLineTo(ctx, target, end2, property);
          }
          const targetLoop = !!target.pathSegment(ctx, tgt, {
            move: lineLoop,
            reverse: true
          });
          loop = lineLoop && targetLoop;
          if (!loop) {
            interpolatedLineTo(ctx, target, start2, property);
          }
        }
        ctx.closePath();
        ctx.fill(loop ? "evenodd" : "nonzero");
        ctx.restore();
      }
    }
    function clipBounds(ctx, scale, bounds) {
      const { top: top2, bottom: bottom2 } = scale.chart.chartArea;
      const { property, start: start2, end: end2 } = bounds || {};
      if (property === "x") {
        ctx.beginPath();
        ctx.rect(start2, top2, end2 - start2, bottom2 - top2);
        ctx.clip();
      }
    }
    function interpolatedLineTo(ctx, target, point, property) {
      const interpolatedPoint = target.interpolate(point, property);
      if (interpolatedPoint) {
        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
      }
    }
    var index = {
      id: "filler",
      afterDatasetsUpdate(chart, _args, options) {
        const count = (chart.data.datasets || []).length;
        const sources = [];
        let meta, i, line, source;
        for (i = 0; i < count; ++i) {
          meta = chart.getDatasetMeta(i);
          line = meta.dataset;
          source = null;
          if (line && line.options && line instanceof LineElement) {
            source = {
              visible: chart.isDatasetVisible(i),
              index: i,
              fill: _decodeFill(line, i, count),
              chart,
              axis: meta.controller.options.indexAxis,
              scale: meta.vScale,
              line
            };
          }
          meta.$filler = source;
          sources.push(source);
        }
        for (i = 0; i < count; ++i) {
          source = sources[i];
          if (!source || source.fill === false) {
            continue;
          }
          source.fill = _resolveTarget(sources, i, options.propagate);
        }
      },
      beforeDraw(chart, _args, options) {
        const draw2 = options.drawTime === "beforeDraw";
        const metasets = chart.getSortedVisibleDatasetMetas();
        const area = chart.chartArea;
        for (let i = metasets.length - 1; i >= 0; --i) {
          const source = metasets[i].$filler;
          if (!source) {
            continue;
          }
          source.line.updateControlPoints(area, source.axis);
          if (draw2 && source.fill) {
            _drawfill(chart.ctx, source, area);
          }
        }
      },
      beforeDatasetsDraw(chart, _args, options) {
        if (options.drawTime !== "beforeDatasetsDraw") {
          return;
        }
        const metasets = chart.getSortedVisibleDatasetMetas();
        for (let i = metasets.length - 1; i >= 0; --i) {
          const source = metasets[i].$filler;
          if (_shouldApplyFill(source)) {
            _drawfill(chart.ctx, source, chart.chartArea);
          }
        }
      },
      beforeDatasetDraw(chart, args, options) {
        const source = args.meta.$filler;
        if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
          return;
        }
        _drawfill(chart.ctx, source, chart.chartArea);
      },
      defaults: {
        propagate: true,
        drawTime: "beforeDatasetDraw"
      }
    };
    const positioners = {
      average(items) {
        if (!items.length) {
          return false;
        }
        let i, len;
        let xSet = /* @__PURE__ */ new Set();
        let y = 0;
        let count = 0;
        for (i = 0, len = items.length; i < len; ++i) {
          const el = items[i].element;
          if (el && el.hasValue()) {
            const pos = el.tooltipPosition();
            xSet.add(pos.x);
            y += pos.y;
            ++count;
          }
        }
        if (count === 0 || xSet.size === 0) {
          return false;
        }
        const xAverage = [
          ...xSet
        ].reduce((a, b) => a + b) / xSet.size;
        return {
          x: xAverage,
          y: y / count
        };
      },
      nearest(items, eventPosition) {
        if (!items.length) {
          return false;
        }
        let x = eventPosition.x;
        let y = eventPosition.y;
        let minDistance = Number.POSITIVE_INFINITY;
        let i, len, nearestElement;
        for (i = 0, len = items.length; i < len; ++i) {
          const el = items[i].element;
          if (el && el.hasValue()) {
            const center = el.getCenterPoint();
            const d = distanceBetweenPoints(eventPosition, center);
            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }
        if (nearestElement) {
          const tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }
        return {
          x,
          y
        };
      }
    };
    function pushOrConcat(base, toPush) {
      if (toPush) {
        if (isArray$1(toPush)) {
          Array.prototype.push.apply(base, toPush);
        } else {
          base.push(toPush);
        }
      }
      return base;
    }
    function splitNewlines(str) {
      if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
        return str.split("\n");
      }
      return str;
    }
    function createTooltipItem(chart, item) {
      const { element, datasetIndex, index: index2 } = item;
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      const { label, value } = controller.getLabelAndValue(index2);
      return {
        chart,
        label,
        parsed: controller.getParsed(index2),
        raw: chart.data.datasets[datasetIndex].data[index2],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index2,
        datasetIndex,
        element
      };
    }
    function getTooltipSize(tooltip, options) {
      const ctx = tooltip.chart.ctx;
      const { body, footer, title } = tooltip;
      const { boxWidth, boxHeight } = options;
      const bodyFont = toFont(options.bodyFont);
      const titleFont = toFont(options.titleFont);
      const footerFont = toFont(options.footerFont);
      const titleLineCount = title.length;
      const footerLineCount = footer.length;
      const bodyLineItemCount = body.length;
      const padding = toPadding(options.padding);
      let height = padding.height;
      let width = 0;
      let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
      combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
      if (titleLineCount) {
        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
      }
      if (combinedBodyLength) {
        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
      }
      if (footerLineCount) {
        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
      }
      let widthPadding = 0;
      const maxLineWidth = function(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };
      ctx.save();
      ctx.font = titleFont.string;
      each(tooltip.title, maxLineWidth);
      ctx.font = bodyFont.string;
      each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
      widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
      each(body, (bodyItem) => {
        each(bodyItem.before, maxLineWidth);
        each(bodyItem.lines, maxLineWidth);
        each(bodyItem.after, maxLineWidth);
      });
      widthPadding = 0;
      ctx.font = footerFont.string;
      each(tooltip.footer, maxLineWidth);
      ctx.restore();
      width += padding.width;
      return {
        width,
        height
      };
    }
    function determineYAlign(chart, size) {
      const { y, height } = size;
      if (y < height / 2) {
        return "top";
      } else if (y > chart.height - height / 2) {
        return "bottom";
      }
      return "center";
    }
    function doesNotFitWithAlign(xAlign, chart, options, size) {
      const { x, width } = size;
      const caret = options.caretSize + options.caretPadding;
      if (xAlign === "left" && x + width + caret > chart.width) {
        return true;
      }
      if (xAlign === "right" && x - width - caret < 0) {
        return true;
      }
    }
    function determineXAlign(chart, options, size, yAlign) {
      const { x, width } = size;
      const { width: chartWidth, chartArea: { left: left2, right: right2 } } = chart;
      let xAlign = "center";
      if (yAlign === "center") {
        xAlign = x <= (left2 + right2) / 2 ? "left" : "right";
      } else if (x <= width / 2) {
        xAlign = "left";
      } else if (x >= chartWidth - width / 2) {
        xAlign = "right";
      }
      if (doesNotFitWithAlign(xAlign, chart, options, size)) {
        xAlign = "center";
      }
      return xAlign;
    }
    function determineAlignment(chart, options, size) {
      const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
      return {
        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign
      };
    }
    function alignX(size, xAlign) {
      let { x, width } = size;
      if (xAlign === "right") {
        x -= width;
      } else if (xAlign === "center") {
        x -= width / 2;
      }
      return x;
    }
    function alignY(size, yAlign, paddingAndSize) {
      let { y, height } = size;
      if (yAlign === "top") {
        y += paddingAndSize;
      } else if (yAlign === "bottom") {
        y -= height + paddingAndSize;
      } else {
        y -= height / 2;
      }
      return y;
    }
    function getBackgroundPoint(options, size, alignment, chart) {
      const { caretSize, caretPadding, cornerRadius } = options;
      const { xAlign, yAlign } = alignment;
      const paddingAndSize = caretSize + caretPadding;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      let x = alignX(size, xAlign);
      const y = alignY(size, yAlign, paddingAndSize);
      if (yAlign === "center") {
        if (xAlign === "left") {
          x += paddingAndSize;
        } else if (xAlign === "right") {
          x -= paddingAndSize;
        }
      } else if (xAlign === "left") {
        x -= Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x += Math.max(topRight, bottomRight) + caretSize;
      }
      return {
        x: _limitValue(x, 0, chart.width - size.width),
        y: _limitValue(y, 0, chart.height - size.height)
      };
    }
    function getAlignedX(tooltip, align, options) {
      const padding = toPadding(options.padding);
      return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
    }
    function getBeforeAfterBodyLines(callback2) {
      return pushOrConcat([], splitNewlines(callback2));
    }
    function createTooltipContext(parent, tooltip, tooltipItems) {
      return createContext(parent, {
        tooltip,
        tooltipItems,
        type: "tooltip"
      });
    }
    function overrideCallbacks(callbacks, context) {
      const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
      return override ? callbacks.override(override) : callbacks;
    }
    const defaultCallbacks = {
      beforeTitle: noop,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === "dataset") {
            return item.dataset.label || "";
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return "";
      },
      afterTitle: noop,
      beforeBody: noop,
      beforeLabel: noop,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
          return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
          label += ": ";
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation
        };
      },
      afterLabel: noop,
      afterBody: noop,
      beforeFooter: noop,
      footer: noop,
      afterFooter: noop
    };
    function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
      const result = callbacks[name].call(ctx, arg);
      if (typeof result === "undefined") {
        return defaultCallbacks[name].call(ctx, arg);
      }
      return result;
    }
    class Tooltip extends Element$1 {
      constructor(config) {
        super();
        this.opacity = 0;
        this._active = [];
        this._eventPosition = void 0;
        this._size = void 0;
        this._cachedAnimations = void 0;
        this._tooltipItems = [];
        this.$animations = void 0;
        this.$context = void 0;
        this.chart = config.chart;
        this.options = config.options;
        this.dataPoints = void 0;
        this.title = void 0;
        this.beforeBody = void 0;
        this.body = void 0;
        this.afterBody = void 0;
        this.footer = void 0;
        this.xAlign = void 0;
        this.yAlign = void 0;
        this.x = void 0;
        this.y = void 0;
        this.height = void 0;
        this.width = void 0;
        this.caretX = void 0;
        this.caretY = void 0;
        this.labelColors = void 0;
        this.labelPointStyles = void 0;
        this.labelTextColors = void 0;
      }
      initialize(options) {
        this.options = options;
        this._cachedAnimations = void 0;
        this.$context = void 0;
      }
      _resolveAnimations() {
        const cached = this._cachedAnimations;
        if (cached) {
          return cached;
        }
        const chart = this.chart;
        const options = this.options.setContext(this.getContext());
        const opts = options.enabled && chart.options.animation && options.animations;
        const animations = new Animations(this.chart, opts);
        if (opts._cacheable) {
          this._cachedAnimations = Object.freeze(animations);
        }
        return animations;
      }
      getContext() {
        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
      }
      getTitle(context, options) {
        const { callbacks } = options;
        const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
        const title = invokeCallbackWithFallback(callbacks, "title", this, context);
        const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      }
      getBeforeBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
      }
      getBody(tooltipItems, options) {
        const { callbacks } = options;
        const bodyItems = [];
        each(tooltipItems, (context) => {
          const bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          const scoped = overrideCallbacks(callbacks, context);
          pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
          pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
          pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      }
      getAfterBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
      }
      getFooter(tooltipItems, options) {
        const { callbacks } = options;
        const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
        const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
        const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      }
      _createItems(options) {
        const active = this._active;
        const data = this.chart.data;
        const labelColors = [];
        const labelPointStyles = [];
        const labelTextColors = [];
        let tooltipItems = [];
        let i, len;
        for (i = 0, len = active.length; i < len; ++i) {
          tooltipItems.push(createTooltipItem(this.chart, active[i]));
        }
        if (options.filter) {
          tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
        }
        if (options.itemSort) {
          tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
        }
        each(tooltipItems, (context) => {
          const scoped = overrideCallbacks(options.callbacks, context);
          labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
          labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
          labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
        });
        this.labelColors = labelColors;
        this.labelPointStyles = labelPointStyles;
        this.labelTextColors = labelTextColors;
        this.dataPoints = tooltipItems;
        return tooltipItems;
      }
      update(changed, replay) {
        const options = this.options.setContext(this.getContext());
        const active = this._active;
        let properties;
        let tooltipItems = [];
        if (!active.length) {
          if (this.opacity !== 0) {
            properties = {
              opacity: 0
            };
          }
        } else {
          const position = positioners[options.position].call(this, active, this._eventPosition);
          tooltipItems = this._createItems(options);
          this.title = this.getTitle(tooltipItems, options);
          this.beforeBody = this.getBeforeBody(tooltipItems, options);
          this.body = this.getBody(tooltipItems, options);
          this.afterBody = this.getAfterBody(tooltipItems, options);
          this.footer = this.getFooter(tooltipItems, options);
          const size = this._size = getTooltipSize(this, options);
          const positionAndSize = Object.assign({}, position, size);
          const alignment = determineAlignment(this.chart, options, positionAndSize);
          const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          properties = {
            opacity: 1,
            x: backgroundPoint.x,
            y: backgroundPoint.y,
            width: size.width,
            height: size.height,
            caretX: position.x,
            caretY: position.y
          };
        }
        this._tooltipItems = tooltipItems;
        this.$context = void 0;
        if (properties) {
          this._resolveAnimations().update(this, properties);
        }
        if (changed && options.external) {
          options.external.call(this, {
            chart: this.chart,
            tooltip: this,
            replay
          });
        }
      }
      drawCaret(tooltipPoint, ctx, size, options) {
        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      }
      getCaretPosition(tooltipPoint, size, options) {
        const { xAlign, yAlign } = this;
        const { caretSize, cornerRadius } = options;
        const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
        const { x: ptX, y: ptY } = tooltipPoint;
        const { width, height } = size;
        let x1, x2, x3, y1, y2, y3;
        if (yAlign === "center") {
          y2 = ptY + height / 2;
          if (xAlign === "left") {
            x1 = ptX;
            x2 = x1 - caretSize;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
          x3 = x1;
        } else {
          if (xAlign === "left") {
            x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
          } else if (xAlign === "right") {
            x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
          } else {
            x2 = this.caretX;
          }
          if (yAlign === "top") {
            y1 = ptY;
            y2 = y1 - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            x1 = x2 + caretSize;
            x3 = x2 - caretSize;
          }
          y3 = y1;
        }
        return {
          x1,
          x2,
          x3,
          y1,
          y2,
          y3
        };
      }
      drawTitle(pt, ctx, options) {
        const title = this.title;
        const length = title.length;
        let titleFont, titleSpacing, i;
        if (length) {
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          pt.x = getAlignedX(this, options.titleAlign, options);
          ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
          ctx.textBaseline = "middle";
          titleFont = toFont(options.titleFont);
          titleSpacing = options.titleSpacing;
          ctx.fillStyle = options.titleColor;
          ctx.font = titleFont.string;
          for (i = 0; i < length; ++i) {
            ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
            pt.y += titleFont.lineHeight + titleSpacing;
            if (i + 1 === length) {
              pt.y += options.titleMarginBottom - titleSpacing;
            }
          }
        }
      }
      _drawColorBox(ctx, pt, i, rtlHelper, options) {
        const labelColor = this.labelColors[i];
        const labelPointStyle = this.labelPointStyles[i];
        const { boxHeight, boxWidth } = options;
        const bodyFont = toFont(options.bodyFont);
        const colorX = getAlignedX(this, "left", options);
        const rtlColorX = rtlHelper.x(colorX);
        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
        const colorY = pt.y + yOffSet;
        if (options.usePointStyle) {
          const drawOptions = {
            radius: Math.min(boxWidth, boxHeight) / 2,
            pointStyle: labelPointStyle.pointStyle,
            rotation: labelPointStyle.rotation,
            borderWidth: 1
          };
          const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
          const centerY = colorY + boxHeight / 2;
          ctx.strokeStyle = options.multiKeyBackground;
          ctx.fillStyle = options.multiKeyBackground;
          drawPoint(ctx, drawOptions, centerX, centerY);
          ctx.strokeStyle = labelColor.borderColor;
          ctx.fillStyle = labelColor.backgroundColor;
          drawPoint(ctx, drawOptions, centerX, centerY);
        } else {
          ctx.lineWidth = isObject$1(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
          ctx.strokeStyle = labelColor.borderColor;
          ctx.setLineDash(labelColor.borderDash || []);
          ctx.lineDashOffset = labelColor.borderDashOffset || 0;
          const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
          const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
          const borderRadius = toTRBLCorners(labelColor.borderRadius);
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            ctx.beginPath();
            ctx.fillStyle = options.multiKeyBackground;
            addRoundedRectPath(ctx, {
              x: outerX,
              y: colorY,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = labelColor.backgroundColor;
            ctx.beginPath();
            addRoundedRectPath(ctx, {
              x: innerX,
              y: colorY + 1,
              w: boxWidth - 2,
              h: boxHeight - 2,
              radius: borderRadius
            });
            ctx.fill();
          } else {
            ctx.fillStyle = options.multiKeyBackground;
            ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
            ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
            ctx.fillStyle = labelColor.backgroundColor;
            ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
          }
        }
        ctx.fillStyle = this.labelTextColors[i];
      }
      drawBody(pt, ctx, options) {
        const { body } = this;
        const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
        const bodyFont = toFont(options.bodyFont);
        let bodyLineHeight = bodyFont.lineHeight;
        let xLinePadding = 0;
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        const fillLineOfText = function(line) {
          ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
          pt.y += bodyLineHeight + bodySpacing;
        };
        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        let bodyItem, textColor, lines, i, j, ilen, jlen;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = "middle";
        ctx.font = bodyFont.string;
        pt.x = getAlignedX(this, bodyAlignForCalculation, options);
        ctx.fillStyle = options.bodyColor;
        each(this.beforeBody, fillLineOfText);
        xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
        for (i = 0, ilen = body.length; i < ilen; ++i) {
          bodyItem = body[i];
          textColor = this.labelTextColors[i];
          ctx.fillStyle = textColor;
          each(bodyItem.before, fillLineOfText);
          lines = bodyItem.lines;
          if (displayColors && lines.length) {
            this._drawColorBox(ctx, pt, i, rtlHelper, options);
            bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
          }
          for (j = 0, jlen = lines.length; j < jlen; ++j) {
            fillLineOfText(lines[j]);
            bodyLineHeight = bodyFont.lineHeight;
          }
          each(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        bodyLineHeight = bodyFont.lineHeight;
        each(this.afterBody, fillLineOfText);
        pt.y -= bodySpacing;
      }
      drawFooter(pt, ctx, options) {
        const footer = this.footer;
        const length = footer.length;
        let footerFont, i;
        if (length) {
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          pt.x = getAlignedX(this, options.footerAlign, options);
          pt.y += options.footerMarginTop;
          ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
          ctx.textBaseline = "middle";
          footerFont = toFont(options.footerFont);
          ctx.fillStyle = options.footerColor;
          ctx.font = footerFont.string;
          for (i = 0; i < length; ++i) {
            ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
            pt.y += footerFont.lineHeight + options.footerSpacing;
          }
        }
      }
      drawBackground(pt, ctx, tooltipSize, options) {
        const { xAlign, yAlign } = this;
        const { x, y } = pt;
        const { width, height } = tooltipSize;
        const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.beginPath();
        ctx.moveTo(x + topLeft, y);
        if (yAlign === "top") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width - topRight, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
        if (yAlign === "center" && xAlign === "right") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width, y + height - bottomRight);
        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
        if (yAlign === "bottom") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + bottomLeft, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
        if (yAlign === "center" && xAlign === "left") {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x, y + topLeft);
        ctx.quadraticCurveTo(x, y, x + topLeft, y);
        ctx.closePath();
        ctx.fill();
        if (options.borderWidth > 0) {
          ctx.stroke();
        }
      }
      _updateAnimationTarget(options) {
        const chart = this.chart;
        const anims = this.$animations;
        const animX = anims && anims.x;
        const animY = anims && anims.y;
        if (animX || animY) {
          const position = positioners[options.position].call(this, this._active, this._eventPosition);
          if (!position) {
            return;
          }
          const size = this._size = getTooltipSize(this, options);
          const positionAndSize = Object.assign({}, position, this._size);
          const alignment = determineAlignment(chart, options, positionAndSize);
          const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
          if (animX._to !== point.x || animY._to !== point.y) {
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            this.width = size.width;
            this.height = size.height;
            this.caretX = position.x;
            this.caretY = position.y;
            this._resolveAnimations().update(this, point);
          }
        }
      }
      _willRender() {
        return !!this.opacity;
      }
      draw(ctx) {
        const options = this.options.setContext(this.getContext());
        let opacity = this.opacity;
        if (!opacity) {
          return;
        }
        this._updateAnimationTarget(options);
        const tooltipSize = {
          width: this.width,
          height: this.height
        };
        const pt = {
          x: this.x,
          y: this.y
        };
        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
        const padding = toPadding(options.padding);
        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        if (options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity;
          this.drawBackground(pt, ctx, tooltipSize, options);
          overrideTextDirection(ctx, options.textDirection);
          pt.y += padding.top;
          this.drawTitle(pt, ctx, options);
          this.drawBody(pt, ctx, options);
          this.drawFooter(pt, ctx, options);
          restoreTextDirection(ctx, options.textDirection);
          ctx.restore();
        }
      }
      getActiveElements() {
        return this._active || [];
      }
      setActiveElements(activeElements, eventPosition) {
        const lastActive = this._active;
        const active = activeElements.map(({ datasetIndex, index: index2 }) => {
          const meta = this.chart.getDatasetMeta(datasetIndex);
          if (!meta) {
            throw new Error("Cannot find a dataset at index " + datasetIndex);
          }
          return {
            datasetIndex,
            element: meta.data[index2],
            index: index2
          };
        });
        const changed = !_elementsEqual(lastActive, active);
        const positionChanged = this._positionChanged(active, eventPosition);
        if (changed || positionChanged) {
          this._active = active;
          this._eventPosition = eventPosition;
          this._ignoreReplayEvents = true;
          this.update(true);
        }
      }
      handleEvent(e, replay, inChartArea = true) {
        if (replay && this._ignoreReplayEvents) {
          return false;
        }
        this._ignoreReplayEvents = false;
        const options = this.options;
        const lastActive = this._active || [];
        const active = this._getActiveElements(e, lastActive, replay, inChartArea);
        const positionChanged = this._positionChanged(active, e);
        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
        if (changed) {
          this._active = active;
          if (options.enabled || options.external) {
            this._eventPosition = {
              x: e.x,
              y: e.y
            };
            this.update(true, replay);
          }
        }
        return changed;
      }
      _getActiveElements(e, lastActive, replay, inChartArea) {
        const options = this.options;
        if (e.type === "mouseout") {
          return [];
        }
        if (!inChartArea) {
          return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
        }
        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
        if (options.reverse) {
          active.reverse();
        }
        return active;
      }
      _positionChanged(active, e) {
        const { caretX, caretY, options } = this;
        const position = positioners[options.position].call(this, active, e);
        return position !== false && (caretX !== position.x || caretY !== position.y);
      }
    }
    __publicField(Tooltip, "positioners", positioners);
    var plugin_tooltip = {
      id: "tooltip",
      _element: Tooltip,
      positioners,
      afterInit(chart, _args, options) {
        if (options) {
          chart.tooltip = new Tooltip({
            chart,
            options
          });
        }
      },
      beforeUpdate(chart, _args, options) {
        if (chart.tooltip) {
          chart.tooltip.initialize(options);
        }
      },
      reset(chart, _args, options) {
        if (chart.tooltip) {
          chart.tooltip.initialize(options);
        }
      },
      afterDraw(chart) {
        const tooltip = chart.tooltip;
        if (tooltip && tooltip._willRender()) {
          const args = {
            tooltip
          };
          if (chart.notifyPlugins("beforeTooltipDraw", {
            ...args,
            cancelable: true
          }) === false) {
            return;
          }
          tooltip.draw(chart.ctx);
          chart.notifyPlugins("afterTooltipDraw", args);
        }
      },
      afterEvent(chart, args) {
        if (chart.tooltip) {
          const useFinalPosition = args.replay;
          if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
            args.changed = true;
          }
        }
      },
      defaults: {
        enabled: true,
        external: null,
        position: "average",
        backgroundColor: "rgba(0,0,0,0.8)",
        titleColor: "#fff",
        titleFont: {
          weight: "bold"
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: "left",
        bodyColor: "#fff",
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: "left",
        footerColor: "#fff",
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
          weight: "bold"
        },
        footerAlign: "left",
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (ctx, opts) => opts.bodyFont.size,
        boxWidth: (ctx, opts) => opts.bodyFont.size,
        multiKeyBackground: "#fff",
        displayColors: true,
        boxPadding: 0,
        borderColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        animation: {
          duration: 400,
          easing: "easeOutQuart"
        },
        animations: {
          numbers: {
            type: "number",
            properties: [
              "x",
              "y",
              "width",
              "height",
              "caretX",
              "caretY"
            ]
          },
          opacity: {
            easing: "linear",
            duration: 200
          }
        },
        callbacks: defaultCallbacks
      },
      defaultRoutes: {
        bodyFont: "font",
        footerFont: "font",
        titleFont: "font"
      },
      descriptors: {
        _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
        _indexable: false,
        callbacks: {
          _scriptable: false,
          _indexable: false
        },
        animation: {
          _fallback: false
        },
        animations: {
          _fallback: "animation"
        }
      },
      additionalOptionScopes: [
        "interaction"
      ]
    };
    function generateTicks$1(generationOptions, dataRange) {
      const ticks = [];
      const MIN_SPACING = 1e-14;
      const { bounds, step, min: min2, max: max2, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
      const unit = step || 1;
      const maxSpaces = maxTicks - 1;
      const { min: rmin, max: rmax } = dataRange;
      const minDefined = !isNullOrUndef(min2);
      const maxDefined = !isNullOrUndef(max2);
      const countDefined = !isNullOrUndef(count);
      const minSpacing = (rmax - rmin) / (maxDigits + 1);
      let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
      let factor, niceMin, niceMax, numSpaces;
      if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
        return [
          {
            value: rmin
          },
          {
            value: rmax
          }
        ];
      }
      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
      if (numSpaces > maxSpaces) {
        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
      }
      if (!isNullOrUndef(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }
      if (bounds === "ticks") {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
      } else {
        niceMin = rmin;
        niceMax = rmax;
      }
      if (minDefined && maxDefined && step && almostWhole((max2 - min2) / step, spacing / 1e3)) {
        numSpaces = Math.round(Math.min((max2 - min2) / spacing, maxTicks));
        spacing = (max2 - min2) / numSpaces;
        niceMin = min2;
        niceMax = max2;
      } else if (countDefined) {
        niceMin = minDefined ? min2 : niceMin;
        niceMax = maxDefined ? max2 : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
      } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
          numSpaces = Math.round(numSpaces);
        } else {
          numSpaces = Math.ceil(numSpaces);
        }
      }
      const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
      factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      let j = 0;
      if (minDefined) {
        if (includeBounds && niceMin !== min2) {
          ticks.push({
            value: min2
          });
          if (niceMin < min2) {
            j++;
          }
          if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min2, relativeLabelSize(min2, minSpacing, generationOptions))) {
            j++;
          }
        } else if (niceMin < min2) {
          j++;
        }
      }
      for (; j < numSpaces; ++j) {
        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
        if (maxDefined && tickValue > max2) {
          break;
        }
        ticks.push({
          value: tickValue
        });
      }
      if (maxDefined && includeBounds && niceMax !== max2) {
        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
          ticks[ticks.length - 1].value = max2;
        } else {
          ticks.push({
            value: max2
          });
        }
      } else if (!maxDefined || niceMax === max2) {
        ticks.push({
          value: niceMax
        });
      }
      return ticks;
    }
    function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
      const rad = toRadians(minRotation);
      const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
      const length = 0.75 * minSpacing * ("" + value).length;
      return Math.min(minSpacing / ratio, length);
    }
    class LinearScaleBase extends Scale {
      constructor(cfg) {
        super(cfg);
        this.start = void 0;
        this.end = void 0;
        this._startValue = void 0;
        this._endValue = void 0;
        this._valueRange = 0;
      }
      parse(raw, index2) {
        if (isNullOrUndef(raw)) {
          return null;
        }
        if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
          return null;
        }
        return +raw;
      }
      handleTickRangeOptions() {
        const { beginAtZero } = this.options;
        const { minDefined, maxDefined } = this.getUserBounds();
        let { min: min2, max: max2 } = this;
        const setMin = (v) => min2 = minDefined ? min2 : v;
        const setMax = (v) => max2 = maxDefined ? max2 : v;
        if (beginAtZero) {
          const minSign = sign$1(min2);
          const maxSign = sign$1(max2);
          if (minSign < 0 && maxSign < 0) {
            setMax(0);
          } else if (minSign > 0 && maxSign > 0) {
            setMin(0);
          }
        }
        if (min2 === max2) {
          let offset2 = max2 === 0 ? 1 : Math.abs(max2 * 0.05);
          setMax(max2 + offset2);
          if (!beginAtZero) {
            setMin(min2 - offset2);
          }
        }
        this.min = min2;
        this.max = max2;
      }
      getTickLimit() {
        const tickOpts = this.options.ticks;
        let { maxTicksLimit, stepSize } = tickOpts;
        let maxTicks;
        if (stepSize) {
          maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
          if (maxTicks > 1e3) {
            console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
            maxTicks = 1e3;
          }
        } else {
          maxTicks = this.computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }
        return maxTicks;
      }
      computeTickLimit() {
        return Number.POSITIVE_INFINITY;
      }
      buildTicks() {
        const opts = this.options;
        const tickOpts = opts.ticks;
        let maxTicks = this.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        const numericGeneratorOptions = {
          maxTicks,
          bounds: opts.bounds,
          min: opts.min,
          max: opts.max,
          precision: tickOpts.precision,
          step: tickOpts.stepSize,
          count: tickOpts.count,
          maxDigits: this._maxDigits(),
          horizontal: this.isHorizontal(),
          minRotation: tickOpts.minRotation || 0,
          includeBounds: tickOpts.includeBounds !== false
        };
        const dataRange = this._range || this;
        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
        if (opts.bounds === "ticks") {
          _setMinAndMaxByKey(ticks, this, "value");
        }
        if (opts.reverse) {
          ticks.reverse();
          this.start = this.max;
          this.end = this.min;
        } else {
          this.start = this.min;
          this.end = this.max;
        }
        return ticks;
      }
      configure() {
        const ticks = this.ticks;
        let start2 = this.min;
        let end2 = this.max;
        super.configure();
        if (this.options.offset && ticks.length) {
          const offset2 = (end2 - start2) / Math.max(ticks.length - 1, 1) / 2;
          start2 -= offset2;
          end2 += offset2;
        }
        this._startValue = start2;
        this._endValue = end2;
        this._valueRange = end2 - start2;
      }
      getLabelForValue(value) {
        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
      }
    }
    class LinearScale extends LinearScaleBase {
      determineDataLimits() {
        const { min: min2, max: max2 } = this.getMinMax(true);
        this.min = isNumberFinite(min2) ? min2 : 0;
        this.max = isNumberFinite(max2) ? max2 : 1;
        this.handleTickRangeOptions();
      }
      computeTickLimit() {
        const horizontal = this.isHorizontal();
        const length = horizontal ? this.width : this.height;
        const minRotation = toRadians(this.options.ticks.minRotation);
        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
        const tickFont = this._resolveTickFontOptions(0);
        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
      }
      getPixelForValue(value) {
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
      }
      getValueForPixel(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
      }
    }
    __publicField(LinearScale, "id", "linear");
    __publicField(LinearScale, "defaults", {
      ticks: {
        callback: Ticks.formatters.numeric
      }
    });
    const INTERVALS = {
      millisecond: {
        common: true,
        size: 1,
        steps: 1e3
      },
      second: {
        common: true,
        size: 1e3,
        steps: 60
      },
      minute: {
        common: true,
        size: 6e4,
        steps: 60
      },
      hour: {
        common: true,
        size: 36e5,
        steps: 24
      },
      day: {
        common: true,
        size: 864e5,
        steps: 30
      },
      week: {
        common: false,
        size: 6048e5,
        steps: 4
      },
      month: {
        common: true,
        size: 2628e6,
        steps: 12
      },
      quarter: {
        common: false,
        size: 7884e6,
        steps: 4
      },
      year: {
        common: true,
        size: 3154e7
      }
    };
    const UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
    function sorter(a, b) {
      return a - b;
    }
    function parse(scale, input) {
      if (isNullOrUndef(input)) {
        return null;
      }
      const adapter = scale._adapter;
      const { parser, round: round2, isoWeekday } = scale._parseOpts;
      let value = input;
      if (typeof parser === "function") {
        value = parser(value);
      }
      if (!isNumberFinite(value)) {
        value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
      }
      if (value === null) {
        return null;
      }
      if (round2) {
        value = round2 === "week" && (isNumber$1(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
      }
      return +value;
    }
    function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
      const ilen = UNITS.length;
      for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        const interval = INTERVALS[UNITS[i]];
        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }
      return UNITS[ilen - 1];
    }
    function determineUnitForFormatting(scale, numTicks, minUnit, min2, max2) {
      for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
        const unit = UNITS[i];
        if (INTERVALS[unit].common && scale._adapter.diff(max2, min2, unit) >= numTicks - 1) {
          return unit;
        }
      }
      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }
    function determineMajorUnit(unit) {
      for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    function addTick(ticks, time, timestamps) {
      if (!timestamps) {
        ticks[time] = true;
      } else if (timestamps.length) {
        const { lo, hi } = _lookup(timestamps, time);
        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp] = true;
      }
    }
    function setMajorTicks(scale, ticks, map2, majorUnit) {
      const adapter = scale._adapter;
      const first = +adapter.startOf(ticks[0].value, majorUnit);
      const last = ticks[ticks.length - 1].value;
      let major, index2;
      for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
        index2 = map2[major];
        if (index2 >= 0) {
          ticks[index2].major = true;
        }
      }
      return ticks;
    }
    function ticksFromTimestamps(scale, values, majorUnit) {
      const ticks = [];
      const map2 = {};
      const ilen = values.length;
      let i, value;
      for (i = 0; i < ilen; ++i) {
        value = values[i];
        map2[value] = i;
        ticks.push({
          value,
          major: false
        });
      }
      return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
    }
    class TimeScale extends Scale {
      constructor(props) {
        super(props);
        this._cache = {
          data: [],
          labels: [],
          all: []
        };
        this._unit = "day";
        this._majorUnit = void 0;
        this._offsets = {};
        this._normalized = false;
        this._parseOpts = void 0;
      }
      init(scaleOpts, opts = {}) {
        const time = scaleOpts.time || (scaleOpts.time = {});
        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
        adapter.init(opts);
        mergeIf(time.displayFormats, adapter.formats());
        this._parseOpts = {
          parser: time.parser,
          round: time.round,
          isoWeekday: time.isoWeekday
        };
        super.init(scaleOpts);
        this._normalized = opts.normalized;
      }
      parse(raw, index2) {
        if (raw === void 0) {
          return null;
        }
        return parse(this, raw);
      }
      beforeLayout() {
        super.beforeLayout();
        this._cache = {
          data: [],
          labels: [],
          all: []
        };
      }
      determineDataLimits() {
        const options = this.options;
        const adapter = this._adapter;
        const unit = options.time.unit || "day";
        let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
        function _applyBounds(bounds) {
          if (!minDefined && !isNaN(bounds.min)) {
            min2 = Math.min(min2, bounds.min);
          }
          if (!maxDefined && !isNaN(bounds.max)) {
            max2 = Math.max(max2, bounds.max);
          }
        }
        if (!minDefined || !maxDefined) {
          _applyBounds(this._getLabelBounds());
          if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
            _applyBounds(this.getMinMax(false));
          }
        }
        min2 = isNumberFinite(min2) && !isNaN(min2) ? min2 : +adapter.startOf(Date.now(), unit);
        max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit) + 1;
        this.min = Math.min(min2, max2 - 1);
        this.max = Math.max(min2 + 1, max2);
      }
      _getLabelBounds() {
        const arr = this.getLabelTimestamps();
        let min2 = Number.POSITIVE_INFINITY;
        let max2 = Number.NEGATIVE_INFINITY;
        if (arr.length) {
          min2 = arr[0];
          max2 = arr[arr.length - 1];
        }
        return {
          min: min2,
          max: max2
        };
      }
      buildTicks() {
        const options = this.options;
        const timeOpts = options.time;
        const tickOpts = options.ticks;
        const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
        if (options.bounds === "ticks" && timestamps.length) {
          this.min = this._userMin || timestamps[0];
          this.max = this._userMax || timestamps[timestamps.length - 1];
        }
        const min2 = this.min;
        const max2 = this.max;
        const ticks = _filterBetween(timestamps, min2, max2);
        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min2)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
        this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
        this.initOffsets(timestamps);
        if (options.reverse) {
          ticks.reverse();
        }
        return ticksFromTimestamps(this, ticks, this._majorUnit);
      }
      afterAutoSkip() {
        if (this.options.offsetAfterAutoskip) {
          this.initOffsets(this.ticks.map((tick) => +tick.value));
        }
      }
      initOffsets(timestamps = []) {
        let start2 = 0;
        let end2 = 0;
        let first, last;
        if (this.options.offset && timestamps.length) {
          first = this.getDecimalForValue(timestamps[0]);
          if (timestamps.length === 1) {
            start2 = 1 - first;
          } else {
            start2 = (this.getDecimalForValue(timestamps[1]) - first) / 2;
          }
          last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
          if (timestamps.length === 1) {
            end2 = last;
          } else {
            end2 = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
          }
        }
        const limit = timestamps.length < 3 ? 0.5 : 0.25;
        start2 = _limitValue(start2, 0, limit);
        end2 = _limitValue(end2, 0, limit);
        this._offsets = {
          start: start2,
          end: end2,
          factor: 1 / (start2 + 1 + end2)
        };
      }
      _generate() {
        const adapter = this._adapter;
        const min2 = this.min;
        const max2 = this.max;
        const options = this.options;
        const timeOpts = options.time;
        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, this._getLabelCapacity(min2));
        const stepSize = valueOrDefault(options.ticks.stepSize, 1);
        const weekday = minor === "week" ? timeOpts.isoWeekday : false;
        const hasWeekday = isNumber$1(weekday) || weekday === true;
        const ticks = {};
        let first = min2;
        let time, count;
        if (hasWeekday) {
          first = +adapter.startOf(first, "isoWeek", weekday);
        }
        first = +adapter.startOf(first, hasWeekday ? "day" : minor);
        if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
          throw new Error(min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
        }
        const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
        for (time = first, count = 0; time < max2; time = +adapter.add(time, stepSize, minor), count++) {
          addTick(ticks, time, timestamps);
        }
        if (time === max2 || options.bounds === "ticks" || count === 1) {
          addTick(ticks, time, timestamps);
        }
        return Object.keys(ticks).sort(sorter).map((x) => +x);
      }
      getLabelForValue(value) {
        const adapter = this._adapter;
        const timeOpts = this.options.time;
        if (timeOpts.tooltipFormat) {
          return adapter.format(value, timeOpts.tooltipFormat);
        }
        return adapter.format(value, timeOpts.displayFormats.datetime);
      }
      format(value, format2) {
        const options = this.options;
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const fmt = format2 || formats[unit];
        return this._adapter.format(value, fmt);
      }
      _tickFormatFunction(time, index2, ticks, format2) {
        const options = this.options;
        const formatter = options.ticks.callback;
        if (formatter) {
          return callback(formatter, [
            time,
            index2,
            ticks
          ], this);
        }
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const majorUnit = this._majorUnit;
        const minorFormat = unit && formats[unit];
        const majorFormat = majorUnit && formats[majorUnit];
        const tick = ticks[index2];
        const major = majorUnit && majorFormat && tick && tick.major;
        return this._adapter.format(time, format2 || (major ? majorFormat : minorFormat));
      }
      generateTickLabels(ticks) {
        let i, ilen, tick;
        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          tick = ticks[i];
          tick.label = this._tickFormatFunction(tick.value, i, ticks);
        }
      }
      getDecimalForValue(value) {
        return value === null ? NaN : (value - this.min) / (this.max - this.min);
      }
      getPixelForValue(value) {
        const offsets = this._offsets;
        const pos = this.getDecimalForValue(value);
        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
      }
      getValueForPixel(pixel) {
        const offsets = this._offsets;
        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return this.min + pos * (this.max - this.min);
      }
      _getLabelSize(label) {
        const ticksOpts = this.options.ticks;
        const tickLabelWidth = this.ctx.measureText(label).width;
        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
        const cosRotation = Math.cos(angle);
        const sinRotation = Math.sin(angle);
        const tickFontSize = this._resolveTickFontOptions(0).size;
        return {
          w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
          h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
        };
      }
      _getLabelCapacity(exampleTime) {
        const timeOpts = this.options.time;
        const displayFormats = timeOpts.displayFormats;
        const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
          exampleTime
        ], this._majorUnit), format2);
        const size = this._getLabelSize(exampleLabel);
        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
        return capacity > 0 ? capacity : 1;
      }
      getDataTimestamps() {
        let timestamps = this._cache.data || [];
        let i, ilen;
        if (timestamps.length) {
          return timestamps;
        }
        const metas = this.getMatchingVisibleMetas();
        if (this._normalized && metas.length) {
          return this._cache.data = metas[0].controller.getAllParsedValues(this);
        }
        for (i = 0, ilen = metas.length; i < ilen; ++i) {
          timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
        }
        return this._cache.data = this.normalize(timestamps);
      }
      getLabelTimestamps() {
        const timestamps = this._cache.labels || [];
        let i, ilen;
        if (timestamps.length) {
          return timestamps;
        }
        const labels = this.getLabels();
        for (i = 0, ilen = labels.length; i < ilen; ++i) {
          timestamps.push(parse(this, labels[i]));
        }
        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
      }
      normalize(values) {
        return _arrayUnique(values.sort(sorter));
      }
    }
    __publicField(TimeScale, "id", "time");
    __publicField(TimeScale, "defaults", {
      bounds: "data",
      adapters: {},
      time: {
        parser: false,
        unit: false,
        round: false,
        isoWeekday: false,
        minUnit: "millisecond",
        displayFormats: {}
      },
      ticks: {
        source: "auto",
        callback: false,
        major: {
          enabled: false
        }
      }
    });
    function interpolate(table, val, reverse) {
      let lo = 0;
      let hi = table.length - 1;
      let prevSource, nextSource, prevTarget, nextTarget;
      if (reverse) {
        if (val >= table[lo].pos && val <= table[hi].pos) {
          ({ lo, hi } = _lookupByKey(table, "pos", val));
        }
        ({ pos: prevSource, time: prevTarget } = table[lo]);
        ({ pos: nextSource, time: nextTarget } = table[hi]);
      } else {
        if (val >= table[lo].time && val <= table[hi].time) {
          ({ lo, hi } = _lookupByKey(table, "time", val));
        }
        ({ time: prevSource, pos: prevTarget } = table[lo]);
        ({ time: nextSource, pos: nextTarget } = table[hi]);
      }
      const span = nextSource - prevSource;
      return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
    }
    class TimeSeriesScale extends TimeScale {
      constructor(props) {
        super(props);
        this._table = [];
        this._minPos = void 0;
        this._tableRange = void 0;
      }
      initOffsets() {
        const timestamps = this._getTimestampsForTable();
        const table = this._table = this.buildLookupTable(timestamps);
        this._minPos = interpolate(table, this.min);
        this._tableRange = interpolate(table, this.max) - this._minPos;
        super.initOffsets(timestamps);
      }
      buildLookupTable(timestamps) {
        const { min: min2, max: max2 } = this;
        const items = [];
        const table = [];
        let i, ilen, prev, curr, next;
        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          curr = timestamps[i];
          if (curr >= min2 && curr <= max2) {
            items.push(curr);
          }
        }
        if (items.length < 2) {
          return [
            {
              time: min2,
              pos: 0
            },
            {
              time: max2,
              pos: 1
            }
          ];
        }
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          next = items[i + 1];
          prev = items[i - 1];
          curr = items[i];
          if (Math.round((next + prev) / 2) !== curr) {
            table.push({
              time: curr,
              pos: i / (ilen - 1)
            });
          }
        }
        return table;
      }
      _generate() {
        const min2 = this.min;
        const max2 = this.max;
        let timestamps = super.getDataTimestamps();
        if (!timestamps.includes(min2) || !timestamps.length) {
          timestamps.splice(0, 0, min2);
        }
        if (!timestamps.includes(max2) || timestamps.length === 1) {
          timestamps.push(max2);
        }
        return timestamps.sort((a, b) => a - b);
      }
      _getTimestampsForTable() {
        let timestamps = this._cache.all || [];
        if (timestamps.length) {
          return timestamps;
        }
        const data = this.getDataTimestamps();
        const label = this.getLabelTimestamps();
        if (data.length && label.length) {
          timestamps = this.normalize(data.concat(label));
        } else {
          timestamps = data.length ? data : label;
        }
        timestamps = this._cache.all = timestamps;
        return timestamps;
      }
      getDecimalForValue(value) {
        return (interpolate(this._table, value) - this._minPos) / this._tableRange;
      }
      getValueForPixel(pixel) {
        const offsets = this._offsets;
        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
      }
    }
    __publicField(TimeSeriesScale, "id", "timeseries");
    __publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
    var resolveConfig$2 = {};
    var resolveConfig$1 = {};
    var negateValue = {};
    var hasRequiredNegateValue;
    function requireNegateValue() {
      if (hasRequiredNegateValue) return negateValue;
      hasRequiredNegateValue = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return negateValue2;
          }
        });
        function negateValue2(value) {
          value = `${value}`;
          if (value === "0") {
            return "0";
          }
          if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(value)) {
            return value.replace(/^[+-]?/, (sign2) => sign2 === "-" ? "" : "-");
          }
          let numericFunctions = [
            "var",
            "calc",
            "min",
            "max",
            "clamp"
          ];
          for (const fn of numericFunctions) {
            if (value.includes(`${fn}(`)) {
              return `calc(${value} * -1)`;
            }
          }
        }
      })(negateValue);
      return negateValue;
    }
    var corePluginList = {};
    var hasRequiredCorePluginList;
    function requireCorePluginList() {
      if (hasRequiredCorePluginList) return corePluginList;
      hasRequiredCorePluginList = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return _default;
          }
        });
        const _default = [
          "preflight",
          "container",
          "accessibility",
          "pointerEvents",
          "visibility",
          "position",
          "inset",
          "isolation",
          "zIndex",
          "order",
          "gridColumn",
          "gridColumnStart",
          "gridColumnEnd",
          "gridRow",
          "gridRowStart",
          "gridRowEnd",
          "float",
          "clear",
          "margin",
          "boxSizing",
          "lineClamp",
          "display",
          "aspectRatio",
          "size",
          "height",
          "maxHeight",
          "minHeight",
          "width",
          "minWidth",
          "maxWidth",
          "flex",
          "flexShrink",
          "flexGrow",
          "flexBasis",
          "tableLayout",
          "captionSide",
          "borderCollapse",
          "borderSpacing",
          "transformOrigin",
          "translate",
          "rotate",
          "skew",
          "scale",
          "transform",
          "animation",
          "cursor",
          "touchAction",
          "userSelect",
          "resize",
          "scrollSnapType",
          "scrollSnapAlign",
          "scrollSnapStop",
          "scrollMargin",
          "scrollPadding",
          "listStylePosition",
          "listStyleType",
          "listStyleImage",
          "appearance",
          "columns",
          "breakBefore",
          "breakInside",
          "breakAfter",
          "gridAutoColumns",
          "gridAutoFlow",
          "gridAutoRows",
          "gridTemplateColumns",
          "gridTemplateRows",
          "flexDirection",
          "flexWrap",
          "placeContent",
          "placeItems",
          "alignContent",
          "alignItems",
          "justifyContent",
          "justifyItems",
          "gap",
          "space",
          "divideWidth",
          "divideStyle",
          "divideColor",
          "divideOpacity",
          "placeSelf",
          "alignSelf",
          "justifySelf",
          "overflow",
          "overscrollBehavior",
          "scrollBehavior",
          "textOverflow",
          "hyphens",
          "whitespace",
          "textWrap",
          "wordBreak",
          "borderRadius",
          "borderWidth",
          "borderStyle",
          "borderColor",
          "borderOpacity",
          "backgroundColor",
          "backgroundOpacity",
          "backgroundImage",
          "gradientColorStops",
          "boxDecorationBreak",
          "backgroundSize",
          "backgroundAttachment",
          "backgroundClip",
          "backgroundPosition",
          "backgroundRepeat",
          "backgroundOrigin",
          "fill",
          "stroke",
          "strokeWidth",
          "objectFit",
          "objectPosition",
          "padding",
          "textAlign",
          "textIndent",
          "verticalAlign",
          "fontFamily",
          "fontSize",
          "fontWeight",
          "textTransform",
          "fontStyle",
          "fontVariantNumeric",
          "lineHeight",
          "letterSpacing",
          "textColor",
          "textOpacity",
          "textDecoration",
          "textDecorationColor",
          "textDecorationStyle",
          "textDecorationThickness",
          "textUnderlineOffset",
          "fontSmoothing",
          "placeholderColor",
          "placeholderOpacity",
          "caretColor",
          "accentColor",
          "opacity",
          "backgroundBlendMode",
          "mixBlendMode",
          "boxShadow",
          "boxShadowColor",
          "outlineStyle",
          "outlineWidth",
          "outlineOffset",
          "outlineColor",
          "ringWidth",
          "ringColor",
          "ringOpacity",
          "ringOffsetWidth",
          "ringOffsetColor",
          "blur",
          "brightness",
          "contrast",
          "dropShadow",
          "grayscale",
          "hueRotate",
          "invert",
          "saturate",
          "sepia",
          "filter",
          "backdropBlur",
          "backdropBrightness",
          "backdropContrast",
          "backdropGrayscale",
          "backdropHueRotate",
          "backdropInvert",
          "backdropOpacity",
          "backdropSaturate",
          "backdropSepia",
          "backdropFilter",
          "transitionProperty",
          "transitionDelay",
          "transitionDuration",
          "transitionTimingFunction",
          "willChange",
          "contain",
          "content",
          "forcedColorAdjust"
        ];
      })(corePluginList);
      return corePluginList;
    }
    var configurePlugins = {};
    var hasRequiredConfigurePlugins;
    function requireConfigurePlugins() {
      if (hasRequiredConfigurePlugins) return configurePlugins;
      hasRequiredConfigurePlugins = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return _default;
          }
        });
        function _default(pluginConfig, plugins) {
          if (pluginConfig === void 0) {
            return plugins;
          }
          const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [
            ...new Set(plugins.filter((pluginName) => {
              return pluginConfig !== false && pluginConfig[pluginName] !== false;
            }).concat(Object.keys(pluginConfig).filter((pluginName) => {
              return pluginConfig[pluginName] !== false;
            })))
          ];
          return pluginNames;
        }
      })(configurePlugins);
      return configurePlugins;
    }
    var colors = {};
    var log = {};
    var picocolors_browser = { exports: {} };
    var hasRequiredPicocolors_browser;
    function requirePicocolors_browser() {
      if (hasRequiredPicocolors_browser) return picocolors_browser.exports;
      hasRequiredPicocolors_browser = 1;
      var x = String;
      var create = function() {
        return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x, blackBright: x, redBright: x, greenBright: x, yellowBright: x, blueBright: x, magentaBright: x, cyanBright: x, whiteBright: x, bgBlackBright: x, bgRedBright: x, bgGreenBright: x, bgYellowBright: x, bgBlueBright: x, bgMagentaBright: x, bgCyanBright: x, bgWhiteBright: x };
      };
      picocolors_browser.exports = create();
      picocolors_browser.exports.createColors = create;
      return picocolors_browser.exports;
    }
    var hasRequiredLog;
    function requireLog() {
      if (hasRequiredLog) return log;
      hasRequiredLog = 1;
      (function(exports2) {
        var define_process_env_default = {};
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        function _export(target, all) {
          for (var name in all) Object.defineProperty(target, name, {
            enumerable: true,
            get: all[name]
          });
        }
        _export(exports2, {
          dim: function() {
            return dim;
          },
          default: function() {
            return _default;
          }
        });
        const _picocolors = /* @__PURE__ */ _interop_require_default(/* @__PURE__ */ requirePicocolors_browser());
        function _interop_require_default(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        let alreadyShown = /* @__PURE__ */ new Set();
        function log2(type, messages, key) {
          if (typeof process !== "undefined" && define_process_env_default.JEST_WORKER_ID) return;
          if (key && alreadyShown.has(key)) return;
          if (key) alreadyShown.add(key);
          console.warn("");
          messages.forEach((message) => console.warn(type, "-", message));
        }
        function dim(input) {
          return _picocolors.default.dim(input);
        }
        const _default = {
          info(key, messages) {
            log2(_picocolors.default.bold(_picocolors.default.cyan("info")), ...Array.isArray(key) ? [
              key
            ] : [
              messages,
              key
            ]);
          },
          warn(key, messages) {
            log2(_picocolors.default.bold(_picocolors.default.yellow("warn")), ...Array.isArray(key) ? [
              key
            ] : [
              messages,
              key
            ]);
          },
          risk(key, messages) {
            log2(_picocolors.default.bold(_picocolors.default.magenta("risk")), ...Array.isArray(key) ? [
              key
            ] : [
              messages,
              key
            ]);
          }
        };
      })(log);
      return log;
    }
    var hasRequiredColors$1;
    function requireColors$1() {
      if (hasRequiredColors$1) return colors;
      hasRequiredColors$1 = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return _default;
          }
        });
        const _log = /* @__PURE__ */ _interop_require_default(requireLog());
        function _interop_require_default(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function warn2({ version: version2, from: from2, to: to2 }) {
          _log.default.warn(`${from2}-color-renamed`, [
            `As of Tailwind CSS ${version2}, \`${from2}\` has been renamed to \`${to2}\`.`,
            "Update your configuration file to silence this warning."
          ]);
        }
        const _default = {
          inherit: "inherit",
          current: "currentColor",
          transparent: "transparent",
          black: "#000",
          white: "#fff",
          slate: {
            50: "#f8fafc",
            100: "#f1f5f9",
            200: "#e2e8f0",
            300: "#cbd5e1",
            400: "#94a3b8",
            500: "#64748b",
            600: "#475569",
            700: "#334155",
            800: "#1e293b",
            900: "#0f172a",
            950: "#020617"
          },
          gray: {
            50: "#f9fafb",
            100: "#f3f4f6",
            200: "#e5e7eb",
            300: "#d1d5db",
            400: "#9ca3af",
            500: "#6b7280",
            600: "#4b5563",
            700: "#374151",
            800: "#1f2937",
            900: "#111827",
            950: "#030712"
          },
          zinc: {
            50: "#fafafa",
            100: "#f4f4f5",
            200: "#e4e4e7",
            300: "#d4d4d8",
            400: "#a1a1aa",
            500: "#71717a",
            600: "#52525b",
            700: "#3f3f46",
            800: "#27272a",
            900: "#18181b",
            950: "#09090b"
          },
          neutral: {
            50: "#fafafa",
            100: "#f5f5f5",
            200: "#e5e5e5",
            300: "#d4d4d4",
            400: "#a3a3a3",
            500: "#737373",
            600: "#525252",
            700: "#404040",
            800: "#262626",
            900: "#171717",
            950: "#0a0a0a"
          },
          stone: {
            50: "#fafaf9",
            100: "#f5f5f4",
            200: "#e7e5e4",
            300: "#d6d3d1",
            400: "#a8a29e",
            500: "#78716c",
            600: "#57534e",
            700: "#44403c",
            800: "#292524",
            900: "#1c1917",
            950: "#0c0a09"
          },
          red: {
            50: "#fef2f2",
            100: "#fee2e2",
            200: "#fecaca",
            300: "#fca5a5",
            400: "#f87171",
            500: "#ef4444",
            600: "#dc2626",
            700: "#b91c1c",
            800: "#991b1b",
            900: "#7f1d1d",
            950: "#450a0a"
          },
          orange: {
            50: "#fff7ed",
            100: "#ffedd5",
            200: "#fed7aa",
            300: "#fdba74",
            400: "#fb923c",
            500: "#f97316",
            600: "#ea580c",
            700: "#c2410c",
            800: "#9a3412",
            900: "#7c2d12",
            950: "#431407"
          },
          amber: {
            50: "#fffbeb",
            100: "#fef3c7",
            200: "#fde68a",
            300: "#fcd34d",
            400: "#fbbf24",
            500: "#f59e0b",
            600: "#d97706",
            700: "#b45309",
            800: "#92400e",
            900: "#78350f",
            950: "#451a03"
          },
          yellow: {
            50: "#fefce8",
            100: "#fef9c3",
            200: "#fef08a",
            300: "#fde047",
            400: "#facc15",
            500: "#eab308",
            600: "#ca8a04",
            700: "#a16207",
            800: "#854d0e",
            900: "#713f12",
            950: "#422006"
          },
          lime: {
            50: "#f7fee7",
            100: "#ecfccb",
            200: "#d9f99d",
            300: "#bef264",
            400: "#a3e635",
            500: "#84cc16",
            600: "#65a30d",
            700: "#4d7c0f",
            800: "#3f6212",
            900: "#365314",
            950: "#1a2e05"
          },
          green: {
            50: "#f0fdf4",
            100: "#dcfce7",
            200: "#bbf7d0",
            300: "#86efac",
            400: "#4ade80",
            500: "#22c55e",
            600: "#16a34a",
            700: "#15803d",
            800: "#166534",
            900: "#14532d",
            950: "#052e16"
          },
          emerald: {
            50: "#ecfdf5",
            100: "#d1fae5",
            200: "#a7f3d0",
            300: "#6ee7b7",
            400: "#34d399",
            500: "#10b981",
            600: "#059669",
            700: "#047857",
            800: "#065f46",
            900: "#064e3b",
            950: "#022c22"
          },
          teal: {
            50: "#f0fdfa",
            100: "#ccfbf1",
            200: "#99f6e4",
            300: "#5eead4",
            400: "#2dd4bf",
            500: "#14b8a6",
            600: "#0d9488",
            700: "#0f766e",
            800: "#115e59",
            900: "#134e4a",
            950: "#042f2e"
          },
          cyan: {
            50: "#ecfeff",
            100: "#cffafe",
            200: "#a5f3fc",
            300: "#67e8f9",
            400: "#22d3ee",
            500: "#06b6d4",
            600: "#0891b2",
            700: "#0e7490",
            800: "#155e75",
            900: "#164e63",
            950: "#083344"
          },
          sky: {
            50: "#f0f9ff",
            100: "#e0f2fe",
            200: "#bae6fd",
            300: "#7dd3fc",
            400: "#38bdf8",
            500: "#0ea5e9",
            600: "#0284c7",
            700: "#0369a1",
            800: "#075985",
            900: "#0c4a6e",
            950: "#082f49"
          },
          blue: {
            50: "#eff6ff",
            100: "#dbeafe",
            200: "#bfdbfe",
            300: "#93c5fd",
            400: "#60a5fa",
            500: "#3b82f6",
            600: "#2563eb",
            700: "#1d4ed8",
            800: "#1e40af",
            900: "#1e3a8a",
            950: "#172554"
          },
          indigo: {
            50: "#eef2ff",
            100: "#e0e7ff",
            200: "#c7d2fe",
            300: "#a5b4fc",
            400: "#818cf8",
            500: "#6366f1",
            600: "#4f46e5",
            700: "#4338ca",
            800: "#3730a3",
            900: "#312e81",
            950: "#1e1b4b"
          },
          violet: {
            50: "#f5f3ff",
            100: "#ede9fe",
            200: "#ddd6fe",
            300: "#c4b5fd",
            400: "#a78bfa",
            500: "#8b5cf6",
            600: "#7c3aed",
            700: "#6d28d9",
            800: "#5b21b6",
            900: "#4c1d95",
            950: "#2e1065"
          },
          purple: {
            50: "#faf5ff",
            100: "#f3e8ff",
            200: "#e9d5ff",
            300: "#d8b4fe",
            400: "#c084fc",
            500: "#a855f7",
            600: "#9333ea",
            700: "#7e22ce",
            800: "#6b21a8",
            900: "#581c87",
            950: "#3b0764"
          },
          fuchsia: {
            50: "#fdf4ff",
            100: "#fae8ff",
            200: "#f5d0fe",
            300: "#f0abfc",
            400: "#e879f9",
            500: "#d946ef",
            600: "#c026d3",
            700: "#a21caf",
            800: "#86198f",
            900: "#701a75",
            950: "#4a044e"
          },
          pink: {
            50: "#fdf2f8",
            100: "#fce7f3",
            200: "#fbcfe8",
            300: "#f9a8d4",
            400: "#f472b6",
            500: "#ec4899",
            600: "#db2777",
            700: "#be185d",
            800: "#9d174d",
            900: "#831843",
            950: "#500724"
          },
          rose: {
            50: "#fff1f2",
            100: "#ffe4e6",
            200: "#fecdd3",
            300: "#fda4af",
            400: "#fb7185",
            500: "#f43f5e",
            600: "#e11d48",
            700: "#be123c",
            800: "#9f1239",
            900: "#881337",
            950: "#4c0519"
          },
          get lightBlue() {
            warn2({
              version: "v2.2",
              from: "lightBlue",
              to: "sky"
            });
            return this.sky;
          },
          get warmGray() {
            warn2({
              version: "v3.0",
              from: "warmGray",
              to: "stone"
            });
            return this.stone;
          },
          get trueGray() {
            warn2({
              version: "v3.0",
              from: "trueGray",
              to: "neutral"
            });
            return this.neutral;
          },
          get coolGray() {
            warn2({
              version: "v3.0",
              from: "coolGray",
              to: "gray"
            });
            return this.gray;
          },
          get blueGray() {
            warn2({
              version: "v3.0",
              from: "blueGray",
              to: "slate"
            });
            return this.slate;
          }
        };
      })(colors);
      return colors;
    }
    var defaults$1 = {};
    var hasRequiredDefaults;
    function requireDefaults() {
      if (hasRequiredDefaults) return defaults$1;
      hasRequiredDefaults = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "defaults", {
          enumerable: true,
          get: function() {
            return defaults2;
          }
        });
        function defaults2(target, ...sources) {
          for (let source of sources) {
            for (let k in source) {
              var _target_hasOwnProperty;
              if (!(target === null || target === void 0 ? void 0 : (_target_hasOwnProperty = target.hasOwnProperty) === null || _target_hasOwnProperty === void 0 ? void 0 : _target_hasOwnProperty.call(target, k))) {
                target[k] = source[k];
              }
            }
            for (let k of Object.getOwnPropertySymbols(source)) {
              var _target_hasOwnProperty1;
              if (!(target === null || target === void 0 ? void 0 : (_target_hasOwnProperty1 = target.hasOwnProperty) === null || _target_hasOwnProperty1 === void 0 ? void 0 : _target_hasOwnProperty1.call(target, k))) {
                target[k] = source[k];
              }
            }
          }
          return target;
        }
      })(defaults$1);
      return defaults$1;
    }
    var toPath = {};
    var hasRequiredToPath;
    function requireToPath() {
      if (hasRequiredToPath) return toPath;
      hasRequiredToPath = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "toPath", {
          enumerable: true,
          get: function() {
            return toPath2;
          }
        });
        function toPath2(path) {
          if (Array.isArray(path)) return path;
          let openBrackets = path.split("[").length - 1;
          let closedBrackets = path.split("]").length - 1;
          if (openBrackets !== closedBrackets) {
            throw new Error(`Path is invalid. Has unbalanced brackets: ${path}`);
          }
          return path.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
        }
      })(toPath);
      return toPath;
    }
    var normalizeConfig = {};
    var featureFlags = {};
    var hasRequiredFeatureFlags;
    function requireFeatureFlags() {
      if (hasRequiredFeatureFlags) return featureFlags;
      hasRequiredFeatureFlags = 1;
      (function(exports2) {
        var define_process_env_default = {};
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        function _export(target, all) {
          for (var name in all) Object.defineProperty(target, name, {
            enumerable: true,
            get: all[name]
          });
        }
        _export(exports2, {
          flagEnabled: function() {
            return flagEnabled;
          },
          issueFlagNotices: function() {
            return issueFlagNotices;
          },
          default: function() {
            return _default;
          }
        });
        const _picocolors = /* @__PURE__ */ _interop_require_default(/* @__PURE__ */ requirePicocolors_browser());
        const _log = /* @__PURE__ */ _interop_require_default(requireLog());
        function _interop_require_default(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        let defaults2 = {
          optimizeUniversalDefaults: false,
          generalizedModifiers: true,
          disableColorOpacityUtilitiesByDefault: false,
          relativeContentPathsByDefault: false
        };
        let featureFlags2 = {
          future: [
            "hoverOnlyWhenSupported",
            "respectDefaultRingColorOpacity",
            "disableColorOpacityUtilitiesByDefault",
            "relativeContentPathsByDefault"
          ],
          experimental: [
            "optimizeUniversalDefaults",
            "generalizedModifiers"
          ]
        };
        function flagEnabled(config, flag) {
          if (featureFlags2.future.includes(flag)) {
            var _config_future;
            var _config_future_flag, _ref;
            return config.future === "all" || ((_ref = (_config_future_flag = config === null || config === void 0 ? void 0 : (_config_future = config.future) === null || _config_future === void 0 ? void 0 : _config_future[flag]) !== null && _config_future_flag !== void 0 ? _config_future_flag : defaults2[flag]) !== null && _ref !== void 0 ? _ref : false);
          }
          if (featureFlags2.experimental.includes(flag)) {
            var _config_experimental;
            var _config_experimental_flag, _ref1;
            return config.experimental === "all" || ((_ref1 = (_config_experimental_flag = config === null || config === void 0 ? void 0 : (_config_experimental = config.experimental) === null || _config_experimental === void 0 ? void 0 : _config_experimental[flag]) !== null && _config_experimental_flag !== void 0 ? _config_experimental_flag : defaults2[flag]) !== null && _ref1 !== void 0 ? _ref1 : false);
          }
          return false;
        }
        function experimentalFlagsEnabled(config) {
          if (config.experimental === "all") {
            return featureFlags2.experimental;
          }
          var _config_experimental;
          return Object.keys((_config_experimental = config === null || config === void 0 ? void 0 : config.experimental) !== null && _config_experimental !== void 0 ? _config_experimental : {}).filter((flag) => featureFlags2.experimental.includes(flag) && config.experimental[flag]);
        }
        function issueFlagNotices(config) {
          if (define_process_env_default.JEST_WORKER_ID !== void 0) {
            return;
          }
          if (experimentalFlagsEnabled(config).length > 0) {
            let changes = experimentalFlagsEnabled(config).map((s) => _picocolors.default.yellow(s)).join(", ");
            _log.default.warn("experimental-flags-enabled", [
              `You have enabled experimental features: ${changes}`,
              "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
            ]);
          }
        }
        const _default = featureFlags2;
      })(featureFlags);
      return featureFlags;
    }
    var hasRequiredNormalizeConfig;
    function requireNormalizeConfig() {
      if (hasRequiredNormalizeConfig) return normalizeConfig;
      hasRequiredNormalizeConfig = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "normalizeConfig", {
          enumerable: true,
          get: function() {
            return normalizeConfig2;
          }
        });
        const _featureFlags = requireFeatureFlags();
        const _log = /* @__PURE__ */ _interop_require_wildcard(requireLog());
        function _getRequireWildcardCache(nodeInterop) {
          if (typeof WeakMap !== "function") return null;
          var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
          var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
          return (_getRequireWildcardCache = function(nodeInterop2) {
            return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
          })(nodeInterop);
        }
        function _interop_require_wildcard(obj, nodeInterop) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
            return {
              default: obj
            };
          }
          var cache = _getRequireWildcardCache(nodeInterop);
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }
        function normalizeConfig2(config) {
          let valid = (() => {
            if (config.purge) {
              return false;
            }
            if (!config.content) {
              return false;
            }
            if (!Array.isArray(config.content) && !(typeof config.content === "object" && config.content !== null)) {
              return false;
            }
            if (Array.isArray(config.content)) {
              return config.content.every((path) => {
                if (typeof path === "string") return true;
                if (typeof (path === null || path === void 0 ? void 0 : path.raw) !== "string") return false;
                if ((path === null || path === void 0 ? void 0 : path.extension) && typeof (path === null || path === void 0 ? void 0 : path.extension) !== "string") {
                  return false;
                }
                return true;
              });
            }
            if (typeof config.content === "object" && config.content !== null) {
              if (Object.keys(config.content).some((key) => ![
                "files",
                "relative",
                "extract",
                "transform"
              ].includes(key))) {
                return false;
              }
              if (Array.isArray(config.content.files)) {
                if (!config.content.files.every((path) => {
                  if (typeof path === "string") return true;
                  if (typeof (path === null || path === void 0 ? void 0 : path.raw) !== "string") return false;
                  if ((path === null || path === void 0 ? void 0 : path.extension) && typeof (path === null || path === void 0 ? void 0 : path.extension) !== "string") {
                    return false;
                  }
                  return true;
                })) {
                  return false;
                }
                if (typeof config.content.extract === "object") {
                  for (let value of Object.values(config.content.extract)) {
                    if (typeof value !== "function") {
                      return false;
                    }
                  }
                } else if (!(config.content.extract === void 0 || typeof config.content.extract === "function")) {
                  return false;
                }
                if (typeof config.content.transform === "object") {
                  for (let value of Object.values(config.content.transform)) {
                    if (typeof value !== "function") {
                      return false;
                    }
                  }
                } else if (!(config.content.transform === void 0 || typeof config.content.transform === "function")) {
                  return false;
                }
                if (typeof config.content.relative !== "boolean" && typeof config.content.relative !== "undefined") {
                  return false;
                }
              }
              return true;
            }
            return false;
          })();
          if (!valid) {
            _log.default.warn("purge-deprecation", [
              "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
              "Update your configuration file to eliminate this warning.",
              "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
            ]);
          }
          config.safelist = (() => {
            var _purge_options;
            let { content, purge, safelist } = config;
            if (Array.isArray(safelist)) return safelist;
            if (Array.isArray(content === null || content === void 0 ? void 0 : content.safelist)) return content.safelist;
            if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.safelist)) return purge.safelist;
            if (Array.isArray(purge === null || purge === void 0 ? void 0 : (_purge_options = purge.options) === null || _purge_options === void 0 ? void 0 : _purge_options.safelist)) return purge.options.safelist;
            return [];
          })();
          config.blocklist = (() => {
            let { blocklist } = config;
            if (Array.isArray(blocklist)) {
              if (blocklist.every((item) => typeof item === "string")) {
                return blocklist;
              }
              _log.default.warn("blocklist-invalid", [
                "The `blocklist` option must be an array of strings.",
                "https://tailwindcss.com/docs/content-configuration#discarding-classes"
              ]);
            }
            return [];
          })();
          if (typeof config.prefix === "function") {
            _log.default.warn("prefix-function", [
              "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
              "Update `prefix` in your configuration to be a string to eliminate this warning.",
              "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
            ]);
            config.prefix = "";
          } else {
            var _config_prefix;
            config.prefix = (_config_prefix = config.prefix) !== null && _config_prefix !== void 0 ? _config_prefix : "";
          }
          config.content = {
            relative: (() => {
              let { content } = config;
              if (content === null || content === void 0 ? void 0 : content.relative) {
                return content.relative;
              }
              return (0, _featureFlags.flagEnabled)(config, "relativeContentPathsByDefault");
            })(),
            files: (() => {
              let { content, purge } = config;
              if (Array.isArray(purge)) return purge;
              if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.content)) return purge.content;
              if (Array.isArray(content)) return content;
              if (Array.isArray(content === null || content === void 0 ? void 0 : content.content)) return content.content;
              if (Array.isArray(content === null || content === void 0 ? void 0 : content.files)) return content.files;
              return [];
            })(),
            extract: (() => {
              let extract = (() => {
                var _config_purge, _config_content, _config_purge1, _config_purge_extract, _config_content1, _config_content_extract, _config_purge2, _config_purge_options, _config_content2, _config_content_options;
                if ((_config_purge = config.purge) === null || _config_purge === void 0 ? void 0 : _config_purge.extract) return config.purge.extract;
                if ((_config_content = config.content) === null || _config_content === void 0 ? void 0 : _config_content.extract) return config.content.extract;
                if ((_config_purge1 = config.purge) === null || _config_purge1 === void 0 ? void 0 : (_config_purge_extract = _config_purge1.extract) === null || _config_purge_extract === void 0 ? void 0 : _config_purge_extract.DEFAULT) return config.purge.extract.DEFAULT;
                if ((_config_content1 = config.content) === null || _config_content1 === void 0 ? void 0 : (_config_content_extract = _config_content1.extract) === null || _config_content_extract === void 0 ? void 0 : _config_content_extract.DEFAULT) return config.content.extract.DEFAULT;
                if ((_config_purge2 = config.purge) === null || _config_purge2 === void 0 ? void 0 : (_config_purge_options = _config_purge2.options) === null || _config_purge_options === void 0 ? void 0 : _config_purge_options.extractors) return config.purge.options.extractors;
                if ((_config_content2 = config.content) === null || _config_content2 === void 0 ? void 0 : (_config_content_options = _config_content2.options) === null || _config_content_options === void 0 ? void 0 : _config_content_options.extractors) return config.content.options.extractors;
                return {};
              })();
              let extractors = {};
              let defaultExtractor = (() => {
                var _config_purge, _config_purge_options, _config_content, _config_content_options;
                if ((_config_purge = config.purge) === null || _config_purge === void 0 ? void 0 : (_config_purge_options = _config_purge.options) === null || _config_purge_options === void 0 ? void 0 : _config_purge_options.defaultExtractor) {
                  return config.purge.options.defaultExtractor;
                }
                if ((_config_content = config.content) === null || _config_content === void 0 ? void 0 : (_config_content_options = _config_content.options) === null || _config_content_options === void 0 ? void 0 : _config_content_options.defaultExtractor) {
                  return config.content.options.defaultExtractor;
                }
                return void 0;
              })();
              if (defaultExtractor !== void 0) {
                extractors.DEFAULT = defaultExtractor;
              }
              if (typeof extract === "function") {
                extractors.DEFAULT = extract;
              } else if (Array.isArray(extract)) {
                for (let { extensions, extractor } of extract !== null && extract !== void 0 ? extract : []) {
                  for (let extension of extensions) {
                    extractors[extension] = extractor;
                  }
                }
              } else if (typeof extract === "object" && extract !== null) {
                Object.assign(extractors, extract);
              }
              return extractors;
            })(),
            transform: (() => {
              let transform = (() => {
                var _config_purge, _config_content, _config_purge1, _config_purge_transform, _config_content1, _config_content_transform;
                if ((_config_purge = config.purge) === null || _config_purge === void 0 ? void 0 : _config_purge.transform) return config.purge.transform;
                if ((_config_content = config.content) === null || _config_content === void 0 ? void 0 : _config_content.transform) return config.content.transform;
                if ((_config_purge1 = config.purge) === null || _config_purge1 === void 0 ? void 0 : (_config_purge_transform = _config_purge1.transform) === null || _config_purge_transform === void 0 ? void 0 : _config_purge_transform.DEFAULT) return config.purge.transform.DEFAULT;
                if ((_config_content1 = config.content) === null || _config_content1 === void 0 ? void 0 : (_config_content_transform = _config_content1.transform) === null || _config_content_transform === void 0 ? void 0 : _config_content_transform.DEFAULT) return config.content.transform.DEFAULT;
                return {};
              })();
              let transformers = {};
              if (typeof transform === "function") {
                transformers.DEFAULT = transform;
              } else if (typeof transform === "object" && transform !== null) {
                Object.assign(transformers, transform);
              }
              return transformers;
            })()
          };
          for (let file of config.content.files) {
            if (typeof file === "string" && /{([^,]*?)}/g.test(file)) {
              _log.default.warn("invalid-glob-braces", [
                `The glob pattern ${(0, _log.dim)(file)} in your Tailwind CSS configuration is invalid.`,
                `Update it to ${(0, _log.dim)(file.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
              ]);
              break;
            }
          }
          return config;
        }
      })(normalizeConfig);
      return normalizeConfig;
    }
    var isPlainObject = {};
    var hasRequiredIsPlainObject;
    function requireIsPlainObject() {
      if (hasRequiredIsPlainObject) return isPlainObject;
      hasRequiredIsPlainObject = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return isPlainObject2;
          }
        });
        function isPlainObject2(value) {
          if (Object.prototype.toString.call(value) !== "[object Object]") {
            return false;
          }
          const prototype = Object.getPrototypeOf(value);
          return prototype === null || Object.getPrototypeOf(prototype) === null;
        }
      })(isPlainObject);
      return isPlainObject;
    }
    var cloneDeep = {};
    var hasRequiredCloneDeep;
    function requireCloneDeep() {
      if (hasRequiredCloneDeep) return cloneDeep;
      hasRequiredCloneDeep = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "cloneDeep", {
          enumerable: true,
          get: function() {
            return cloneDeep2;
          }
        });
        function cloneDeep2(value) {
          if (Array.isArray(value)) {
            return value.map((child) => cloneDeep2(child));
          }
          if (typeof value === "object" && value !== null) {
            return Object.fromEntries(Object.entries(value).map(([k, v]) => [
              k,
              cloneDeep2(v)
            ]));
          }
          return value;
        }
      })(cloneDeep);
      return cloneDeep;
    }
    var pluginUtils = {};
    var escapeCommas = {};
    var hasRequiredEscapeCommas;
    function requireEscapeCommas() {
      if (hasRequiredEscapeCommas) return escapeCommas;
      hasRequiredEscapeCommas = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return escapeCommas2;
          }
        });
        function escapeCommas2(className) {
          return className.replace(/\\,/g, "\\2c ");
        }
      })(escapeCommas);
      return escapeCommas;
    }
    var withAlphaVariable = {};
    var color = {};
    var colorNames = {};
    var hasRequiredColorNames;
    function requireColorNames() {
      if (hasRequiredColorNames) return colorNames;
      hasRequiredColorNames = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return _default;
          }
        });
        const _default = {
          aliceblue: [
            240,
            248,
            255
          ],
          antiquewhite: [
            250,
            235,
            215
          ],
          aqua: [
            0,
            255,
            255
          ],
          aquamarine: [
            127,
            255,
            212
          ],
          azure: [
            240,
            255,
            255
          ],
          beige: [
            245,
            245,
            220
          ],
          bisque: [
            255,
            228,
            196
          ],
          black: [
            0,
            0,
            0
          ],
          blanchedalmond: [
            255,
            235,
            205
          ],
          blue: [
            0,
            0,
            255
          ],
          blueviolet: [
            138,
            43,
            226
          ],
          brown: [
            165,
            42,
            42
          ],
          burlywood: [
            222,
            184,
            135
          ],
          cadetblue: [
            95,
            158,
            160
          ],
          chartreuse: [
            127,
            255,
            0
          ],
          chocolate: [
            210,
            105,
            30
          ],
          coral: [
            255,
            127,
            80
          ],
          cornflowerblue: [
            100,
            149,
            237
          ],
          cornsilk: [
            255,
            248,
            220
          ],
          crimson: [
            220,
            20,
            60
          ],
          cyan: [
            0,
            255,
            255
          ],
          darkblue: [
            0,
            0,
            139
          ],
          darkcyan: [
            0,
            139,
            139
          ],
          darkgoldenrod: [
            184,
            134,
            11
          ],
          darkgray: [
            169,
            169,
            169
          ],
          darkgreen: [
            0,
            100,
            0
          ],
          darkgrey: [
            169,
            169,
            169
          ],
          darkkhaki: [
            189,
            183,
            107
          ],
          darkmagenta: [
            139,
            0,
            139
          ],
          darkolivegreen: [
            85,
            107,
            47
          ],
          darkorange: [
            255,
            140,
            0
          ],
          darkorchid: [
            153,
            50,
            204
          ],
          darkred: [
            139,
            0,
            0
          ],
          darksalmon: [
            233,
            150,
            122
          ],
          darkseagreen: [
            143,
            188,
            143
          ],
          darkslateblue: [
            72,
            61,
            139
          ],
          darkslategray: [
            47,
            79,
            79
          ],
          darkslategrey: [
            47,
            79,
            79
          ],
          darkturquoise: [
            0,
            206,
            209
          ],
          darkviolet: [
            148,
            0,
            211
          ],
          deeppink: [
            255,
            20,
            147
          ],
          deepskyblue: [
            0,
            191,
            255
          ],
          dimgray: [
            105,
            105,
            105
          ],
          dimgrey: [
            105,
            105,
            105
          ],
          dodgerblue: [
            30,
            144,
            255
          ],
          firebrick: [
            178,
            34,
            34
          ],
          floralwhite: [
            255,
            250,
            240
          ],
          forestgreen: [
            34,
            139,
            34
          ],
          fuchsia: [
            255,
            0,
            255
          ],
          gainsboro: [
            220,
            220,
            220
          ],
          ghostwhite: [
            248,
            248,
            255
          ],
          gold: [
            255,
            215,
            0
          ],
          goldenrod: [
            218,
            165,
            32
          ],
          gray: [
            128,
            128,
            128
          ],
          green: [
            0,
            128,
            0
          ],
          greenyellow: [
            173,
            255,
            47
          ],
          grey: [
            128,
            128,
            128
          ],
          honeydew: [
            240,
            255,
            240
          ],
          hotpink: [
            255,
            105,
            180
          ],
          indianred: [
            205,
            92,
            92
          ],
          indigo: [
            75,
            0,
            130
          ],
          ivory: [
            255,
            255,
            240
          ],
          khaki: [
            240,
            230,
            140
          ],
          lavender: [
            230,
            230,
            250
          ],
          lavenderblush: [
            255,
            240,
            245
          ],
          lawngreen: [
            124,
            252,
            0
          ],
          lemonchiffon: [
            255,
            250,
            205
          ],
          lightblue: [
            173,
            216,
            230
          ],
          lightcoral: [
            240,
            128,
            128
          ],
          lightcyan: [
            224,
            255,
            255
          ],
          lightgoldenrodyellow: [
            250,
            250,
            210
          ],
          lightgray: [
            211,
            211,
            211
          ],
          lightgreen: [
            144,
            238,
            144
          ],
          lightgrey: [
            211,
            211,
            211
          ],
          lightpink: [
            255,
            182,
            193
          ],
          lightsalmon: [
            255,
            160,
            122
          ],
          lightseagreen: [
            32,
            178,
            170
          ],
          lightskyblue: [
            135,
            206,
            250
          ],
          lightslategray: [
            119,
            136,
            153
          ],
          lightslategrey: [
            119,
            136,
            153
          ],
          lightsteelblue: [
            176,
            196,
            222
          ],
          lightyellow: [
            255,
            255,
            224
          ],
          lime: [
            0,
            255,
            0
          ],
          limegreen: [
            50,
            205,
            50
          ],
          linen: [
            250,
            240,
            230
          ],
          magenta: [
            255,
            0,
            255
          ],
          maroon: [
            128,
            0,
            0
          ],
          mediumaquamarine: [
            102,
            205,
            170
          ],
          mediumblue: [
            0,
            0,
            205
          ],
          mediumorchid: [
            186,
            85,
            211
          ],
          mediumpurple: [
            147,
            112,
            219
          ],
          mediumseagreen: [
            60,
            179,
            113
          ],
          mediumslateblue: [
            123,
            104,
            238
          ],
          mediumspringgreen: [
            0,
            250,
            154
          ],
          mediumturquoise: [
            72,
            209,
            204
          ],
          mediumvioletred: [
            199,
            21,
            133
          ],
          midnightblue: [
            25,
            25,
            112
          ],
          mintcream: [
            245,
            255,
            250
          ],
          mistyrose: [
            255,
            228,
            225
          ],
          moccasin: [
            255,
            228,
            181
          ],
          navajowhite: [
            255,
            222,
            173
          ],
          navy: [
            0,
            0,
            128
          ],
          oldlace: [
            253,
            245,
            230
          ],
          olive: [
            128,
            128,
            0
          ],
          olivedrab: [
            107,
            142,
            35
          ],
          orange: [
            255,
            165,
            0
          ],
          orangered: [
            255,
            69,
            0
          ],
          orchid: [
            218,
            112,
            214
          ],
          palegoldenrod: [
            238,
            232,
            170
          ],
          palegreen: [
            152,
            251,
            152
          ],
          paleturquoise: [
            175,
            238,
            238
          ],
          palevioletred: [
            219,
            112,
            147
          ],
          papayawhip: [
            255,
            239,
            213
          ],
          peachpuff: [
            255,
            218,
            185
          ],
          peru: [
            205,
            133,
            63
          ],
          pink: [
            255,
            192,
            203
          ],
          plum: [
            221,
            160,
            221
          ],
          powderblue: [
            176,
            224,
            230
          ],
          purple: [
            128,
            0,
            128
          ],
          rebeccapurple: [
            102,
            51,
            153
          ],
          red: [
            255,
            0,
            0
          ],
          rosybrown: [
            188,
            143,
            143
          ],
          royalblue: [
            65,
            105,
            225
          ],
          saddlebrown: [
            139,
            69,
            19
          ],
          salmon: [
            250,
            128,
            114
          ],
          sandybrown: [
            244,
            164,
            96
          ],
          seagreen: [
            46,
            139,
            87
          ],
          seashell: [
            255,
            245,
            238
          ],
          sienna: [
            160,
            82,
            45
          ],
          silver: [
            192,
            192,
            192
          ],
          skyblue: [
            135,
            206,
            235
          ],
          slateblue: [
            106,
            90,
            205
          ],
          slategray: [
            112,
            128,
            144
          ],
          slategrey: [
            112,
            128,
            144
          ],
          snow: [
            255,
            250,
            250
          ],
          springgreen: [
            0,
            255,
            127
          ],
          steelblue: [
            70,
            130,
            180
          ],
          tan: [
            210,
            180,
            140
          ],
          teal: [
            0,
            128,
            128
          ],
          thistle: [
            216,
            191,
            216
          ],
          tomato: [
            255,
            99,
            71
          ],
          turquoise: [
            64,
            224,
            208
          ],
          violet: [
            238,
            130,
            238
          ],
          wheat: [
            245,
            222,
            179
          ],
          white: [
            255,
            255,
            255
          ],
          whitesmoke: [
            245,
            245,
            245
          ],
          yellow: [
            255,
            255,
            0
          ],
          yellowgreen: [
            154,
            205,
            50
          ]
        };
      })(colorNames);
      return colorNames;
    }
    var hasRequiredColor;
    function requireColor() {
      if (hasRequiredColor) return color;
      hasRequiredColor = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        function _export(target, all) {
          for (var name in all) Object.defineProperty(target, name, {
            enumerable: true,
            get: all[name]
          });
        }
        _export(exports2, {
          parseColor: function() {
            return parseColor;
          },
          formatColor: function() {
            return formatColor;
          }
        });
        const _colorNames = /* @__PURE__ */ _interop_require_default(requireColorNames());
        function _interop_require_default(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        let HEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
        let SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
        let VALUE = /(?:\d+|\d*\.\d+)%?/;
        let SEP = /(?:\s*,\s*|\s+)/;
        let ALPHA_SEP = /\s*[,/]\s*/;
        let CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/;
        let RGB = new RegExp(`^(rgba?)\\(\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`);
        let HSL = new RegExp(`^(hsla?)\\(\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`);
        function parseColor(value, { loose = false } = {}) {
          var _match_, _match__toString;
          if (typeof value !== "string") {
            return null;
          }
          value = value.trim();
          if (value === "transparent") {
            return {
              mode: "rgb",
              color: [
                "0",
                "0",
                "0"
              ],
              alpha: "0"
            };
          }
          if (value in _colorNames.default) {
            return {
              mode: "rgb",
              color: _colorNames.default[value].map((v) => v.toString())
            };
          }
          let hex2 = value.replace(SHORT_HEX, (_, r, g, b, a) => [
            "#",
            r,
            r,
            g,
            g,
            b,
            b,
            a ? a + a : ""
          ].join("")).match(HEX);
          if (hex2 !== null) {
            return {
              mode: "rgb",
              color: [
                parseInt(hex2[1], 16),
                parseInt(hex2[2], 16),
                parseInt(hex2[3], 16)
              ].map((v) => v.toString()),
              alpha: hex2[4] ? (parseInt(hex2[4], 16) / 255).toString() : void 0
            };
          }
          var _value_match;
          let match = (_value_match = value.match(RGB)) !== null && _value_match !== void 0 ? _value_match : value.match(HSL);
          if (match === null) {
            return null;
          }
          let color2 = [
            match[2],
            match[3],
            match[4]
          ].filter(Boolean).map((v) => v.toString());
          if (color2.length === 2 && color2[0].startsWith("var(")) {
            return {
              mode: match[1],
              color: [
                color2[0]
              ],
              alpha: color2[1]
            };
          }
          if (!loose && color2.length !== 3) {
            return null;
          }
          if (color2.length < 3 && !color2.some((part) => /^var\(.*?\)$/.test(part))) {
            return null;
          }
          return {
            mode: match[1],
            color: color2,
            alpha: (_match_ = match[5]) === null || _match_ === void 0 ? void 0 : (_match__toString = _match_.toString) === null || _match__toString === void 0 ? void 0 : _match__toString.call(_match_)
          };
        }
        function formatColor({ mode, color: color2, alpha: alpha2 }) {
          let hasAlpha = alpha2 !== void 0;
          if (mode === "rgba" || mode === "hsla") {
            return `${mode}(${color2.join(", ")}${hasAlpha ? `, ${alpha2}` : ""})`;
          }
          return `${mode}(${color2.join(" ")}${hasAlpha ? ` / ${alpha2}` : ""})`;
        }
      })(color);
      return color;
    }
    var hasRequiredWithAlphaVariable;
    function requireWithAlphaVariable() {
      if (hasRequiredWithAlphaVariable) return withAlphaVariable;
      hasRequiredWithAlphaVariable = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        function _export(target, all) {
          for (var name in all) Object.defineProperty(target, name, {
            enumerable: true,
            get: all[name]
          });
        }
        _export(exports2, {
          withAlphaValue: function() {
            return withAlphaValue;
          },
          default: function() {
            return withAlphaVariable2;
          }
        });
        const _color = requireColor();
        function withAlphaValue(color2, alphaValue, defaultValue) {
          if (typeof color2 === "function") {
            return color2({
              opacityValue: alphaValue
            });
          }
          let parsed = (0, _color.parseColor)(color2, {
            loose: true
          });
          if (parsed === null) {
            return defaultValue;
          }
          return (0, _color.formatColor)({
            ...parsed,
            alpha: alphaValue
          });
        }
        function withAlphaVariable2({ color: color2, property, variable }) {
          let properties = [].concat(property);
          if (typeof color2 === "function") {
            return {
              [variable]: "1",
              ...Object.fromEntries(properties.map((p) => {
                return [
                  p,
                  color2({
                    opacityVariable: variable,
                    opacityValue: `var(${variable}, 1)`
                  })
                ];
              }))
            };
          }
          const parsed = (0, _color.parseColor)(color2);
          if (parsed === null) {
            return Object.fromEntries(properties.map((p) => [
              p,
              color2
            ]));
          }
          if (parsed.alpha !== void 0) {
            return Object.fromEntries(properties.map((p) => [
              p,
              color2
            ]));
          }
          return {
            [variable]: "1",
            ...Object.fromEntries(properties.map((p) => {
              return [
                p,
                (0, _color.formatColor)({
                  ...parsed,
                  alpha: `var(${variable}, 1)`
                })
              ];
            }))
          };
        }
      })(withAlphaVariable);
      return withAlphaVariable;
    }
    var dataTypes = {};
    var parseBoxShadowValue = {};
    var splitAtTopLevelOnly = {};
    var hasRequiredSplitAtTopLevelOnly;
    function requireSplitAtTopLevelOnly() {
      if (hasRequiredSplitAtTopLevelOnly) return splitAtTopLevelOnly;
      hasRequiredSplitAtTopLevelOnly = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "splitAtTopLevelOnly", {
          enumerable: true,
          get: function() {
            return splitAtTopLevelOnly2;
          }
        });
        function splitAtTopLevelOnly2(input, separator) {
          let stack = [];
          let parts = [];
          let lastPos = 0;
          let isEscaped = false;
          for (let idx = 0; idx < input.length; idx++) {
            let char = input[idx];
            if (stack.length === 0 && char === separator[0] && !isEscaped) {
              if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
                parts.push(input.slice(lastPos, idx));
                lastPos = idx + separator.length;
              }
            }
            isEscaped = isEscaped ? false : char === "\\";
            if (char === "(" || char === "[" || char === "{") {
              stack.push(char);
            } else if (char === ")" && stack[stack.length - 1] === "(" || char === "]" && stack[stack.length - 1] === "[" || char === "}" && stack[stack.length - 1] === "{") {
              stack.pop();
            }
          }
          parts.push(input.slice(lastPos));
          return parts;
        }
      })(splitAtTopLevelOnly);
      return splitAtTopLevelOnly;
    }
    var hasRequiredParseBoxShadowValue;
    function requireParseBoxShadowValue() {
      if (hasRequiredParseBoxShadowValue) return parseBoxShadowValue;
      hasRequiredParseBoxShadowValue = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        function _export(target, all) {
          for (var name in all) Object.defineProperty(target, name, {
            enumerable: true,
            get: all[name]
          });
        }
        _export(exports2, {
          parseBoxShadowValue: function() {
            return parseBoxShadowValue2;
          },
          formatBoxShadowValue: function() {
            return formatBoxShadowValue;
          }
        });
        const _splitAtTopLevelOnly = requireSplitAtTopLevelOnly();
        let KEYWORDS = /* @__PURE__ */ new Set([
          "inset",
          "inherit",
          "initial",
          "revert",
          "unset"
        ]);
        let SPACE = /\ +(?![^(]*\))/g;
        let LENGTH = /^-?(\d+|\.\d+)(.*?)$/g;
        function parseBoxShadowValue2(input) {
          let shadows = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, ",");
          return shadows.map((shadow) => {
            let value = shadow.trim();
            let result = {
              raw: value
            };
            let parts = value.split(SPACE);
            let seen = /* @__PURE__ */ new Set();
            for (let part of parts) {
              LENGTH.lastIndex = 0;
              if (!seen.has("KEYWORD") && KEYWORDS.has(part)) {
                result.keyword = part;
                seen.add("KEYWORD");
              } else if (LENGTH.test(part)) {
                if (!seen.has("X")) {
                  result.x = part;
                  seen.add("X");
                } else if (!seen.has("Y")) {
                  result.y = part;
                  seen.add("Y");
                } else if (!seen.has("BLUR")) {
                  result.blur = part;
                  seen.add("BLUR");
                } else if (!seen.has("SPREAD")) {
                  result.spread = part;
                  seen.add("SPREAD");
                }
              } else {
                if (!result.color) {
                  result.color = part;
                } else {
                  if (!result.unknown) result.unknown = [];
                  result.unknown.push(part);
                }
              }
            }
            result.valid = result.x !== void 0 && result.y !== void 0;
            return result;
          });
        }
        function formatBoxShadowValue(shadows) {
          return shadows.map((shadow) => {
            if (!shadow.valid) {
              return shadow.raw;
            }
            return [
              shadow.keyword,
              shadow.x,
              shadow.y,
              shadow.blur,
              shadow.spread,
              shadow.color
            ].filter(Boolean).join(" ");
          }).join(", ");
        }
      })(parseBoxShadowValue);
      return parseBoxShadowValue;
    }
    var hasRequiredDataTypes;
    function requireDataTypes() {
      if (hasRequiredDataTypes) return dataTypes;
      hasRequiredDataTypes = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        function _export(target, all) {
          for (var name in all) Object.defineProperty(target, name, {
            enumerable: true,
            get: all[name]
          });
        }
        _export(exports2, {
          normalize: function() {
            return normalize;
          },
          normalizeAttributeSelectors: function() {
            return normalizeAttributeSelectors;
          },
          url: function() {
            return url;
          },
          number: function() {
            return number;
          },
          percentage: function() {
            return percentage;
          },
          length: function() {
            return length;
          },
          lineWidth: function() {
            return lineWidth;
          },
          shadow: function() {
            return shadow;
          },
          color: function() {
            return color2;
          },
          image: function() {
            return image;
          },
          gradient: function() {
            return gradient;
          },
          position: function() {
            return position;
          },
          familyName: function() {
            return familyName;
          },
          genericName: function() {
            return genericName;
          },
          absoluteSize: function() {
            return absoluteSize;
          },
          relativeSize: function() {
            return relativeSize;
          }
        });
        const _color = requireColor();
        const _parseBoxShadowValue = requireParseBoxShadowValue();
        const _splitAtTopLevelOnly = requireSplitAtTopLevelOnly();
        let cssFunctions = [
          "min",
          "max",
          "clamp",
          "calc"
        ];
        function isCSSFunction(value) {
          return cssFunctions.some((fn) => new RegExp(`^${fn}\\(.*\\)`).test(value));
        }
        const AUTO_VAR_INJECTION_EXCEPTIONS = /* @__PURE__ */ new Set([
          // Concrete properties
          "scroll-timeline-name",
          "timeline-scope",
          "view-timeline-name",
          "font-palette",
          "anchor-name",
          "anchor-scope",
          "position-anchor",
          "position-try-options",
          // Shorthand properties
          "scroll-timeline",
          "animation-timeline",
          "view-timeline",
          "position-try"
        ]);
        function normalize(value, context = null, isRoot = true) {
          let isVarException = context && AUTO_VAR_INJECTION_EXCEPTIONS.has(context.property);
          if (value.startsWith("--") && !isVarException) {
            return `var(${value})`;
          }
          if (value.includes("url(")) {
            return value.split(/(url\(.*?\))/g).filter(Boolean).map((part) => {
              if (/^url\(.*?\)$/.test(part)) {
                return part;
              }
              return normalize(part, context, false);
            }).join("");
          }
          value = value.replace(/([^\\])_+/g, (fullMatch, characterBefore) => characterBefore + " ".repeat(fullMatch.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_");
          if (isRoot) {
            value = value.trim();
          }
          value = normalizeMathOperatorSpacing(value);
          return value;
        }
        function normalizeAttributeSelectors(value) {
          if (value.includes("=")) {
            value = value.replace(/(=.*)/g, (_fullMatch, match) => {
              if (match[1] === "'" || match[1] === '"') {
                return match;
              }
              if (match.length > 2) {
                let trailingCharacter = match[match.length - 1];
                if (match[match.length - 2] === " " && (trailingCharacter === "i" || trailingCharacter === "I" || trailingCharacter === "s" || trailingCharacter === "S")) {
                  return `="${match.slice(1, -2)}" ${match[match.length - 1]}`;
                }
              }
              return `="${match.slice(1)}"`;
            });
          }
          return value;
        }
        function normalizeMathOperatorSpacing(value) {
          let preventFormattingInFunctions = [
            "theme"
          ];
          let preventFormattingKeywords = [
            "min-content",
            "max-content",
            "fit-content",
            // Env
            "safe-area-inset-top",
            "safe-area-inset-right",
            "safe-area-inset-bottom",
            "safe-area-inset-left",
            "titlebar-area-x",
            "titlebar-area-y",
            "titlebar-area-width",
            "titlebar-area-height",
            "keyboard-inset-top",
            "keyboard-inset-right",
            "keyboard-inset-bottom",
            "keyboard-inset-left",
            "keyboard-inset-width",
            "keyboard-inset-height",
            "radial-gradient",
            "linear-gradient",
            "conic-gradient",
            "repeating-radial-gradient",
            "repeating-linear-gradient",
            "repeating-conic-gradient",
            "anchor-size"
          ];
          return value.replace(/(calc|min|max|clamp)\(.+\)/g, (match) => {
            let result = "";
            function lastChar() {
              let char = result.trimEnd();
              return char[char.length - 1];
            }
            for (let i = 0; i < match.length; i++) {
              let peek = function(word) {
                return word.split("").every((char2, j) => match[i + j] === char2);
              }, consumeUntil = function(chars) {
                let minIndex = Infinity;
                for (let char2 of chars) {
                  let index2 = match.indexOf(char2, i);
                  if (index2 !== -1 && index2 < minIndex) {
                    minIndex = index2;
                  }
                }
                let result2 = match.slice(i, minIndex);
                i += result2.length - 1;
                return result2;
              };
              let char = match[i];
              if (peek("var")) {
                result += consumeUntil([
                  ")",
                  ","
                ]);
              } else if (preventFormattingKeywords.some((keyword) => peek(keyword))) {
                let keyword = preventFormattingKeywords.find((keyword2) => peek(keyword2));
                result += keyword;
                i += keyword.length - 1;
              } else if (preventFormattingInFunctions.some((fn) => peek(fn))) {
                result += consumeUntil([
                  ")"
                ]);
              } else if (peek("[")) {
                result += consumeUntil([
                  "]"
                ]);
              } else if ([
                "+",
                "-",
                "*",
                "/"
              ].includes(char) && ![
                "(",
                "+",
                "-",
                "*",
                "/",
                ","
              ].includes(lastChar())) {
                result += ` ${char} `;
              } else {
                result += char;
              }
            }
            return result.replace(/\s+/g, " ");
          });
        }
        function url(value) {
          return value.startsWith("url(");
        }
        function number(value) {
          return !isNaN(Number(value)) || isCSSFunction(value);
        }
        function percentage(value) {
          return value.endsWith("%") && number(value.slice(0, -1)) || isCSSFunction(value);
        }
        let lengthUnits = [
          "cm",
          "mm",
          "Q",
          "in",
          "pc",
          "pt",
          "px",
          "em",
          "ex",
          "ch",
          "rem",
          "lh",
          "rlh",
          "vw",
          "vh",
          "vmin",
          "vmax",
          "vb",
          "vi",
          "svw",
          "svh",
          "lvw",
          "lvh",
          "dvw",
          "dvh",
          "cqw",
          "cqh",
          "cqi",
          "cqb",
          "cqmin",
          "cqmax"
        ];
        let lengthUnitsPattern = `(?:${lengthUnits.join("|")})`;
        function length(value) {
          return value === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`).test(value) || isCSSFunction(value);
        }
        let lineWidths = /* @__PURE__ */ new Set([
          "thin",
          "medium",
          "thick"
        ]);
        function lineWidth(value) {
          return lineWidths.has(value);
        }
        function shadow(value) {
          let parsedShadows = (0, _parseBoxShadowValue.parseBoxShadowValue)(normalize(value));
          for (let parsedShadow of parsedShadows) {
            if (!parsedShadow.valid) {
              return false;
            }
          }
          return true;
        }
        function color2(value) {
          let colors2 = 0;
          let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, "_").every((part) => {
            part = normalize(part);
            if (part.startsWith("var(")) return true;
            if ((0, _color.parseColor)(part, {
              loose: true
            }) !== null) return colors2++, true;
            return false;
          });
          if (!result) return false;
          return colors2 > 0;
        }
        function image(value) {
          let images = 0;
          let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part) => {
            part = normalize(part);
            if (part.startsWith("var(")) return true;
            if (url(part) || gradient(part) || [
              "element(",
              "image(",
              "cross-fade(",
              "image-set("
            ].some((fn) => part.startsWith(fn))) {
              images++;
              return true;
            }
            return false;
          });
          if (!result) return false;
          return images > 0;
        }
        let gradientTypes = /* @__PURE__ */ new Set([
          "conic-gradient",
          "linear-gradient",
          "radial-gradient",
          "repeating-conic-gradient",
          "repeating-linear-gradient",
          "repeating-radial-gradient"
        ]);
        function gradient(value) {
          value = normalize(value);
          for (let type of gradientTypes) {
            if (value.startsWith(`${type}(`)) {
              return true;
            }
          }
          return false;
        }
        let validPositions = /* @__PURE__ */ new Set([
          "center",
          "top",
          "right",
          "bottom",
          "left"
        ]);
        function position(value) {
          let positions2 = 0;
          let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, "_").every((part) => {
            part = normalize(part);
            if (part.startsWith("var(")) return true;
            if (validPositions.has(part) || length(part) || percentage(part)) {
              positions2++;
              return true;
            }
            return false;
          });
          if (!result) return false;
          return positions2 > 0;
        }
        function familyName(value) {
          let fonts = 0;
          let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part) => {
            part = normalize(part);
            if (part.startsWith("var(")) return true;
            if (part.includes(" ")) {
              if (!/(['"])([^"']+)\1/g.test(part)) {
                return false;
              }
            }
            if (/^\d/g.test(part)) {
              return false;
            }
            fonts++;
            return true;
          });
          if (!result) return false;
          return fonts > 0;
        }
        let genericNames = /* @__PURE__ */ new Set([
          "serif",
          "sans-serif",
          "monospace",
          "cursive",
          "fantasy",
          "system-ui",
          "ui-serif",
          "ui-sans-serif",
          "ui-monospace",
          "ui-rounded",
          "math",
          "emoji",
          "fangsong"
        ]);
        function genericName(value) {
          return genericNames.has(value);
        }
        let absoluteSizes = /* @__PURE__ */ new Set([
          "xx-small",
          "x-small",
          "small",
          "medium",
          "large",
          "x-large",
          "xx-large",
          "xxx-large"
        ]);
        function absoluteSize(value) {
          return absoluteSizes.has(value);
        }
        let relativeSizes = /* @__PURE__ */ new Set([
          "larger",
          "smaller"
        ]);
        function relativeSize(value) {
          return relativeSizes.has(value);
        }
      })(dataTypes);
      return dataTypes;
    }
    var validateFormalSyntax = {};
    var hasRequiredValidateFormalSyntax;
    function requireValidateFormalSyntax() {
      if (hasRequiredValidateFormalSyntax) return validateFormalSyntax;
      hasRequiredValidateFormalSyntax = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "backgroundSize", {
          enumerable: true,
          get: function() {
            return backgroundSize;
          }
        });
        const _dataTypes = requireDataTypes();
        const _splitAtTopLevelOnly = requireSplitAtTopLevelOnly();
        function backgroundSize(value) {
          let keywordValues = [
            "cover",
            "contain"
          ];
          return (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part) => {
            let sizes = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(part, "_").filter(Boolean);
            if (sizes.length === 1 && keywordValues.includes(sizes[0])) return true;
            if (sizes.length !== 1 && sizes.length !== 2) return false;
            return sizes.every((size) => (0, _dataTypes.length)(size) || (0, _dataTypes.percentage)(size) || size === "auto");
          });
        }
      })(validateFormalSyntax);
      return validateFormalSyntax;
    }
    var hasRequiredPluginUtils;
    function requirePluginUtils() {
      if (hasRequiredPluginUtils) return pluginUtils;
      hasRequiredPluginUtils = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        function _export(target, all) {
          for (var name in all) Object.defineProperty(target, name, {
            enumerable: true,
            get: all[name]
          });
        }
        _export(exports2, {
          updateAllClasses: function() {
            return updateAllClasses;
          },
          asValue: function() {
            return asValue;
          },
          parseColorFormat: function() {
            return parseColorFormat;
          },
          asColor: function() {
            return asColor;
          },
          asLookupValue: function() {
            return asLookupValue;
          },
          typeMap: function() {
            return typeMap;
          },
          coerceValue: function() {
            return coerceValue;
          },
          getMatchingTypes: function() {
            return getMatchingTypes;
          }
        });
        const _escapeCommas = /* @__PURE__ */ _interop_require_default(requireEscapeCommas());
        const _withAlphaVariable = requireWithAlphaVariable();
        const _dataTypes = requireDataTypes();
        const _negateValue = /* @__PURE__ */ _interop_require_default(requireNegateValue());
        const _validateFormalSyntax = requireValidateFormalSyntax();
        const _featureFlags = requireFeatureFlags();
        function _interop_require_default(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function updateAllClasses(selectors, updateClass) {
          selectors.walkClasses((sel) => {
            sel.value = updateClass(sel.value);
            if (sel.raws && sel.raws.value) {
              sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);
            }
          });
        }
        function resolveArbitraryValue(modifier, validate) {
          if (!isArbitraryValue(modifier)) {
            return void 0;
          }
          let value = modifier.slice(1, -1);
          if (!validate(value)) {
            return void 0;
          }
          return (0, _dataTypes.normalize)(value);
        }
        function asNegativeValue(modifier, lookup = {}, validate) {
          let positiveValue = lookup[modifier];
          if (positiveValue !== void 0) {
            return (0, _negateValue.default)(positiveValue);
          }
          if (isArbitraryValue(modifier)) {
            let resolved = resolveArbitraryValue(modifier, validate);
            if (resolved === void 0) {
              return void 0;
            }
            return (0, _negateValue.default)(resolved);
          }
        }
        function asValue(modifier, options = {}, { validate = () => true } = {}) {
          var _options_values;
          let value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];
          if (value !== void 0) {
            return value;
          }
          if (options.supportsNegativeValues && modifier.startsWith("-")) {
            return asNegativeValue(modifier.slice(1), options.values, validate);
          }
          return resolveArbitraryValue(modifier, validate);
        }
        function isArbitraryValue(input) {
          return input.startsWith("[") && input.endsWith("]");
        }
        function splitUtilityModifier(modifier) {
          let slashIdx = modifier.lastIndexOf("/");
          let arbitraryStartIdx = modifier.lastIndexOf("[", slashIdx);
          let arbitraryEndIdx = modifier.indexOf("]", slashIdx);
          let isNextToArbitrary = modifier[slashIdx - 1] === "]" || modifier[slashIdx + 1] === "[";
          if (!isNextToArbitrary) {
            if (arbitraryStartIdx !== -1 && arbitraryEndIdx !== -1) {
              if (arbitraryStartIdx < slashIdx && slashIdx < arbitraryEndIdx) {
                slashIdx = modifier.lastIndexOf("/", arbitraryStartIdx);
              }
            }
          }
          if (slashIdx === -1 || slashIdx === modifier.length - 1) {
            return [
              modifier,
              void 0
            ];
          }
          let arbitrary = isArbitraryValue(modifier);
          if (arbitrary && !modifier.includes("]/[")) {
            return [
              modifier,
              void 0
            ];
          }
          return [
            modifier.slice(0, slashIdx),
            modifier.slice(slashIdx + 1)
          ];
        }
        function parseColorFormat(value) {
          if (typeof value === "string" && value.includes("<alpha-value>")) {
            let oldValue = value;
            return ({ opacityValue = 1 }) => oldValue.replace(/<alpha-value>/g, opacityValue);
          }
          return value;
        }
        function unwrapArbitraryModifier(modifier) {
          return (0, _dataTypes.normalize)(modifier.slice(1, -1));
        }
        function asColor(modifier, options = {}, { tailwindConfig: tailwindConfig2 = {} } = {}) {
          var _options_values;
          if (((_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier]) !== void 0) {
            var _options_values1;
            return parseColorFormat((_options_values1 = options.values) === null || _options_values1 === void 0 ? void 0 : _options_values1[modifier]);
          }
          let [color2, alpha2] = splitUtilityModifier(modifier);
          if (alpha2 !== void 0) {
            var _options_values2, _tailwindConfig_theme, _tailwindConfig_theme_opacity;
            var _options_values_color;
            let normalizedColor = (_options_values_color = (_options_values2 = options.values) === null || _options_values2 === void 0 ? void 0 : _options_values2[color2]) !== null && _options_values_color !== void 0 ? _options_values_color : isArbitraryValue(color2) ? color2.slice(1, -1) : void 0;
            if (normalizedColor === void 0) {
              return void 0;
            }
            normalizedColor = parseColorFormat(normalizedColor);
            if (isArbitraryValue(alpha2)) {
              return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, unwrapArbitraryModifier(alpha2));
            }
            if (((_tailwindConfig_theme = tailwindConfig2.theme) === null || _tailwindConfig_theme === void 0 ? void 0 : (_tailwindConfig_theme_opacity = _tailwindConfig_theme.opacity) === null || _tailwindConfig_theme_opacity === void 0 ? void 0 : _tailwindConfig_theme_opacity[alpha2]) === void 0) {
              return void 0;
            }
            return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig2.theme.opacity[alpha2]);
          }
          return asValue(modifier, options, {
            validate: _dataTypes.color
          });
        }
        function asLookupValue(modifier, options = {}) {
          var _options_values;
          return (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];
        }
        function guess(validate) {
          return (modifier, options) => {
            return asValue(modifier, options, {
              validate
            });
          };
        }
        let typeMap = {
          any: asValue,
          color: asColor,
          url: guess(_dataTypes.url),
          image: guess(_dataTypes.image),
          length: guess(_dataTypes.length),
          percentage: guess(_dataTypes.percentage),
          position: guess(_dataTypes.position),
          lookup: asLookupValue,
          "generic-name": guess(_dataTypes.genericName),
          "family-name": guess(_dataTypes.familyName),
          number: guess(_dataTypes.number),
          "line-width": guess(_dataTypes.lineWidth),
          "absolute-size": guess(_dataTypes.absoluteSize),
          "relative-size": guess(_dataTypes.relativeSize),
          shadow: guess(_dataTypes.shadow),
          size: guess(_validateFormalSyntax.backgroundSize)
        };
        let supportedTypes = Object.keys(typeMap);
        function splitAtFirst(input, delim) {
          let idx = input.indexOf(delim);
          if (idx === -1) return [
            void 0,
            input
          ];
          return [
            input.slice(0, idx),
            input.slice(idx + 1)
          ];
        }
        function coerceValue(types, modifier, options, tailwindConfig2) {
          if (options.values && modifier in options.values) {
            for (let { type } of types !== null && types !== void 0 ? types : []) {
              let result = typeMap[type](modifier, options, {
                tailwindConfig: tailwindConfig2
              });
              if (result === void 0) {
                continue;
              }
              return [
                result,
                type,
                null
              ];
            }
          }
          if (isArbitraryValue(modifier)) {
            let arbitraryValue = modifier.slice(1, -1);
            let [explicitType, value] = splitAtFirst(arbitraryValue, ":");
            if (!/^[\w-_]+$/g.test(explicitType)) {
              value = arbitraryValue;
            } else if (explicitType !== void 0 && !supportedTypes.includes(explicitType)) {
              return [];
            }
            if (value.length > 0 && supportedTypes.includes(explicitType)) {
              return [
                asValue(`[${value}]`, options),
                explicitType,
                null
              ];
            }
          }
          let matches = getMatchingTypes(types, modifier, options, tailwindConfig2);
          for (let match of matches) {
            return match;
          }
          return [];
        }
        function* getMatchingTypes(types, rawModifier, options, tailwindConfig2) {
          let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig2, "generalizedModifiers");
          let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);
          let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === "any" || typeof options.modifiers === "object" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));
          if (!canUseUtilityModifier) {
            modifier = rawModifier;
            utilityModifier = void 0;
          }
          if (utilityModifier !== void 0 && modifier === "") {
            modifier = "DEFAULT";
          }
          if (utilityModifier !== void 0) {
            if (typeof options.modifiers === "object") {
              var _options_modifiers;
              var _options_modifiers_utilityModifier;
              let configValue = (_options_modifiers_utilityModifier = (_options_modifiers = options.modifiers) === null || _options_modifiers === void 0 ? void 0 : _options_modifiers[utilityModifier]) !== null && _options_modifiers_utilityModifier !== void 0 ? _options_modifiers_utilityModifier : null;
              if (configValue !== null) {
                utilityModifier = configValue;
              } else if (isArbitraryValue(utilityModifier)) {
                utilityModifier = unwrapArbitraryModifier(utilityModifier);
              }
            }
          }
          for (let { type } of types !== null && types !== void 0 ? types : []) {
            let result = typeMap[type](modifier, options, {
              tailwindConfig: tailwindConfig2
            });
            if (result === void 0) {
              continue;
            }
            yield [
              result,
              type,
              utilityModifier !== null && utilityModifier !== void 0 ? utilityModifier : null
            ];
          }
        }
      })(pluginUtils);
      return pluginUtils;
    }
    var toColorValue = {};
    var hasRequiredToColorValue;
    function requireToColorValue() {
      if (hasRequiredToColorValue) return toColorValue;
      hasRequiredToColorValue = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return toColorValue2;
          }
        });
        function toColorValue2(maybeFunction) {
          return typeof maybeFunction === "function" ? maybeFunction({}) : maybeFunction;
        }
      })(toColorValue);
      return toColorValue;
    }
    var hasRequiredResolveConfig$2;
    function requireResolveConfig$2() {
      if (hasRequiredResolveConfig$2) return resolveConfig$1;
      hasRequiredResolveConfig$2 = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return resolveConfig2;
          }
        });
        const _negateValue = /* @__PURE__ */ _interop_require_default(requireNegateValue());
        const _corePluginList = /* @__PURE__ */ _interop_require_default(requireCorePluginList());
        const _configurePlugins = /* @__PURE__ */ _interop_require_default(requireConfigurePlugins());
        const _colors = /* @__PURE__ */ _interop_require_default(requireColors$1());
        const _defaults = requireDefaults();
        const _toPath = requireToPath();
        const _normalizeConfig = requireNormalizeConfig();
        const _isPlainObject = /* @__PURE__ */ _interop_require_default(requireIsPlainObject());
        const _cloneDeep = requireCloneDeep();
        const _pluginUtils = requirePluginUtils();
        const _withAlphaVariable = requireWithAlphaVariable();
        const _toColorValue = /* @__PURE__ */ _interop_require_default(requireToColorValue());
        function _interop_require_default(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function isFunction2(input) {
          return typeof input === "function";
        }
        function mergeWith(target, ...sources) {
          let customizer = sources.pop();
          for (let source of sources) {
            for (let k in source) {
              let merged = customizer(target[k], source[k]);
              if (merged === void 0) {
                if ((0, _isPlainObject.default)(target[k]) && (0, _isPlainObject.default)(source[k])) {
                  target[k] = mergeWith({}, target[k], source[k], customizer);
                } else {
                  target[k] = source[k];
                }
              } else {
                target[k] = merged;
              }
            }
          }
          return target;
        }
        const configUtils = {
          colors: _colors.default,
          negative(scale) {
            return Object.keys(scale).filter((key) => scale[key] !== "0").reduce((negativeScale, key) => {
              let negativeValue = (0, _negateValue.default)(scale[key]);
              if (negativeValue !== void 0) {
                negativeScale[`-${key}`] = negativeValue;
              }
              return negativeScale;
            }, {});
          },
          breakpoints(screens) {
            return Object.keys(screens).filter((key) => typeof screens[key] === "string").reduce((breakpoints, key) => ({
              ...breakpoints,
              [`screen-${key}`]: screens[key]
            }), {});
          }
        };
        function value(valueToResolve, ...args) {
          return isFunction2(valueToResolve) ? valueToResolve(...args) : valueToResolve;
        }
        function collectExtends(items) {
          return items.reduce((merged, { extend: extend2 }) => {
            return mergeWith(merged, extend2, (mergedValue, extendValue) => {
              if (mergedValue === void 0) {
                return [
                  extendValue
                ];
              }
              if (Array.isArray(mergedValue)) {
                return [
                  extendValue,
                  ...mergedValue
                ];
              }
              return [
                extendValue,
                mergedValue
              ];
            });
          }, {});
        }
        function mergeThemes(themes) {
          return {
            ...themes.reduce((merged, theme) => (0, _defaults.defaults)(merged, theme), {}),
            // In order to resolve n config objects, we combine all of their `extend` properties
            // into arrays instead of objects so they aren't overridden.
            extend: collectExtends(themes)
          };
        }
        function mergeExtensionCustomizer(merged, value2) {
          if (Array.isArray(merged) && (0, _isPlainObject.default)(merged[0])) {
            return merged.concat(value2);
          }
          if (Array.isArray(value2) && (0, _isPlainObject.default)(value2[0]) && (0, _isPlainObject.default)(merged)) {
            return [
              merged,
              ...value2
            ];
          }
          if (Array.isArray(value2)) {
            return value2;
          }
          return void 0;
        }
        function mergeExtensions({ extend: extend2, ...theme }) {
          return mergeWith(theme, extend2, (themeValue, extensions) => {
            if (!isFunction2(themeValue) && !extensions.some(isFunction2)) {
              return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);
            }
            return (resolveThemePath, utils) => mergeWith({}, ...[
              themeValue,
              ...extensions
            ].map((e) => value(e, resolveThemePath, utils)), mergeExtensionCustomizer);
          });
        }
        function* toPaths(key) {
          let path = (0, _toPath.toPath)(key);
          if (path.length === 0) {
            return;
          }
          yield path;
          if (Array.isArray(key)) {
            return;
          }
          let pattern = /^(.*?)\s*\/\s*([^/]+)$/;
          let matches = key.match(pattern);
          if (matches !== null) {
            let [, prefix, alpha2] = matches;
            let newPath = (0, _toPath.toPath)(prefix);
            newPath.alpha = alpha2;
            yield newPath;
          }
        }
        function resolveFunctionKeys(object) {
          const resolvePath = (key, defaultValue) => {
            for (const path of toPaths(key)) {
              let index2 = 0;
              let val = object;
              while (val !== void 0 && val !== null && index2 < path.length) {
                val = val[path[index2++]];
                let shouldResolveAsFn = isFunction2(val) && (path.alpha === void 0 || index2 <= path.length - 1);
                val = shouldResolveAsFn ? val(resolvePath, configUtils) : val;
              }
              if (val !== void 0) {
                if (path.alpha !== void 0) {
                  let normalized = (0, _pluginUtils.parseColorFormat)(val);
                  return (0, _withAlphaVariable.withAlphaValue)(normalized, path.alpha, (0, _toColorValue.default)(normalized));
                }
                if ((0, _isPlainObject.default)(val)) {
                  return (0, _cloneDeep.cloneDeep)(val);
                }
                return val;
              }
            }
            return defaultValue;
          };
          Object.assign(resolvePath, {
            theme: resolvePath,
            ...configUtils
          });
          return Object.keys(object).reduce((resolved, key) => {
            resolved[key] = isFunction2(object[key]) ? object[key](resolvePath, configUtils) : object[key];
            return resolved;
          }, {});
        }
        function extractPluginConfigs(configs) {
          let allConfigs = [];
          configs.forEach((config) => {
            allConfigs = [
              ...allConfigs,
              config
            ];
            var _config_plugins;
            const plugins = (_config_plugins = config === null || config === void 0 ? void 0 : config.plugins) !== null && _config_plugins !== void 0 ? _config_plugins : [];
            if (plugins.length === 0) {
              return;
            }
            plugins.forEach((plugin2) => {
              if (plugin2.__isOptionsFunction) {
                plugin2 = plugin2();
              }
              var _plugin_config;
              allConfigs = [
                ...allConfigs,
                ...extractPluginConfigs([
                  (_plugin_config = plugin2 === null || plugin2 === void 0 ? void 0 : plugin2.config) !== null && _plugin_config !== void 0 ? _plugin_config : {}
                ])
              ];
            });
          });
          return allConfigs;
        }
        function resolveCorePlugins(corePluginConfigs) {
          const result = [
            ...corePluginConfigs
          ].reduceRight((resolved, corePluginConfig) => {
            if (isFunction2(corePluginConfig)) {
              return corePluginConfig({
                corePlugins: resolved
              });
            }
            return (0, _configurePlugins.default)(corePluginConfig, resolved);
          }, _corePluginList.default);
          return result;
        }
        function resolvePluginLists(pluginLists) {
          const result = [
            ...pluginLists
          ].reduceRight((resolved, pluginList) => {
            return [
              ...resolved,
              ...pluginList
            ];
          }, []);
          return result;
        }
        function resolveConfig2(configs) {
          let allConfigs = [
            ...extractPluginConfigs(configs),
            {
              prefix: "",
              important: false,
              separator: ":"
            }
          ];
          var _t_theme, _c_plugins;
          return (0, _normalizeConfig.normalizeConfig)((0, _defaults.defaults)({
            theme: resolveFunctionKeys(mergeExtensions(mergeThemes(allConfigs.map((t) => {
              return (_t_theme = t === null || t === void 0 ? void 0 : t.theme) !== null && _t_theme !== void 0 ? _t_theme : {};
            })))),
            corePlugins: resolveCorePlugins(allConfigs.map((c) => c.corePlugins)),
            plugins: resolvePluginLists(configs.map((c) => {
              return (_c_plugins = c === null || c === void 0 ? void 0 : c.plugins) !== null && _c_plugins !== void 0 ? _c_plugins : [];
            }))
          }, ...allConfigs));
        }
      })(resolveConfig$1);
      return resolveConfig$1;
    }
    var getAllConfigs = {};
    var config_full;
    var hasRequiredConfig_full;
    function requireConfig_full() {
      if (hasRequiredConfig_full) return config_full;
      hasRequiredConfig_full = 1;
      config_full = {
        content: [],
        presets: [],
        darkMode: "media",
        // or 'class'
        theme: {
          accentColor: ({ theme }) => ({
            ...theme("colors"),
            auto: "auto"
          }),
          animation: {
            none: "none",
            spin: "spin 1s linear infinite",
            ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
            pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
            bounce: "bounce 1s infinite"
          },
          aria: {
            busy: 'busy="true"',
            checked: 'checked="true"',
            disabled: 'disabled="true"',
            expanded: 'expanded="true"',
            hidden: 'hidden="true"',
            pressed: 'pressed="true"',
            readonly: 'readonly="true"',
            required: 'required="true"',
            selected: 'selected="true"'
          },
          aspectRatio: {
            auto: "auto",
            square: "1 / 1",
            video: "16 / 9"
          },
          backdropBlur: ({ theme }) => theme("blur"),
          backdropBrightness: ({ theme }) => theme("brightness"),
          backdropContrast: ({ theme }) => theme("contrast"),
          backdropGrayscale: ({ theme }) => theme("grayscale"),
          backdropHueRotate: ({ theme }) => theme("hueRotate"),
          backdropInvert: ({ theme }) => theme("invert"),
          backdropOpacity: ({ theme }) => theme("opacity"),
          backdropSaturate: ({ theme }) => theme("saturate"),
          backdropSepia: ({ theme }) => theme("sepia"),
          backgroundColor: ({ theme }) => theme("colors"),
          backgroundImage: {
            none: "none",
            "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
            "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
            "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
            "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
            "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
            "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
            "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
            "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
          },
          backgroundOpacity: ({ theme }) => theme("opacity"),
          backgroundPosition: {
            bottom: "bottom",
            center: "center",
            left: "left",
            "left-bottom": "left bottom",
            "left-top": "left top",
            right: "right",
            "right-bottom": "right bottom",
            "right-top": "right top",
            top: "top"
          },
          backgroundSize: {
            auto: "auto",
            cover: "cover",
            contain: "contain"
          },
          blur: {
            0: "0",
            none: "",
            sm: "4px",
            DEFAULT: "8px",
            md: "12px",
            lg: "16px",
            xl: "24px",
            "2xl": "40px",
            "3xl": "64px"
          },
          borderColor: ({ theme }) => ({
            ...theme("colors"),
            DEFAULT: theme("colors.gray.200", "currentColor")
          }),
          borderOpacity: ({ theme }) => theme("opacity"),
          borderRadius: {
            none: "0px",
            sm: "0.125rem",
            DEFAULT: "0.25rem",
            md: "0.375rem",
            lg: "0.5rem",
            xl: "0.75rem",
            "2xl": "1rem",
            "3xl": "1.5rem",
            full: "9999px"
          },
          borderSpacing: ({ theme }) => ({
            ...theme("spacing")
          }),
          borderWidth: {
            DEFAULT: "1px",
            0: "0px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          boxShadow: {
            sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
            DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
            md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
            lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
            xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
            "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
            inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
            none: "none"
          },
          boxShadowColor: ({ theme }) => theme("colors"),
          brightness: {
            0: "0",
            50: ".5",
            75: ".75",
            90: ".9",
            95: ".95",
            100: "1",
            105: "1.05",
            110: "1.1",
            125: "1.25",
            150: "1.5",
            200: "2"
          },
          caretColor: ({ theme }) => theme("colors"),
          colors: ({ colors: colors2 }) => ({
            inherit: colors2.inherit,
            current: colors2.current,
            transparent: colors2.transparent,
            black: colors2.black,
            white: colors2.white,
            slate: colors2.slate,
            gray: colors2.gray,
            zinc: colors2.zinc,
            neutral: colors2.neutral,
            stone: colors2.stone,
            red: colors2.red,
            orange: colors2.orange,
            amber: colors2.amber,
            yellow: colors2.yellow,
            lime: colors2.lime,
            green: colors2.green,
            emerald: colors2.emerald,
            teal: colors2.teal,
            cyan: colors2.cyan,
            sky: colors2.sky,
            blue: colors2.blue,
            indigo: colors2.indigo,
            violet: colors2.violet,
            purple: colors2.purple,
            fuchsia: colors2.fuchsia,
            pink: colors2.pink,
            rose: colors2.rose
          }),
          columns: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            "3xs": "16rem",
            "2xs": "18rem",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem"
          },
          container: {},
          content: {
            none: "none"
          },
          contrast: {
            0: "0",
            50: ".5",
            75: ".75",
            100: "1",
            125: "1.25",
            150: "1.5",
            200: "2"
          },
          cursor: {
            auto: "auto",
            default: "default",
            pointer: "pointer",
            wait: "wait",
            text: "text",
            move: "move",
            help: "help",
            "not-allowed": "not-allowed",
            none: "none",
            "context-menu": "context-menu",
            progress: "progress",
            cell: "cell",
            crosshair: "crosshair",
            "vertical-text": "vertical-text",
            alias: "alias",
            copy: "copy",
            "no-drop": "no-drop",
            grab: "grab",
            grabbing: "grabbing",
            "all-scroll": "all-scroll",
            "col-resize": "col-resize",
            "row-resize": "row-resize",
            "n-resize": "n-resize",
            "e-resize": "e-resize",
            "s-resize": "s-resize",
            "w-resize": "w-resize",
            "ne-resize": "ne-resize",
            "nw-resize": "nw-resize",
            "se-resize": "se-resize",
            "sw-resize": "sw-resize",
            "ew-resize": "ew-resize",
            "ns-resize": "ns-resize",
            "nesw-resize": "nesw-resize",
            "nwse-resize": "nwse-resize",
            "zoom-in": "zoom-in",
            "zoom-out": "zoom-out"
          },
          divideColor: ({ theme }) => theme("borderColor"),
          divideOpacity: ({ theme }) => theme("borderOpacity"),
          divideWidth: ({ theme }) => theme("borderWidth"),
          dropShadow: {
            sm: "0 1px 1px rgb(0 0 0 / 0.05)",
            DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
            md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
            lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
            xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
            "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
            none: "0 0 #0000"
          },
          fill: ({ theme }) => ({
            none: "none",
            ...theme("colors")
          }),
          flex: {
            1: "1 1 0%",
            auto: "1 1 auto",
            initial: "0 1 auto",
            none: "none"
          },
          flexBasis: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%"
          }),
          flexGrow: {
            0: "0",
            DEFAULT: "1"
          },
          flexShrink: {
            0: "0",
            DEFAULT: "1"
          },
          fontFamily: {
            sans: [
              "ui-sans-serif",
              "system-ui",
              "sans-serif",
              '"Apple Color Emoji"',
              '"Segoe UI Emoji"',
              '"Segoe UI Symbol"',
              '"Noto Color Emoji"'
            ],
            serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
            mono: [
              "ui-monospace",
              "SFMono-Regular",
              "Menlo",
              "Monaco",
              "Consolas",
              '"Liberation Mono"',
              '"Courier New"',
              "monospace"
            ]
          },
          fontSize: {
            xs: ["0.75rem", { lineHeight: "1rem" }],
            sm: ["0.875rem", { lineHeight: "1.25rem" }],
            base: ["1rem", { lineHeight: "1.5rem" }],
            lg: ["1.125rem", { lineHeight: "1.75rem" }],
            xl: ["1.25rem", { lineHeight: "1.75rem" }],
            "2xl": ["1.5rem", { lineHeight: "2rem" }],
            "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
            "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
            "5xl": ["3rem", { lineHeight: "1" }],
            "6xl": ["3.75rem", { lineHeight: "1" }],
            "7xl": ["4.5rem", { lineHeight: "1" }],
            "8xl": ["6rem", { lineHeight: "1" }],
            "9xl": ["8rem", { lineHeight: "1" }]
          },
          fontWeight: {
            thin: "100",
            extralight: "200",
            light: "300",
            normal: "400",
            medium: "500",
            semibold: "600",
            bold: "700",
            extrabold: "800",
            black: "900"
          },
          gap: ({ theme }) => theme("spacing"),
          gradientColorStops: ({ theme }) => theme("colors"),
          gradientColorStopPositions: {
            "0%": "0%",
            "5%": "5%",
            "10%": "10%",
            "15%": "15%",
            "20%": "20%",
            "25%": "25%",
            "30%": "30%",
            "35%": "35%",
            "40%": "40%",
            "45%": "45%",
            "50%": "50%",
            "55%": "55%",
            "60%": "60%",
            "65%": "65%",
            "70%": "70%",
            "75%": "75%",
            "80%": "80%",
            "85%": "85%",
            "90%": "90%",
            "95%": "95%",
            "100%": "100%"
          },
          grayscale: {
            0: "0",
            DEFAULT: "100%"
          },
          gridAutoColumns: {
            auto: "auto",
            min: "min-content",
            max: "max-content",
            fr: "minmax(0, 1fr)"
          },
          gridAutoRows: {
            auto: "auto",
            min: "min-content",
            max: "max-content",
            fr: "minmax(0, 1fr)"
          },
          gridColumn: {
            auto: "auto",
            "span-1": "span 1 / span 1",
            "span-2": "span 2 / span 2",
            "span-3": "span 3 / span 3",
            "span-4": "span 4 / span 4",
            "span-5": "span 5 / span 5",
            "span-6": "span 6 / span 6",
            "span-7": "span 7 / span 7",
            "span-8": "span 8 / span 8",
            "span-9": "span 9 / span 9",
            "span-10": "span 10 / span 10",
            "span-11": "span 11 / span 11",
            "span-12": "span 12 / span 12",
            "span-full": "1 / -1"
          },
          gridColumnEnd: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
          },
          gridColumnStart: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
          },
          gridRow: {
            auto: "auto",
            "span-1": "span 1 / span 1",
            "span-2": "span 2 / span 2",
            "span-3": "span 3 / span 3",
            "span-4": "span 4 / span 4",
            "span-5": "span 5 / span 5",
            "span-6": "span 6 / span 6",
            "span-7": "span 7 / span 7",
            "span-8": "span 8 / span 8",
            "span-9": "span 9 / span 9",
            "span-10": "span 10 / span 10",
            "span-11": "span 11 / span 11",
            "span-12": "span 12 / span 12",
            "span-full": "1 / -1"
          },
          gridRowEnd: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
          },
          gridRowStart: {
            auto: "auto",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12",
            13: "13"
          },
          gridTemplateColumns: {
            none: "none",
            subgrid: "subgrid",
            1: "repeat(1, minmax(0, 1fr))",
            2: "repeat(2, minmax(0, 1fr))",
            3: "repeat(3, minmax(0, 1fr))",
            4: "repeat(4, minmax(0, 1fr))",
            5: "repeat(5, minmax(0, 1fr))",
            6: "repeat(6, minmax(0, 1fr))",
            7: "repeat(7, minmax(0, 1fr))",
            8: "repeat(8, minmax(0, 1fr))",
            9: "repeat(9, minmax(0, 1fr))",
            10: "repeat(10, minmax(0, 1fr))",
            11: "repeat(11, minmax(0, 1fr))",
            12: "repeat(12, minmax(0, 1fr))"
          },
          gridTemplateRows: {
            none: "none",
            subgrid: "subgrid",
            1: "repeat(1, minmax(0, 1fr))",
            2: "repeat(2, minmax(0, 1fr))",
            3: "repeat(3, minmax(0, 1fr))",
            4: "repeat(4, minmax(0, 1fr))",
            5: "repeat(5, minmax(0, 1fr))",
            6: "repeat(6, minmax(0, 1fr))",
            7: "repeat(7, minmax(0, 1fr))",
            8: "repeat(8, minmax(0, 1fr))",
            9: "repeat(9, minmax(0, 1fr))",
            10: "repeat(10, minmax(0, 1fr))",
            11: "repeat(11, minmax(0, 1fr))",
            12: "repeat(12, minmax(0, 1fr))"
          },
          height: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          hueRotate: {
            0: "0deg",
            15: "15deg",
            30: "30deg",
            60: "60deg",
            90: "90deg",
            180: "180deg"
          },
          inset: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%"
          }),
          invert: {
            0: "0",
            DEFAULT: "100%"
          },
          keyframes: {
            spin: {
              to: {
                transform: "rotate(360deg)"
              }
            },
            ping: {
              "75%, 100%": {
                transform: "scale(2)",
                opacity: "0"
              }
            },
            pulse: {
              "50%": {
                opacity: ".5"
              }
            },
            bounce: {
              "0%, 100%": {
                transform: "translateY(-25%)",
                animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
              },
              "50%": {
                transform: "none",
                animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
              }
            }
          },
          letterSpacing: {
            tighter: "-0.05em",
            tight: "-0.025em",
            normal: "0em",
            wide: "0.025em",
            wider: "0.05em",
            widest: "0.1em"
          },
          lineHeight: {
            none: "1",
            tight: "1.25",
            snug: "1.375",
            normal: "1.5",
            relaxed: "1.625",
            loose: "2",
            3: ".75rem",
            4: "1rem",
            5: "1.25rem",
            6: "1.5rem",
            7: "1.75rem",
            8: "2rem",
            9: "2.25rem",
            10: "2.5rem"
          },
          listStyleType: {
            none: "none",
            disc: "disc",
            decimal: "decimal"
          },
          listStyleImage: {
            none: "none"
          },
          margin: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing")
          }),
          lineClamp: {
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6"
          },
          maxHeight: ({ theme }) => ({
            ...theme("spacing"),
            none: "none",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          maxWidth: ({ theme, breakpoints }) => ({
            ...theme("spacing"),
            none: "none",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            prose: "65ch",
            ...breakpoints(theme("screens"))
          }),
          minHeight: ({ theme }) => ({
            ...theme("spacing"),
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          minWidth: ({ theme }) => ({
            ...theme("spacing"),
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          objectPosition: {
            bottom: "bottom",
            center: "center",
            left: "left",
            "left-bottom": "left bottom",
            "left-top": "left top",
            right: "right",
            "right-bottom": "right bottom",
            "right-top": "right top",
            top: "top"
          },
          opacity: {
            0: "0",
            5: "0.05",
            10: "0.1",
            15: "0.15",
            20: "0.2",
            25: "0.25",
            30: "0.3",
            35: "0.35",
            40: "0.4",
            45: "0.45",
            50: "0.5",
            55: "0.55",
            60: "0.6",
            65: "0.65",
            70: "0.7",
            75: "0.75",
            80: "0.8",
            85: "0.85",
            90: "0.9",
            95: "0.95",
            100: "1"
          },
          order: {
            first: "-9999",
            last: "9999",
            none: "0",
            1: "1",
            2: "2",
            3: "3",
            4: "4",
            5: "5",
            6: "6",
            7: "7",
            8: "8",
            9: "9",
            10: "10",
            11: "11",
            12: "12"
          },
          outlineColor: ({ theme }) => theme("colors"),
          outlineOffset: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          outlineWidth: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          padding: ({ theme }) => theme("spacing"),
          placeholderColor: ({ theme }) => theme("colors"),
          placeholderOpacity: ({ theme }) => theme("opacity"),
          ringColor: ({ theme }) => ({
            DEFAULT: theme("colors.blue.500", "#3b82f6"),
            ...theme("colors")
          }),
          ringOffsetColor: ({ theme }) => theme("colors"),
          ringOffsetWidth: {
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          ringOpacity: ({ theme }) => ({
            DEFAULT: "0.5",
            ...theme("opacity")
          }),
          ringWidth: {
            DEFAULT: "3px",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          rotate: {
            0: "0deg",
            1: "1deg",
            2: "2deg",
            3: "3deg",
            6: "6deg",
            12: "12deg",
            45: "45deg",
            90: "90deg",
            180: "180deg"
          },
          saturate: {
            0: "0",
            50: ".5",
            100: "1",
            150: "1.5",
            200: "2"
          },
          scale: {
            0: "0",
            50: ".5",
            75: ".75",
            90: ".9",
            95: ".95",
            100: "1",
            105: "1.05",
            110: "1.1",
            125: "1.25",
            150: "1.5"
          },
          screens: {
            sm: "640px",
            md: "768px",
            lg: "1024px",
            xl: "1280px",
            "2xl": "1536px"
          },
          scrollMargin: ({ theme }) => ({
            ...theme("spacing")
          }),
          scrollPadding: ({ theme }) => theme("spacing"),
          sepia: {
            0: "0",
            DEFAULT: "100%"
          },
          skew: {
            0: "0deg",
            1: "1deg",
            2: "2deg",
            3: "3deg",
            6: "6deg",
            12: "12deg"
          },
          space: ({ theme }) => ({
            ...theme("spacing")
          }),
          spacing: {
            px: "1px",
            0: "0px",
            0.5: "0.125rem",
            1: "0.25rem",
            1.5: "0.375rem",
            2: "0.5rem",
            2.5: "0.625rem",
            3: "0.75rem",
            3.5: "0.875rem",
            4: "1rem",
            5: "1.25rem",
            6: "1.5rem",
            7: "1.75rem",
            8: "2rem",
            9: "2.25rem",
            10: "2.5rem",
            11: "2.75rem",
            12: "3rem",
            14: "3.5rem",
            16: "4rem",
            20: "5rem",
            24: "6rem",
            28: "7rem",
            32: "8rem",
            36: "9rem",
            40: "10rem",
            44: "11rem",
            48: "12rem",
            52: "13rem",
            56: "14rem",
            60: "15rem",
            64: "16rem",
            72: "18rem",
            80: "20rem",
            96: "24rem"
          },
          stroke: ({ theme }) => ({
            none: "none",
            ...theme("colors")
          }),
          strokeWidth: {
            0: "0",
            1: "1",
            2: "2"
          },
          supports: {},
          data: {},
          textColor: ({ theme }) => theme("colors"),
          textDecorationColor: ({ theme }) => theme("colors"),
          textDecorationThickness: {
            auto: "auto",
            "from-font": "from-font",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          textIndent: ({ theme }) => ({
            ...theme("spacing")
          }),
          textOpacity: ({ theme }) => theme("opacity"),
          textUnderlineOffset: {
            auto: "auto",
            0: "0px",
            1: "1px",
            2: "2px",
            4: "4px",
            8: "8px"
          },
          transformOrigin: {
            center: "center",
            top: "top",
            "top-right": "top right",
            right: "right",
            "bottom-right": "bottom right",
            bottom: "bottom",
            "bottom-left": "bottom left",
            left: "left",
            "top-left": "top left"
          },
          transitionDelay: {
            0: "0s",
            75: "75ms",
            100: "100ms",
            150: "150ms",
            200: "200ms",
            300: "300ms",
            500: "500ms",
            700: "700ms",
            1e3: "1000ms"
          },
          transitionDuration: {
            DEFAULT: "150ms",
            0: "0s",
            75: "75ms",
            100: "100ms",
            150: "150ms",
            200: "200ms",
            300: "300ms",
            500: "500ms",
            700: "700ms",
            1e3: "1000ms"
          },
          transitionProperty: {
            none: "none",
            all: "all",
            DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
            colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
            opacity: "opacity",
            shadow: "box-shadow",
            transform: "transform"
          },
          transitionTimingFunction: {
            DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
            linear: "linear",
            in: "cubic-bezier(0.4, 0, 1, 1)",
            out: "cubic-bezier(0, 0, 0.2, 1)",
            "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
          },
          translate: ({ theme }) => ({
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%"
          }),
          size: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          width: ({ theme }) => ({
            auto: "auto",
            ...theme("spacing"),
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            screen: "100vw",
            svw: "100svw",
            lvw: "100lvw",
            dvw: "100dvw",
            min: "min-content",
            max: "max-content",
            fit: "fit-content"
          }),
          willChange: {
            auto: "auto",
            scroll: "scroll-position",
            contents: "contents",
            transform: "transform"
          },
          zIndex: {
            auto: "auto",
            0: "0",
            10: "10",
            20: "20",
            30: "30",
            40: "40",
            50: "50"
          }
        },
        plugins: []
      };
      return config_full;
    }
    var hasRequiredGetAllConfigs;
    function requireGetAllConfigs() {
      if (hasRequiredGetAllConfigs) return getAllConfigs;
      hasRequiredGetAllConfigs = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return getAllConfigs2;
          }
        });
        const _configfull = /* @__PURE__ */ _interop_require_default(requireConfig_full());
        const _featureFlags = requireFeatureFlags();
        function _interop_require_default(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function getAllConfigs2(config) {
          var _config_presets;
          const configs = ((_config_presets = config === null || config === void 0 ? void 0 : config.presets) !== null && _config_presets !== void 0 ? _config_presets : [
            _configfull.default
          ]).slice().reverse().flatMap((preset) => getAllConfigs2(preset instanceof Function ? preset() : preset));
          const features = {
            // Add experimental configs here...
            respectDefaultRingColorOpacity: {
              theme: {
                ringColor: ({ theme }) => ({
                  DEFAULT: "#3b82f67f",
                  ...theme("colors")
                })
              }
            },
            disableColorOpacityUtilitiesByDefault: {
              corePlugins: {
                backgroundOpacity: false,
                borderOpacity: false,
                divideOpacity: false,
                placeholderOpacity: false,
                ringOpacity: false,
                textOpacity: false
              }
            }
          };
          const experimentals = Object.keys(features).filter((feature) => (0, _featureFlags.flagEnabled)(config, feature)).map((feature) => features[feature]);
          return [
            config,
            ...experimentals,
            ...configs
          ];
        }
      })(getAllConfigs);
      return getAllConfigs;
    }
    var hasRequiredResolveConfig$1;
    function requireResolveConfig$1() {
      if (hasRequiredResolveConfig$1) return resolveConfig$2;
      hasRequiredResolveConfig$1 = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return resolveConfig2;
          }
        });
        const _resolveConfig = /* @__PURE__ */ _interop_require_default(requireResolveConfig$2());
        const _getAllConfigs = /* @__PURE__ */ _interop_require_default(requireGetAllConfigs());
        function _interop_require_default(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function resolveConfig2(...configs) {
          let [, ...defaultConfigs] = (0, _getAllConfigs.default)(configs[0]);
          return (0, _resolveConfig.default)([
            ...configs,
            ...defaultConfigs
          ]);
        }
      })(resolveConfig$2);
      return resolveConfig$2;
    }
    var resolveConfig_1;
    var hasRequiredResolveConfig;
    function requireResolveConfig() {
      if (hasRequiredResolveConfig) return resolveConfig_1;
      hasRequiredResolveConfig = 1;
      let resolveConfig2 = requireResolveConfig$1();
      resolveConfig_1 = (resolveConfig2.__esModule ? resolveConfig2 : { default: resolveConfig2 }).default;
      return resolveConfig_1;
    }
    var resolveConfigExports = requireResolveConfig();
    const resolveConfig = /* @__PURE__ */ getDefaultExportFromCjs(resolveConfigExports);
    var defaultTheme$1 = {};
    var hasRequiredDefaultTheme$1;
    function requireDefaultTheme$1() {
      if (hasRequiredDefaultTheme$1) return defaultTheme$1;
      hasRequiredDefaultTheme$1 = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return _default;
          }
        });
        const _cloneDeep = requireCloneDeep();
        const _configfull = /* @__PURE__ */ _interop_require_default(requireConfig_full());
        function _interop_require_default(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        const _default = (0, _cloneDeep.cloneDeep)(_configfull.default.theme);
      })(defaultTheme$1);
      return defaultTheme$1;
    }
    var defaultTheme_1;
    var hasRequiredDefaultTheme;
    function requireDefaultTheme() {
      if (hasRequiredDefaultTheme) return defaultTheme_1;
      hasRequiredDefaultTheme = 1;
      let defaultTheme2 = requireDefaultTheme$1();
      defaultTheme_1 = (defaultTheme2.__esModule ? defaultTheme2 : { default: defaultTheme2 }).default;
      return defaultTheme_1;
    }
    var defaultThemeExports = requireDefaultTheme();
    const defaultTheme = /* @__PURE__ */ getDefaultExportFromCjs(defaultThemeExports);
    var shorterCssColorNames;
    var hasRequiredShorterCssColorNames;
    function requireShorterCssColorNames() {
      if (hasRequiredShorterCssColorNames) return shorterCssColorNames;
      hasRequiredShorterCssColorNames = 1;
      shorterCssColorNames = {
        aqua: /#00ffff(ff)?(?!\w)|#0ff(f)?(?!\w)/gi,
        azure: /#f0ffff(ff)?(?!\w)/gi,
        beige: /#f5f5dc(ff)?(?!\w)/gi,
        bisque: /#ffe4c4(ff)?(?!\w)/gi,
        black: /#000000(ff)?(?!\w)|#000(f)?(?!\w)/gi,
        blue: /#0000ff(ff)?(?!\w)|#00f(f)?(?!\w)/gi,
        brown: /#a52a2a(ff)?(?!\w)/gi,
        coral: /#ff7f50(ff)?(?!\w)/gi,
        cornsilk: /#fff8dc(ff)?(?!\w)/gi,
        crimson: /#dc143c(ff)?(?!\w)/gi,
        cyan: /#00ffff(ff)?(?!\w)|#0ff(f)?(?!\w)/gi,
        darkblue: /#00008b(ff)?(?!\w)/gi,
        darkcyan: /#008b8b(ff)?(?!\w)/gi,
        darkgrey: /#a9a9a9(ff)?(?!\w)/gi,
        darkred: /#8b0000(ff)?(?!\w)/gi,
        deeppink: /#ff1493(ff)?(?!\w)/gi,
        dimgrey: /#696969(ff)?(?!\w)/gi,
        gold: /#ffd700(ff)?(?!\w)/gi,
        green: /#008000(ff)?(?!\w)/gi,
        grey: /#808080(ff)?(?!\w)/gi,
        honeydew: /#f0fff0(ff)?(?!\w)/gi,
        hotpink: /#ff69b4(ff)?(?!\w)/gi,
        indigo: /#4b0082(ff)?(?!\w)/gi,
        ivory: /#fffff0(ff)?(?!\w)/gi,
        khaki: /#f0e68c(ff)?(?!\w)/gi,
        lavender: /#e6e6fa(ff)?(?!\w)/gi,
        lime: /#00ff00(ff)?(?!\w)|#0f0(f)?(?!\w)/gi,
        linen: /#faf0e6(ff)?(?!\w)/gi,
        maroon: /#800000(ff)?(?!\w)/gi,
        moccasin: /#ffe4b5(ff)?(?!\w)/gi,
        navy: /#000080(ff)?(?!\w)/gi,
        oldlace: /#fdf5e6(ff)?(?!\w)/gi,
        olive: /#808000(ff)?(?!\w)/gi,
        orange: /#ffa500(ff)?(?!\w)/gi,
        orchid: /#da70d6(ff)?(?!\w)/gi,
        peru: /#cd853f(ff)?(?!\w)/gi,
        pink: /#ffc0cb(ff)?(?!\w)/gi,
        plum: /#dda0dd(ff)?(?!\w)/gi,
        purple: /#800080(ff)?(?!\w)/gi,
        red: /#ff0000(ff)?(?!\w)|#f00(f)?(?!\w)/gi,
        salmon: /#fa8072(ff)?(?!\w)/gi,
        seagreen: /#2e8b57(ff)?(?!\w)/gi,
        seashell: /#fff5ee(ff)?(?!\w)/gi,
        sienna: /#a0522d(ff)?(?!\w)/gi,
        silver: /#c0c0c0(ff)?(?!\w)/gi,
        skyblue: /#87ceeb(ff)?(?!\w)/gi,
        snow: /#fffafa(ff)?(?!\w)/gi,
        tan: /#d2b48c(ff)?(?!\w)/gi,
        teal: /#008080(ff)?(?!\w)/gi,
        thistle: /#d8bfd8(ff)?(?!\w)/gi,
        tomato: /#ff6347(ff)?(?!\w)/gi,
        violet: /#ee82ee(ff)?(?!\w)/gi,
        wheat: /#f5deb3(ff)?(?!\w)/gi,
        white: /#ffffff(ff)?(?!\w)|#fff(f)?(?!\w)/gi
      };
      return shorterCssColorNames;
    }
    var miniSvgDataUri;
    var hasRequiredMiniSvgDataUri;
    function requireMiniSvgDataUri() {
      if (hasRequiredMiniSvgDataUri) return miniSvgDataUri;
      hasRequiredMiniSvgDataUri = 1;
      var shorterNames = requireShorterCssColorNames();
      var REGEX = {
        whitespace: /\s+/g,
        urlHexPairs: /%[\dA-F]{2}/g,
        quotes: /"/g
      };
      function collapseWhitespace(str) {
        return str.trim().replace(REGEX.whitespace, " ");
      }
      function dataURIPayload(string) {
        return encodeURIComponent(string).replace(REGEX.urlHexPairs, specialHexEncode);
      }
      function colorCodeToShorterNames(string) {
        Object.keys(shorterNames).forEach(function(key) {
          if (shorterNames[key].test(string)) {
            string = string.replace(shorterNames[key], key);
          }
        });
        return string;
      }
      function specialHexEncode(match) {
        switch (match) {
          // Browsers tolerate these characters, and they're frequent
          case "%20":
            return " ";
          case "%3D":
            return "=";
          case "%3A":
            return ":";
          case "%2F":
            return "/";
          default:
            return match.toLowerCase();
        }
      }
      function svgToTinyDataUri(svgString) {
        if (typeof svgString !== "string") {
          throw new TypeError("Expected a string, but received " + typeof svgString);
        }
        if (svgString.charCodeAt(0) === 65279) {
          svgString = svgString.slice(1);
        }
        var body = colorCodeToShorterNames(collapseWhitespace(svgString)).replace(REGEX.quotes, "'");
        return "data:image/svg+xml," + dataURIPayload(body);
      }
      svgToTinyDataUri.toSrcset = function toSrcset(svgString) {
        return svgToTinyDataUri(svgString).replace(/ /g, "%20");
      };
      miniSvgDataUri = svgToTinyDataUri;
      return miniSvgDataUri;
    }
    var createPlugin$1 = {};
    var createPlugin = {};
    var hasRequiredCreatePlugin$1;
    function requireCreatePlugin$1() {
      if (hasRequiredCreatePlugin$1) return createPlugin;
      hasRequiredCreatePlugin$1 = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return _default;
          }
        });
        function createPlugin2(plugin2, config) {
          return {
            handler: plugin2,
            config
          };
        }
        createPlugin2.withOptions = function(pluginFunction, configFunction = () => ({})) {
          const optionsFunction = function(options) {
            return {
              __options: options,
              handler: pluginFunction(options),
              config: configFunction(options)
            };
          };
          optionsFunction.__isOptionsFunction = true;
          optionsFunction.__pluginFunction = pluginFunction;
          optionsFunction.__configFunction = configFunction;
          return optionsFunction;
        };
        const _default = createPlugin2;
      })(createPlugin);
      return createPlugin;
    }
    var hasRequiredCreatePlugin;
    function requireCreatePlugin() {
      if (hasRequiredCreatePlugin) return createPlugin$1;
      hasRequiredCreatePlugin = 1;
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        Object.defineProperty(exports2, "default", {
          enumerable: true,
          get: function() {
            return _default;
          }
        });
        const _createPlugin = /* @__PURE__ */ _interop_require_default(requireCreatePlugin$1());
        function _interop_require_default(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        const _default = _createPlugin.default;
      })(createPlugin$1);
      return createPlugin$1;
    }
    var plugin;
    var hasRequiredPlugin$1;
    function requirePlugin$1() {
      if (hasRequiredPlugin$1) return plugin;
      hasRequiredPlugin$1 = 1;
      let createPlugin2 = requireCreatePlugin();
      plugin = (createPlugin2.__esModule ? createPlugin2 : { default: createPlugin2 }).default;
      return plugin;
    }
    var colors_1;
    var hasRequiredColors;
    function requireColors() {
      if (hasRequiredColors) return colors_1;
      hasRequiredColors = 1;
      let colors2 = requireColors$1();
      colors_1 = (colors2.__esModule ? colors2 : { default: colors2 }).default;
      return colors_1;
    }
    var src;
    var hasRequiredSrc;
    function requireSrc() {
      if (hasRequiredSrc) return src;
      hasRequiredSrc = 1;
      const svgToDataUri = requireMiniSvgDataUri();
      const plugin2 = requirePlugin$1();
      const defaultTheme2 = requireDefaultTheme();
      const colors2 = requireColors();
      const [baseFontSize, { lineHeight: baseLineHeight }] = defaultTheme2.fontSize.base;
      const { spacing, borderWidth, borderRadius } = defaultTheme2;
      function resolveColor(color2, opacityVariableName) {
        return color2.replace("<alpha-value>", `var(${opacityVariableName}, 1)`);
      }
      const forms2 = plugin2.withOptions(function(options = { strategy: void 0 }) {
        return function({ addBase, addComponents, theme }) {
          function resolveChevronColor(color2, fallback) {
            let resolved = theme(color2);
            if (!resolved || resolved.includes("var(")) {
              return fallback;
            }
            return resolved.replace("<alpha-value>", "1");
          }
          const strategy = options.strategy === void 0 ? ["base", "class"] : [options.strategy];
          const rules = [
            {
              base: [
                "[type='text']",
                "input:where(:not([type]))",
                "[type='email']",
                "[type='url']",
                "[type='password']",
                "[type='number']",
                "[type='date']",
                "[type='datetime-local']",
                "[type='month']",
                "[type='search']",
                "[type='tel']",
                "[type='time']",
                "[type='week']",
                "[multiple]",
                "textarea",
                "select"
              ],
              class: [".form-input", ".form-textarea", ".form-select", ".form-multiselect"],
              styles: {
                appearance: "none",
                "background-color": "#fff",
                "border-color": resolveColor(
                  theme("colors.gray.500", colors2.gray[500]),
                  "--tw-border-opacity"
                ),
                "border-width": borderWidth["DEFAULT"],
                "border-radius": borderRadius.none,
                "padding-top": spacing[2],
                "padding-right": spacing[3],
                "padding-bottom": spacing[2],
                "padding-left": spacing[3],
                "font-size": baseFontSize,
                "line-height": baseLineHeight,
                "--tw-shadow": "0 0 #0000",
                "&:focus": {
                  outline: "2px solid transparent",
                  "outline-offset": "2px",
                  "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-ring-offset-width": "0px",
                  "--tw-ring-offset-color": "#fff",
                  "--tw-ring-color": resolveColor(
                    theme("colors.blue.600", colors2.blue[600]),
                    "--tw-ring-opacity"
                  ),
                  "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
                  "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
                  "box-shadow": `var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow)`,
                  "border-color": resolveColor(
                    theme("colors.blue.600", colors2.blue[600]),
                    "--tw-border-opacity"
                  )
                }
              }
            },
            {
              base: ["input::placeholder", "textarea::placeholder"],
              class: [".form-input::placeholder", ".form-textarea::placeholder"],
              styles: {
                color: resolveColor(theme("colors.gray.500", colors2.gray[500]), "--tw-text-opacity"),
                opacity: "1"
              }
            },
            {
              base: ["::-webkit-datetime-edit-fields-wrapper"],
              class: [".form-input::-webkit-datetime-edit-fields-wrapper"],
              styles: {
                padding: "0"
              }
            },
            {
              // Unfortunate hack until https://bugs.webkit.org/show_bug.cgi?id=198959 is fixed.
              // This sucks because users can't change line-height with a utility on date inputs now.
              // Reference: https://github.com/twbs/bootstrap/pull/31993
              base: ["::-webkit-date-and-time-value"],
              class: [".form-input::-webkit-date-and-time-value"],
              styles: {
                "min-height": "1.5em"
              }
            },
            {
              // In Safari on iOS date and time inputs are centered instead of left-aligned and can't be
              // changed with `text-align` utilities on the input by default. Resetting this to `inherit`
              // makes them left-aligned by default and makes it possible to override the alignment with
              // utility classes without using an arbitrary variant to target the pseudo-elements.
              base: ["::-webkit-date-and-time-value"],
              class: [".form-input::-webkit-date-and-time-value"],
              styles: {
                "text-align": "inherit"
              }
            },
            {
              // In Safari on macOS date time inputs that are set to `display: block` have unexpected
              // extra bottom spacing. This can be corrected by setting the `::-webkit-datetime-edit`
              // pseudo-element to `display: inline-flex`, instead of the browser default of
              // `display: inline-block`.
              base: ["::-webkit-datetime-edit"],
              class: [".form-input::-webkit-datetime-edit"],
              styles: {
                display: "inline-flex"
              }
            },
            {
              // In Safari on macOS date time inputs are 4px taller than normal inputs
              // This is because there is extra padding on the datetime-edit and datetime-edit-{part}-field pseudo elements
              // See https://github.com/tailwindlabs/tailwindcss-forms/issues/95
              base: [
                "::-webkit-datetime-edit",
                "::-webkit-datetime-edit-year-field",
                "::-webkit-datetime-edit-month-field",
                "::-webkit-datetime-edit-day-field",
                "::-webkit-datetime-edit-hour-field",
                "::-webkit-datetime-edit-minute-field",
                "::-webkit-datetime-edit-second-field",
                "::-webkit-datetime-edit-millisecond-field",
                "::-webkit-datetime-edit-meridiem-field"
              ],
              class: [
                ".form-input::-webkit-datetime-edit",
                ".form-input::-webkit-datetime-edit-year-field",
                ".form-input::-webkit-datetime-edit-month-field",
                ".form-input::-webkit-datetime-edit-day-field",
                ".form-input::-webkit-datetime-edit-hour-field",
                ".form-input::-webkit-datetime-edit-minute-field",
                ".form-input::-webkit-datetime-edit-second-field",
                ".form-input::-webkit-datetime-edit-millisecond-field",
                ".form-input::-webkit-datetime-edit-meridiem-field"
              ],
              styles: {
                "padding-top": 0,
                "padding-bottom": 0
              }
            },
            {
              base: ["select"],
              class: [".form-select"],
              styles: {
                "background-image": `url("${svgToDataUri(
                  `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20"><path stroke="${resolveChevronColor(
                    "colors.gray.500",
                    colors2.gray[500]
                  )}" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 8l4 4 4-4"/></svg>`
                )}")`,
                "background-position": `right ${spacing[2]} center`,
                "background-repeat": `no-repeat`,
                "background-size": `1.5em 1.5em`,
                "padding-right": spacing[10],
                "print-color-adjust": `exact`
              }
            },
            {
              base: ["[multiple]", '[size]:where(select:not([size="1"]))'],
              class: ['.form-select:where([size]:not([size="1"]))'],
              styles: {
                "background-image": "initial",
                "background-position": "initial",
                "background-repeat": "unset",
                "background-size": "initial",
                "padding-right": spacing[3],
                "print-color-adjust": "unset"
              }
            },
            {
              base: [`[type='checkbox']`, `[type='radio']`],
              class: [".form-checkbox", ".form-radio"],
              styles: {
                appearance: "none",
                padding: "0",
                "print-color-adjust": "exact",
                display: "inline-block",
                "vertical-align": "middle",
                "background-origin": "border-box",
                "user-select": "none",
                "flex-shrink": "0",
                height: spacing[4],
                width: spacing[4],
                color: resolveColor(theme("colors.blue.600", colors2.blue[600]), "--tw-text-opacity"),
                "background-color": "#fff",
                "border-color": resolveColor(
                  theme("colors.gray.500", colors2.gray[500]),
                  "--tw-border-opacity"
                ),
                "border-width": borderWidth["DEFAULT"],
                "--tw-shadow": "0 0 #0000"
              }
            },
            {
              base: [`[type='checkbox']`],
              class: [".form-checkbox"],
              styles: {
                "border-radius": borderRadius["none"]
              }
            },
            {
              base: [`[type='radio']`],
              class: [".form-radio"],
              styles: {
                "border-radius": "100%"
              }
            },
            {
              base: [`[type='checkbox']:focus`, `[type='radio']:focus`],
              class: [".form-checkbox:focus", ".form-radio:focus"],
              styles: {
                outline: "2px solid transparent",
                "outline-offset": "2px",
                "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)",
                "--tw-ring-offset-width": "2px",
                "--tw-ring-offset-color": "#fff",
                "--tw-ring-color": resolveColor(
                  theme("colors.blue.600", colors2.blue[600]),
                  "--tw-ring-opacity"
                ),
                "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
                "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
                "box-shadow": `var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow)`
              }
            },
            {
              base: [`[type='checkbox']:checked`, `[type='radio']:checked`],
              class: [".form-checkbox:checked", ".form-radio:checked"],
              styles: {
                "border-color": `transparent`,
                "background-color": `currentColor`,
                "background-size": `100% 100%`,
                "background-position": `center`,
                "background-repeat": `no-repeat`
              }
            },
            {
              base: [`[type='checkbox']:checked`],
              class: [".form-checkbox:checked"],
              styles: {
                "background-image": `url("${svgToDataUri(
                  `<svg viewBox="0 0 16 16" fill="white" xmlns="http://www.w3.org/2000/svg"><path d="M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z"/></svg>`
                )}")`,
                "@media (forced-colors: active) ": {
                  appearance: "auto"
                }
              }
            },
            {
              base: [`[type='radio']:checked`],
              class: [".form-radio:checked"],
              styles: {
                "background-image": `url("${svgToDataUri(
                  `<svg viewBox="0 0 16 16" fill="white" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="3"/></svg>`
                )}")`,
                "@media (forced-colors: active) ": {
                  appearance: "auto"
                }
              }
            },
            {
              base: [
                `[type='checkbox']:checked:hover`,
                `[type='checkbox']:checked:focus`,
                `[type='radio']:checked:hover`,
                `[type='radio']:checked:focus`
              ],
              class: [
                ".form-checkbox:checked:hover",
                ".form-checkbox:checked:focus",
                ".form-radio:checked:hover",
                ".form-radio:checked:focus"
              ],
              styles: {
                "border-color": "transparent",
                "background-color": "currentColor"
              }
            },
            {
              base: [`[type='checkbox']:indeterminate`],
              class: [".form-checkbox:indeterminate"],
              styles: {
                "background-image": `url("${svgToDataUri(
                  `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16"><path stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h8"/></svg>`
                )}")`,
                "border-color": `transparent`,
                "background-color": `currentColor`,
                "background-size": `100% 100%`,
                "background-position": `center`,
                "background-repeat": `no-repeat`,
                "@media (forced-colors: active) ": {
                  appearance: "auto"
                }
              }
            },
            {
              base: [`[type='checkbox']:indeterminate:hover`, `[type='checkbox']:indeterminate:focus`],
              class: [".form-checkbox:indeterminate:hover", ".form-checkbox:indeterminate:focus"],
              styles: {
                "border-color": "transparent",
                "background-color": "currentColor"
              }
            },
            {
              base: [`[type='file']`],
              class: null,
              styles: {
                background: "unset",
                "border-color": "inherit",
                "border-width": "0",
                "border-radius": "0",
                padding: "0",
                "font-size": "unset",
                "line-height": "inherit"
              }
            },
            {
              base: [`[type='file']:focus`],
              class: null,
              styles: {
                outline: [`1px solid ButtonText`, `1px auto -webkit-focus-ring-color`]
              }
            }
          ];
          const getStrategyRules = (strategy2) => rules.map((rule) => {
            if (rule[strategy2] === null) return null;
            return { [rule[strategy2]]: rule.styles };
          }).filter(Boolean);
          if (strategy.includes("base")) {
            addBase(getStrategyRules("base"));
          }
          if (strategy.includes("class")) {
            addComponents(getStrategyRules("class"));
          }
        };
      });
      src = forms2;
      return src;
    }
    var srcExports = requireSrc();
    const forms = /* @__PURE__ */ getDefaultExportFromCjs(srcExports);
    var tailwindcssAnimate$1;
    var hasRequiredTailwindcssAnimate;
    function requireTailwindcssAnimate() {
      if (hasRequiredTailwindcssAnimate) return tailwindcssAnimate$1;
      hasRequiredTailwindcssAnimate = 1;
      const plugin2 = requirePlugin$1();
      function filterDefault(values) {
        return Object.fromEntries(
          Object.entries(values).filter(([key]) => key !== "DEFAULT")
        );
      }
      tailwindcssAnimate$1 = plugin2(
        ({ addUtilities, matchUtilities, theme }) => {
          addUtilities({
            "@keyframes enter": theme("keyframes.enter"),
            "@keyframes exit": theme("keyframes.exit"),
            ".animate-in": {
              animationName: "enter",
              animationDuration: theme("animationDuration.DEFAULT"),
              "--tw-enter-opacity": "initial",
              "--tw-enter-scale": "initial",
              "--tw-enter-rotate": "initial",
              "--tw-enter-translate-x": "initial",
              "--tw-enter-translate-y": "initial"
            },
            ".animate-out": {
              animationName: "exit",
              animationDuration: theme("animationDuration.DEFAULT"),
              "--tw-exit-opacity": "initial",
              "--tw-exit-scale": "initial",
              "--tw-exit-rotate": "initial",
              "--tw-exit-translate-x": "initial",
              "--tw-exit-translate-y": "initial"
            }
          });
          matchUtilities(
            {
              "fade-in": (value) => ({ "--tw-enter-opacity": value }),
              "fade-out": (value) => ({ "--tw-exit-opacity": value })
            },
            { values: theme("animationOpacity") }
          );
          matchUtilities(
            {
              "zoom-in": (value) => ({ "--tw-enter-scale": value }),
              "zoom-out": (value) => ({ "--tw-exit-scale": value })
            },
            { values: theme("animationScale") }
          );
          matchUtilities(
            {
              "spin-in": (value) => ({ "--tw-enter-rotate": value }),
              "spin-out": (value) => ({ "--tw-exit-rotate": value })
            },
            { values: theme("animationRotate") }
          );
          matchUtilities(
            {
              "slide-in-from-top": (value) => ({
                "--tw-enter-translate-y": `-${value}`
              }),
              "slide-in-from-bottom": (value) => ({
                "--tw-enter-translate-y": value
              }),
              "slide-in-from-left": (value) => ({
                "--tw-enter-translate-x": `-${value}`
              }),
              "slide-in-from-right": (value) => ({
                "--tw-enter-translate-x": value
              }),
              "slide-out-to-top": (value) => ({
                "--tw-exit-translate-y": `-${value}`
              }),
              "slide-out-to-bottom": (value) => ({
                "--tw-exit-translate-y": value
              }),
              "slide-out-to-left": (value) => ({
                "--tw-exit-translate-x": `-${value}`
              }),
              "slide-out-to-right": (value) => ({
                "--tw-exit-translate-x": value
              })
            },
            { values: theme("animationTranslate") }
          );
          matchUtilities(
            { duration: (value) => ({ animationDuration: value }) },
            { values: filterDefault(theme("animationDuration")) }
          );
          matchUtilities(
            { delay: (value) => ({ animationDelay: value }) },
            { values: theme("animationDelay") }
          );
          matchUtilities(
            { ease: (value) => ({ animationTimingFunction: value }) },
            { values: filterDefault(theme("animationTimingFunction")) }
          );
          addUtilities({
            ".running": { animationPlayState: "running" },
            ".paused": { animationPlayState: "paused" }
          });
          matchUtilities(
            { "fill-mode": (value) => ({ animationFillMode: value }) },
            { values: theme("animationFillMode") }
          );
          matchUtilities(
            { direction: (value) => ({ animationDirection: value }) },
            { values: theme("animationDirection") }
          );
          matchUtilities(
            { repeat: (value) => ({ animationIterationCount: value }) },
            { values: theme("animationRepeat") }
          );
        },
        {
          theme: {
            extend: {
              animationDelay: ({ theme }) => ({
                ...theme("transitionDelay")
              }),
              animationDuration: ({ theme }) => ({
                0: "0ms",
                ...theme("transitionDuration")
              }),
              animationTimingFunction: ({ theme }) => ({
                ...theme("transitionTimingFunction")
              }),
              animationFillMode: {
                none: "none",
                forwards: "forwards",
                backwards: "backwards",
                both: "both"
              },
              animationDirection: {
                normal: "normal",
                reverse: "reverse",
                alternate: "alternate",
                "alternate-reverse": "alternate-reverse"
              },
              animationOpacity: ({ theme }) => ({
                DEFAULT: 0,
                ...theme("opacity")
              }),
              animationTranslate: ({ theme }) => ({
                DEFAULT: "100%",
                ...theme("translate")
              }),
              animationScale: ({ theme }) => ({
                DEFAULT: 0,
                ...theme("scale")
              }),
              animationRotate: ({ theme }) => ({
                DEFAULT: "30deg",
                ...theme("rotate")
              }),
              animationRepeat: {
                0: "0",
                1: "1",
                infinite: "infinite"
              },
              keyframes: {
                enter: {
                  from: {
                    opacity: "var(--tw-enter-opacity, 1)",
                    transform: "translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))"
                  }
                },
                exit: {
                  to: {
                    opacity: "var(--tw-exit-opacity, 1)",
                    transform: "translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))"
                  }
                }
              }
            }
          }
        }
      );
      return tailwindcssAnimate$1;
    }
    var tailwindcssAnimateExports = requireTailwindcssAnimate();
    const tailwindcssAnimate = /* @__PURE__ */ getDefaultExportFromCjs(tailwindcssAnimateExports);
    var plugin_1;
    var hasRequiredPlugin;
    function requirePlugin() {
      if (hasRequiredPlugin) return plugin_1;
      hasRequiredPlugin = 1;
      const svgToDataUri = requireMiniSvgDataUri();
      const plugin2 = requirePlugin$1();
      const defaultTheme2 = requireDefaultTheme();
      const colors2 = requireColors();
      const [baseFontSize, { lineHeight: baseLineHeight }] = defaultTheme2.fontSize.base;
      const { spacing, borderWidth, borderRadius, boxShadow } = defaultTheme2;
      plugin_1 = plugin2.withOptions(
        function(options = {}) {
          const {
            charts = false,
            datatables = false,
            forms: forms2 = true,
            tooltips = true,
            wysiwyg = false
          } = options;
          return function({ addBase, addComponents, theme }) {
            if (tooltips) {
              addBase({
                // remove from v2.x+ END
                [[".tooltip-arrow", ".tooltip-arrow:before"]]: {
                  position: "absolute",
                  width: "8px",
                  height: "8px",
                  background: "inherit"
                },
                [[".tooltip-arrow"]]: {
                  visibility: "hidden"
                },
                [[".tooltip-arrow:before"]]: {
                  content: '""',
                  visibility: "visible",
                  transform: "rotate(45deg)"
                },
                [`[data-tooltip-style^='light'] + .tooltip > .tooltip-arrow:before`]: {
                  "border-style": "solid",
                  "border-color": colors2.gray[200]
                },
                [`[data-tooltip-style^='light'] + .tooltip[data-popper-placement^='top'] > .tooltip-arrow:before`]: {
                  "border-bottom-width": "1px",
                  "border-right-width": "1px"
                },
                [`[data-tooltip-style^='light'] + .tooltip[data-popper-placement^='right'] > .tooltip-arrow:before`]: {
                  "border-bottom-width": "1px",
                  "border-left-width": "1px"
                },
                [`[data-tooltip-style^='light'] + .tooltip[data-popper-placement^='bottom'] > .tooltip-arrow:before`]: {
                  "border-top-width": "1px",
                  "border-left-width": "1px"
                },
                [`[data-tooltip-style^='light'] + .tooltip[data-popper-placement^='left'] > .tooltip-arrow:before`]: {
                  "border-top-width": "1px",
                  "border-right-width": "1px"
                },
                [`.tooltip[data-popper-placement^='top'] > .tooltip-arrow`]: {
                  bottom: "-4px"
                },
                [`.tooltip[data-popper-placement^='bottom'] > .tooltip-arrow`]: {
                  top: "-4px"
                },
                [`.tooltip[data-popper-placement^='left'] > .tooltip-arrow`]: {
                  right: "-4px"
                },
                [`.tooltip[data-popper-placement^='right'] > .tooltip-arrow`]: {
                  left: "-4px"
                },
                [".tooltip.invisible > .tooltip-arrow:before"]: {
                  visibility: "hidden"
                },
                [["[data-popper-arrow]", "[data-popper-arrow]:before"]]: {
                  position: "absolute",
                  width: "8px",
                  height: "8px",
                  background: "inherit"
                },
                ["[data-popper-arrow]"]: {
                  visibility: "hidden"
                },
                ["[data-popper-arrow]:before"]: {
                  content: '""',
                  visibility: "visible",
                  transform: "rotate(45deg)"
                },
                ["[data-popper-arrow]:after"]: {
                  content: '""',
                  visibility: "visible",
                  transform: "rotate(45deg)",
                  position: "absolute",
                  width: "9px",
                  height: "9px",
                  background: "inherit"
                },
                [`[role="tooltip"] > [data-popper-arrow]:before`]: {
                  "border-style": "solid",
                  "border-color": colors2.gray[200]
                },
                [`.dark [role="tooltip"] > [data-popper-arrow]:before`]: {
                  "border-style": "solid",
                  "border-color": colors2.gray[600]
                },
                [`[role="tooltip"] > [data-popper-arrow]:after`]: {
                  "border-style": "solid",
                  "border-color": colors2.gray[200]
                },
                [`.dark [role="tooltip"] > [data-popper-arrow]:after`]: {
                  "border-style": "solid",
                  "border-color": colors2.gray[600]
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='top'] > [data-popper-arrow]:before`]: {
                  "border-bottom-width": "1px",
                  "border-right-width": "1px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='top'] > [data-popper-arrow]:after`]: {
                  "border-bottom-width": "1px",
                  "border-right-width": "1px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='right'] > [data-popper-arrow]:before`]: {
                  "border-bottom-width": "1px",
                  "border-left-width": "1px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='right'] > [data-popper-arrow]:after`]: {
                  "border-bottom-width": "1px",
                  "border-left-width": "1px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='bottom'] > [data-popper-arrow]:before`]: {
                  "border-top-width": "1px",
                  "border-left-width": "1px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='bottom'] > [data-popper-arrow]:after`]: {
                  "border-top-width": "1px",
                  "border-left-width": "1px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='left'] > [data-popper-arrow]:before`]: {
                  "border-top-width": "1px",
                  "border-right-width": "1px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='left'] > [data-popper-arrow]:after`]: {
                  "border-top-width": "1px",
                  "border-right-width": "1px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='top'] > [data-popper-arrow]`]: {
                  bottom: "-5px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='bottom'] > [data-popper-arrow]`]: {
                  top: "-5px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='left'] > [data-popper-arrow]`]: {
                  right: "-5px"
                },
                [`[data-popover][role="tooltip"][data-popper-placement^='right'] > [data-popper-arrow]`]: {
                  left: "-5px"
                },
                ['[role="tooltip"].invisible > [data-popper-arrow]:before']: {
                  visibility: "hidden"
                },
                ['[role="tooltip"].invisible > [data-popper-arrow]:after']: {
                  visibility: "hidden"
                }
              });
            }
            if (forms2) {
              addBase({
                [[
                  "[type='text']",
                  "[type='email']",
                  "[type='url']",
                  "[type='password']",
                  "[type='number']",
                  "[type='date']",
                  "[type='datetime-local']",
                  "[type='month']",
                  "[type='search']",
                  "[type='tel']",
                  "[type='time']",
                  "[type='week']",
                  "[multiple]",
                  "textarea",
                  "select"
                ]]: {
                  appearance: "none",
                  "background-color": "#fff",
                  "border-color": theme(
                    "colors.gray.500",
                    colors2.gray[500]
                  ),
                  "border-width": borderWidth["DEFAULT"],
                  "border-radius": borderRadius.none,
                  "padding-top": spacing[2],
                  "padding-right": spacing[3],
                  "padding-bottom": spacing[2],
                  "padding-left": spacing[3],
                  "font-size": baseFontSize,
                  "line-height": baseLineHeight,
                  "--tw-shadow": "0 0 #0000",
                  "&:focus": {
                    outline: "2px solid transparent",
                    "outline-offset": "2px",
                    "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)",
                    "--tw-ring-offset-width": "0px",
                    "--tw-ring-offset-color": "#fff",
                    "--tw-ring-color": theme(
                      "colors.blue.600",
                      colors2.blue[600]
                    ),
                    "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
                    "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
                    "box-shadow": `var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow)`,
                    "border-color": theme(
                      "colors.blue.600",
                      colors2.blue[600]
                    )
                  }
                },
                [["input::placeholder", "textarea::placeholder"]]: {
                  color: theme("colors.gray.500", colors2.gray[500]),
                  opacity: "1"
                },
                ["::-webkit-datetime-edit-fields-wrapper"]: {
                  padding: "0"
                },
                ['input[type="time"]::-webkit-calendar-picker-indicator']: {
                  background: "none"
                },
                ["select:not([size])"]: {
                  "background-image": `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6">
                            <path stroke="${theme(
                      "colors.gray.500",
                      colors2.gray[500]
                    )}" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m1 1 4 4 4-4"/>
                          </svg>`
                  )}")`,
                  "background-position": `right ${spacing[3]} center`,
                  "background-repeat": `no-repeat`,
                  "background-size": `0.75em 0.75em`,
                  "padding-right": spacing[10],
                  "print-color-adjust": `exact`
                },
                [[`:is([dir=rtl]) select:not([size])`]]: {
                  backgroundPosition: `left ${spacing[3]} center`,
                  paddingRight: spacing[3],
                  paddingLeft: 0
                },
                ["[multiple]"]: {
                  "background-image": "initial",
                  "background-position": "initial",
                  "background-repeat": "unset",
                  "background-size": "initial",
                  "padding-right": spacing[3],
                  "print-color-adjust": "unset"
                },
                [[`[type='checkbox']`, `[type='radio']`]]: {
                  appearance: "none",
                  padding: "0",
                  "print-color-adjust": "exact",
                  display: "inline-block",
                  "vertical-align": "middle",
                  "background-origin": "border-box",
                  "user-select": "none",
                  "flex-shrink": "0",
                  height: spacing[4],
                  width: spacing[4],
                  color: theme("colors.blue.600", colors2.blue[600]),
                  "background-color": "#fff",
                  "border-color": theme(
                    "colors.gray.500",
                    colors2.gray[500]
                  ),
                  "border-width": borderWidth["DEFAULT"],
                  "--tw-shadow": "0 0 #0000"
                },
                [`[type='checkbox']`]: {
                  "border-radius": borderRadius["none"]
                },
                [`[type='radio']`]: {
                  "border-radius": "100%"
                },
                [[`[type='checkbox']:focus`, `[type='radio']:focus`]]: {
                  outline: "2px solid transparent",
                  "outline-offset": "2px",
                  "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-ring-offset-width": "2px",
                  "--tw-ring-offset-color": "#fff",
                  "--tw-ring-color": theme(
                    "colors.blue.600",
                    colors2.blue[600]
                  ),
                  "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
                  "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
                  "box-shadow": `var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow)`
                },
                [[
                  `[type='checkbox']:checked`,
                  `[type='radio']:checked`,
                  `.dark [type='checkbox']:checked`,
                  `.dark [type='radio']:checked`
                ]]: {
                  "border-color": `transparent`,
                  "background-color": `currentColor`,
                  "background-size": `0.55em 0.55em`,
                  "background-position": `center`,
                  "background-repeat": `no-repeat`
                },
                [`[type='checkbox']:checked`]: {
                  "background-image": `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 12">
                                <path stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M1 5.917 5.724 10.5 15 1.5"/>
                            </svg>`
                  )}")`,
                  "background-repeat": `no-repeat`,
                  "background-size": `0.55em 0.55em`,
                  "print-color-adjust": `exact`
                },
                [`[type='radio']:checked`]: {
                  "background-image": `url("${svgToDataUri(
                    `<svg viewBox="0 0 16 16" fill="white" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="3"/></svg>`
                  )}")`,
                  "background-size": `1em 1em`
                },
                [`.dark [type='radio']:checked`]: {
                  "background-image": `url("${svgToDataUri(
                    `<svg viewBox="0 0 16 16" fill="white" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="3"/></svg>`
                  )}")`,
                  "background-size": `1em 1em`
                },
                [`[type='checkbox']:indeterminate`]: {
                  "background-image": `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 12">
                            <path stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M0.5 6h14"/>
                            </svg>`
                  )}")`,
                  "background-color": `currentColor`,
                  "border-color": `transparent`,
                  "background-position": `center`,
                  "background-repeat": `no-repeat`,
                  "background-size": `0.55em 0.55em`,
                  "print-color-adjust": `exact`
                },
                [[
                  `[type='checkbox']:indeterminate:hover`,
                  `[type='checkbox']:indeterminate:focus`
                ]]: {
                  "border-color": "transparent",
                  "background-color": "currentColor"
                },
                [`[type='file']`]: {
                  background: "unset",
                  "border-color": "inherit",
                  "border-width": "0",
                  "border-radius": "0",
                  padding: "0",
                  "font-size": "unset",
                  "line-height": "inherit"
                },
                [`[type='file']:focus`]: {
                  outline: `1px auto inherit`
                },
                [[`input[type=file]::file-selector-button`]]: {
                  color: "white",
                  background: theme("colors.gray.800", colors2.gray[800]),
                  border: 0,
                  "font-weight": theme("fontWeight.medium"),
                  "font-size": theme("fontSize.sm"),
                  cursor: "pointer",
                  "padding-top": spacing[2.5],
                  "padding-bottom": spacing[2.5],
                  "padding-left": spacing[8],
                  "padding-right": spacing[4],
                  "margin-inline-start": "-1rem",
                  "margin-inline-end": "1rem",
                  "&:hover": {
                    background: theme(
                      "colors.gray.700",
                      colors2.gray[700]
                    )
                  }
                },
                [[`:is([dir=rtl]) input[type=file]::file-selector-button`]]: {
                  paddingRight: spacing[8],
                  paddingLeft: spacing[4]
                },
                [[`.dark input[type=file]::file-selector-button`]]: {
                  color: "white",
                  background: theme("colors.gray.600", colors2.gray[600]),
                  "&:hover": {
                    background: theme(
                      "colors.gray.500",
                      colors2.gray[500]
                    )
                  }
                },
                [[`input[type="range"]::-webkit-slider-thumb`]]: {
                  height: spacing[5],
                  width: spacing[5],
                  background: theme("colors.blue.600", colors2.blue[600]),
                  "border-radius": borderRadius.full,
                  border: 0,
                  appearance: "none",
                  "-moz-appearance": "none",
                  "-webkit-appearance": "none",
                  cursor: "pointer"
                },
                [[`input[type="range"]:disabled::-webkit-slider-thumb`]]: {
                  background: theme("colors.gray.400", colors2.gray[400])
                },
                [[
                  `.dark input[type="range"]:disabled::-webkit-slider-thumb`
                ]]: {
                  background: theme("colors.gray.500", colors2.gray[500])
                },
                [[`input[type="range"]:focus::-webkit-slider-thumb`]]: {
                  outline: "2px solid transparent",
                  "outline-offset": "2px",
                  "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
                  "--tw-ring-shadow": "var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color)",
                  "box-shadow": "var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)",
                  "--tw-ring-opacity": 1,
                  "--tw-ring-color": "rgb(164 202 254 / var(--tw-ring-opacity))"
                },
                [[`input[type="range"]::-moz-range-thumb`]]: {
                  height: spacing[5],
                  width: spacing[5],
                  background: theme("colors.blue.600", colors2.blue[600]),
                  "border-radius": borderRadius.full,
                  border: 0,
                  appearance: "none",
                  "-moz-appearance": "none",
                  "-webkit-appearance": "none",
                  cursor: "pointer"
                },
                [[`input[type="range"]:disabled::-moz-range-thumb`]]: {
                  background: theme("colors.gray.400", colors2.gray[400])
                },
                [[`.dark input[type="range"]:disabled::-moz-range-thumb`]]: {
                  background: theme(
                    "colors.gray.500",
                    colors2.gray[500]
                  )
                },
                [[`input[type="range"]::-moz-range-progress`]]: {
                  background: theme("colors.blue.500", colors2.blue[500])
                },
                [[`input[type="range"]::-ms-fill-lower`]]: {
                  background: theme("colors.blue.500", colors2.blue[500])
                },
                [[`input[type="range"].range-sm::-webkit-slider-thumb`]]: {
                  height: spacing[4],
                  width: spacing[4]
                },
                [[`input[type="range"].range-lg::-webkit-slider-thumb`]]: {
                  height: spacing[6],
                  width: spacing[6]
                },
                [[`input[type="range"].range-sm::-moz-range-thumb`]]: {
                  height: spacing[4],
                  width: spacing[4]
                },
                [[`input[type="range"].range-lg::-moz-range-thumb`]]: {
                  height: spacing[6],
                  width: spacing[6]
                },
                // remove from v2.x+
                [[".toggle-bg:after"]]: {
                  content: '""',
                  position: "absolute",
                  top: spacing[0.5],
                  left: spacing[0.5],
                  background: "white",
                  "border-color": theme(
                    "colors.gray.300",
                    colors2.gray[300]
                  ),
                  "border-width": borderWidth["DEFAULT"],
                  "border-radius": borderRadius.full,
                  height: theme("height.5"),
                  width: theme("width.5"),
                  "transition-property": "background-color,border-color,color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter",
                  "transition-duration": ".15s",
                  "box-shadow": "var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color)"
                },
                [["input:checked + .toggle-bg:after"]]: {
                  transform: "translateX(100%);",
                  "border-color": "white"
                },
                [["input:checked + .toggle-bg"]]: {
                  background: theme("colors.blue.600", colors2.gray[600]),
                  "border-color": theme(
                    "colors.blue.600",
                    colors2.gray[600]
                  )
                }
              });
            }
            if (wysiwyg) {
              addComponents({
                ".selectedCell": {
                  backgroundColor: `${theme(
                    "colors.gray.50",
                    colors2.gray[50]
                  )}`
                },
                ".dark .selectedCell": {
                  backgroundColor: `${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )}`
                }
              });
            }
            if (datatables) {
              addComponents({
                ".datatable-wrapper": {
                  width: "100%"
                },
                ".datatable-wrapper .datatable-top": {
                  display: "flex",
                  justifyContent: "space-between",
                  flexDirection: "column-reverse",
                  alignItems: "start",
                  gap: `${theme("spacing.4", spacing[4])}`,
                  marginBottom: `${theme("spacing.4", spacing[4])}`
                },
                ".datatable-wrapper .datatable-search .datatable-input, .datatable-wrapper .datatable-input": {
                  color: `${theme(
                    "colors.gray.900",
                    colors2.gray[900]
                  )}`,
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )}`,
                  border: `1px solid ${theme("colors.gray.300")}`,
                  borderRadius: `${theme(
                    "borderRadius.lg",
                    borderRadius.lg
                  )}`,
                  backgroundColor: `${theme(
                    "colors.gray.50",
                    colors2.gray[50]
                  )}`,
                  minWidth: "16rem"
                },
                ".dark .datatable-wrapper .datatable-search .datatable-input, .dark .datatable-wrapper .datatable-input": {
                  color: "white",
                  backgroundColor: `${theme(
                    "colors.gray.800",
                    colors2.gray[800]
                  )}`,
                  border: `1px solid ${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )}`
                },
                ".datatable-wrapper thead th .datatable-input": {
                  backgroundColor: "white",
                  fontWeight: `${theme("fontWeight.normal")}`,
                  color: `${theme("colors.gray.900", colors2.gray[900])}`,
                  paddingTop: `.35rem`,
                  paddingBottom: `.35rem`,
                  minWidth: "0"
                },
                ".dark .datatable-wrapper thead th .datatable-input": {
                  backgroundColor: `${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )}`,
                  borderColor: `${theme(
                    "colors.gray.600",
                    colors2.gray[600]
                  )}`,
                  color: "white"
                },
                ".datatable-wrapper .datatable-top .datatable-dropdown": {
                  color: `${theme("colors.gray.500", colors2.gray[500])}`,
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )}`
                },
                ".dark .datatable-wrapper .datatable-top .datatable-dropdown": {
                  color: `${theme(
                    "colors.gray.400",
                    colors2.gray[400]
                  )}`
                },
                ".datatable-wrapper .datatable-top .datatable-dropdown .datatable-selector": {
                  backgroundColor: `${theme("colors.gray.50")}`,
                  color: `${theme(
                    "colors.gray.900",
                    colors2.gray[900]
                  )}`,
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )}`,
                  border: `1px solid ${theme("colors.gray.300")}`,
                  borderRadius: `${theme(
                    "borderRadius.lg",
                    borderRadius.lg
                  )}`,
                  marginRight: `${theme("spacing.1", spacing[1])}`,
                  minWidth: "4rem"
                },
                ".dark .datatable-wrapper .datatable-top .datatable-dropdown .datatable-selector": {
                  backgroundColor: `${theme(
                    "colors.gray.800",
                    colors2.gray[800]
                  )}`,
                  border: `1px solid ${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )}`,
                  color: "white"
                },
                ".datatable-wrapper .datatable-container thead tr.search-filtering-row th": {
                  paddingTop: "0"
                },
                ".datatable-wrapper .datatable-search .datatable-input:focus": {
                  borderColor: `${theme(
                    "colors.blue.600",
                    colors2.blue[600]
                  )}`
                },
                ".datatable-wrapper .datatable-container": {
                  overflowX: "auto"
                },
                ".datatable-wrapper .datatable-table": {
                  width: "100%",
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )}`,
                  color: `${theme("colors.gray.500", colors2.gray[500])}`,
                  textAlign: "left"
                },
                ".dark .datatable-wrapper .datatable-table": {
                  color: `${theme("colors.gray.400", colors2.gray[400])}`
                },
                ".datatable-wrapper .datatable-table thead": {
                  fontSize: `${theme(
                    "fontSize.xs",
                    defaultTheme2.fontSize.xs
                  )}`,
                  color: `${theme("colors.gray.500", colors2.gray[500])}`,
                  backgroundColor: `${theme(
                    "colors.gray.50",
                    colors2.gray[50]
                  )}`
                },
                ".dark .datatable-wrapper .datatable-table thead": {
                  color: `${theme("colors.gray.400", colors2.gray[400])}`,
                  backgroundColor: `${theme(
                    "colors.gray.800",
                    colors2.gray[800]
                  )}`
                },
                ".datatable-wrapper .datatable-table thead th": {
                  whiteSpace: "nowrap"
                },
                ".datatable-wrapper .datatable-table thead th, .datatable-wrapper .datatable-table tbody th, .datatable-wrapper .datatable-table tbody td": {
                  width: "auto !important",
                  paddingTop: `${theme("spacing.3", spacing[3])}`,
                  paddingBottom: `${theme("spacing.3", spacing[3])}`,
                  paddingLeft: `${theme("spacing.6", spacing[6])}`,
                  paddingRight: `${theme("spacing.6", spacing[6])}`
                },
                ".datatable-wrapper .datatable-table thead th .datatable-sorter, .datatable-wrapper .datatable-table thead th": {
                  textTransform: "uppercase"
                },
                ".datatable-wrapper .datatable-table thead th .datatable-sorter:hover, .datatable-wrapper .datatable-table thead th.datatable-ascending .datatable-sorter, .datatable-wrapper .datatable-table thead th.datatable-descending .datatable-sorter": {
                  color: `${theme(
                    "colors.gray.900",
                    colors2.blue[900]
                  )}`
                },
                ".dark .datatable-wrapper .datatable-table thead th .datatable-sorter:hover, .dark .datatable-wrapper .datatable-table thead th.datatable-ascending .datatable-sorter, .dark .datatable-wrapper .datatable-table thead th.datatable-descending .datatable-sorter": {
                  color: "white"
                },
                ".datatable-wrapper .datatable-table tbody tr.selected": {
                  backgroundColor: `${theme(
                    "colors.gray.100",
                    colors2.gray[100]
                  )}`
                },
                ".dark .datatable-wrapper .datatable-table tbody tr.selected": {
                  backgroundColor: `${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )}`
                },
                ".datatable-wrapper .datatable-table tbody tr": {
                  borderBottom: `1px solid ${theme("colors.gray.200")}`
                },
                ".dark .datatable-wrapper .datatable-table tbody tr": {
                  borderBottom: `1px solid ${theme("colors.gray.700")}`
                },
                ".datatable-wrapper .datatable-table .datatable-empty": {
                  textAlign: "center"
                },
                ".datatable-wrapper .datatable-bottom": {
                  display: "flex",
                  flexDirection: "column",
                  justifyContent: "space-between",
                  alignItems: "start",
                  marginTop: `${theme("spacing.4", spacing[4])}`,
                  gap: `${theme("spacing.4", spacing[4])}`
                },
                ".datatable-wrapper .datatable-bottom .datatable-info": {
                  color: `${theme("colors.gray.500", colors2.gray[500])}`,
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )}`
                },
                ".dark .datatable-wrapper .datatable-bottom .datatable-info": {
                  color: `${theme(
                    "colors.gray.400",
                    colors2.gray[400]
                  )}`
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list": {
                  display: "flex",
                  alignItems: "center",
                  height: spacing[8],
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )}`
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item-link": {
                  display: "flex",
                  alignItems: "center",
                  color: `${theme(
                    "colors.gray.500",
                    colors2.gray[500]
                  )}`,
                  fontWeight: `${theme("fontWeight.medium")}`,
                  paddingLeft: `${theme("spacing.3", spacing[3])}`,
                  paddingRight: `${theme("spacing.3", spacing[3])}`,
                  height: spacing[8],
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )}`,
                  borderTop: `1px solid ${theme("colors.gray.300")}`,
                  borderBottom: `1px solid ${theme(
                    "colors.gray.300"
                  )}`,
                  borderRight: `1px solid ${theme(
                    "colors.gray.300"
                  )}`
                },
                ".dark .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item-link": {
                  color: `${theme(
                    "colors.gray.400",
                    colors2.gray[400]
                  )}`,
                  borderColor: `${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )}`
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:first-of-type, .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:last-of-type": {
                  position: "relative"
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:first-of-type .datatable-pagination-list-item-link, .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:last-of-type .datatable-pagination-list-item-link": {
                  color: "transparent"
                },
                ".dark .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:first-of-type .datatable-pagination-list-item-link, .dark .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:last-of-type .datatable-pagination-list-item-link": {
                  color: "transparent"
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:first-of-type .datatable-pagination-list-item-link::after": {
                  content: `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24">
                                    <path stroke="${theme(
                      "colors.gray.500",
                      colors2.gray[500]
                    )}" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m14 8-4 4 4 4"/>
                                </svg>`
                  )}")`,
                  position: "absolute",
                  top: "50%",
                  left: "50%",
                  width: "1.3rem",
                  height: "1.3rem",
                  transform: "translate(-50%, -50%)"
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:first-of-type .datatable-pagination-list-item-link:hover::after": {
                  content: `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24">
                                    <path stroke="${theme(
                      "colors.gray.900",
                      colors2.gray[900]
                    )}" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m14 8-4 4 4 4"/>
                                </svg>`
                  )}")`
                },
                ".dark .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:first-of-type .datatable-pagination-list-item-link::after": {
                  content: `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24">
                                    <path stroke="${theme(
                      "colors.gray.400",
                      colors2.gray[400]
                    )}" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m14 8-4 4 4 4"/>
                                </svg>`
                  )}")`
                },
                ".dark .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:first-of-type .datatable-pagination-list-item-link:hover::after": {
                  content: `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24">
                                    <path stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m14 8-4 4 4 4"/>
                                </svg>`
                  )}")`
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:last-of-type .datatable-pagination-list-item-link::after": {
                  content: `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24">
                                <path stroke="${theme(
                      "colors.gray.500",
                      colors2.gray[500]
                    )}" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m10 16 4-4-4-4"/>
                                </svg>
                                `
                  )}")`,
                  position: "absolute",
                  top: "50%",
                  right: "50%",
                  width: "1.3rem",
                  height: "1.3rem",
                  transform: "translate(50%, -50%)"
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:last-of-type .datatable-pagination-list-item-link:hover::after": {
                  content: `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24">
                                <path stroke="${theme(
                      "colors.gray.900",
                      colors2.gray[900]
                    )}" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m10 16 4-4-4-4"/>
                                </svg>
                                `
                  )}")`
                },
                ".dark .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:last-of-type .datatable-pagination-list-item-link::after": {
                  content: `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24">
                                <path stroke="${theme(
                      "colors.gray.400",
                      colors2.gray[400]
                    )}" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m10 16 4-4-4-4"/>
                                </svg>
                                `
                  )}")`
                },
                ".dark .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:last-of-type .datatable-pagination-list-item-link:hover::after": {
                  content: `url("${svgToDataUri(
                    `<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24">
                                <path stroke="white" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m10 16 4-4-4-4"/>
                                </svg>
                                `
                  )}")`
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:first-of-type .datatable-pagination-list-item-link": {
                  borderTopLeftRadius: `${theme(
                    "borderRadius.lg",
                    borderRadius.lg
                  )}`,
                  borderBottomLeftRadius: `${theme(
                    "borderRadius.lg",
                    borderRadius.lg
                  )}`,
                  borderLeft: `1px solid ${theme("colors.gray.300")}`
                },
                ".dark .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:first-of-type .datatable-pagination-list-item-link": {
                  borderLeft: `1px solid ${theme("colors.gray.700")}`
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item:last-of-type .datatable-pagination-list-item-link": {
                  borderTopRightRadius: `${theme(
                    "borderRadius.lg",
                    borderRadius.lg
                  )}`,
                  borderBottomRightRadius: `${theme(
                    "borderRadius.lg",
                    borderRadius.lg
                  )}`,
                  borderLeft: 0
                },
                ".datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item-link:hover": {
                  backgroundColor: `${theme("colors.gray.50")}`,
                  color: `${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )}`
                },
                ".dark .datatable-wrapper .datatable-bottom .datatable-pagination .datatable-pagination-list-item-link:hover": {
                  backgroundColor: `${theme("colors.gray.700")}`,
                  color: "white"
                },
                "@screen sm": {
                  ".datatable-wrapper .datatable-top": {
                    flexDirection: "row-reverse",
                    alignItems: "center"
                  },
                  ".datatable-wrapper .datatable-bottom": {
                    flexDirection: "row",
                    alignItems: "center"
                  }
                }
              });
            }
            if (charts) {
              addComponents({
                ".apexcharts-canvas .apexcharts-tooltip": {
                  backgroundColor: "white",
                  color: `${theme("colors.gray.500", colors2.gray[500])}`,
                  border: "0 !important",
                  borderRadius: `${theme(
                    "borderRadius.DEFAULT",
                    borderRadius.DEFAULT
                  )}`,
                  // padding: `${theme('spacing.3', spacing[3])}`,
                  boxShadow: `${theme("boxShadow.md", boxShadow.md)}`
                },
                ".dark .apexcharts-canvas .apexcharts-tooltip": {
                  backgroundColor: `${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )}`,
                  color: `${theme("colors.gray.400", colors2.gray[400])}`,
                  borderColor: "transparent",
                  boxShadow: `${theme("boxShadow.md", boxShadow.md)}`
                },
                ".apexcharts-canvas .apexcharts-tooltip .apexcharts-tooltip-title": {
                  paddingTop: `${theme("spacing.2", spacing[2])}`,
                  paddingBottom: `${theme("spacing.2", spacing[2])}`,
                  paddingRight: `${theme("spacing.3", spacing[3])}`,
                  paddingLeft: `${theme("spacing.3", spacing[3])}`,
                  marginBottom: `${theme("spacing.3", spacing[3])}`,
                  backgroundColor: `${theme(
                    "colors.gray.100",
                    colors2.gray[100]
                  )}`,
                  borderBottomColor: `${theme(
                    "colors.gray.200",
                    colors2.gray[200]
                  )}`,
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )} !important`,
                  fontWeight: `${theme(
                    "fontWeight.normal",
                    defaultTheme2.fontWeight.normal
                  )}`,
                  color: `${theme(
                    "colors.gray.500",
                    colors2.gray[500]
                  )}`
                },
                ".dark .apexcharts-canvas .apexcharts-tooltip .apexcharts-tooltip-title": {
                  backgroundColor: `${theme(
                    "colors.gray.600",
                    colors2.gray[600]
                  )}`,
                  borderColor: `${theme(
                    "colors.gray.500",
                    colors2.gray[500]
                  )}`,
                  color: `${theme(
                    "colors.gray.400",
                    colors2.gray[400]
                  )}`
                },
                ".apexcharts-canvas .apexcharts-xaxistooltip": {
                  color: `${theme("colors.gray.500", colors2.gray[500])}`,
                  paddingTop: `${theme("spacing.2", spacing[2])}`,
                  paddingBottom: `${theme("spacing.2", spacing[2])}`,
                  paddingRight: `${theme("spacing.3", spacing[3])}`,
                  paddingLeft: `${theme("spacing.3", spacing[3])}`,
                  borderColor: `transparent`,
                  backgroundColor: "white",
                  borderRadius: `${theme(
                    "borderRadius.DEFAULT",
                    borderRadius.DEFAULT
                  )}`,
                  boxShadow: `${theme("boxShadow.md", boxShadow.md)}`
                },
                ".dark .apexcharts-canvas .apexcharts-xaxistooltip": {
                  color: `${theme("colors.gray.400", colors2.gray[400])}`,
                  backgroundColor: `${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )}`
                },
                ".apexcharts-canvas .apexcharts-tooltip .apexcharts-tooltip-text-y-label": {
                  color: `${theme(
                    "colors.gray.500",
                    colors2.gray[500]
                  )}`,
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )}`
                },
                ".dark .apexcharts-canvas .apexcharts-tooltip .apexcharts-tooltip-text-y-label": {
                  color: `${theme(
                    "colors.gray.400",
                    colors2.gray[400]
                  )}`
                },
                ".apexcharts-canvas .apexcharts-tooltip .apexcharts-tooltip-text-y-value": {
                  color: `${theme(
                    "colors.gray.900",
                    colors2.gray[900]
                  )}`,
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )}`
                },
                ":is([dir=rtl]) .apexcharts-tooltip .apexcharts-tooltip-marker": {
                  marginRight: `${theme("spacing.0", spacing[0])}`,
                  marginLeft: `${theme("spacing.1.5", spacing[1.5])}`
                },
                ".dark .apexcharts-canvas .apexcharts-tooltip .apexcharts-tooltip-text-y-value": {
                  color: "white"
                },
                ".apexcharts-canvas .apexcharts-xaxistooltip-text": {
                  fontWeight: `${theme(
                    "fontWeight.normal",
                    defaultTheme2.fontWeight.normal
                  )}`,
                  fontSize: `${theme(
                    "fontSize.sm",
                    defaultTheme2.fontSize.sm
                  )} !important`
                },
                ".apexcharts-canvas .apexcharts-xaxistooltip:after, .apexcharts-canvas .apexcharts-xaxistooltip:before": {
                  borderBottomColor: "white"
                },
                ".apexcharts-canvas .apexcharts-xaxistooltip:after": {
                  borderWidth: "8px",
                  marginLeft: "-8px"
                },
                ".apexcharts-canvas .apexcharts-xaxistooltip:before": {
                  borderWidth: "10px",
                  marginLeft: "-10px"
                },
                ".dark .apexcharts-canvas .apexcharts-xaxistooltip:after, .dark .apexcharts-canvas .apexcharts-xaxistooltip:before": {
                  borderBottomColor: `${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )}`
                },
                ".apexcharts-canvas .apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-y-group": {
                  padding: "0"
                },
                ".apexcharts-canvas .apexcharts-tooltip-series-group.apexcharts-active": {
                  paddingLeft: `${theme("spacing.3", spacing[3])}`,
                  paddingRight: `${theme("spacing.3", spacing[3])}`,
                  paddingBottom: `${theme("spacing.3", spacing[3])}`,
                  backgroundColor: "white !important",
                  color: `${theme(
                    "colors.gray.500",
                    colors2.gray[500]
                  )} !important`
                },
                ".dark .apexcharts-canvas .apexcharts-tooltip-series-group.apexcharts-active": {
                  backgroundColor: `${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )} !important`,
                  color: `${theme(
                    "colors.gray.400",
                    colors2.gray[400]
                  )} !important`
                },
                ".apexcharts-canvas .apexcharts-tooltip-series-group.apexcharts-active:first-of-type": {
                  paddingTop: `${theme("spacing.3", spacing[3])}`
                },
                ".apexcharts-canvas .apexcharts-legend": {
                  padding: "0 !important"
                },
                ".apexcharts-canvas .apexcharts-legend-text": {
                  fontSize: `${theme(
                    "fontSize.xs",
                    defaultTheme2.fontSize.xs
                  )}`,
                  fontWeight: `${theme(
                    "fontWeight.medium",
                    defaultTheme2.fontWeight.medium
                  )} !important`,
                  paddingLeft: `${theme("spacing.5", spacing[5])}`,
                  color: `${theme(
                    "colors.gray.500",
                    colors2.gray[500]
                  )} !important`
                },
                ":is([dir=rtl]) .apexcharts-canvas .apexcharts-legend-text": {
                  paddingRight: `${theme("spacing.2", spacing[2])}`
                },
                ".apexcharts-canvas .apexcharts-legend-text:not(.apexcharts-inactive-legend):hover": {
                  color: `${theme(
                    "colors.gray.900",
                    colors2.gray[900]
                  )} !important`
                },
                ".dark .apexcharts-canvas .apexcharts-legend-text": {
                  color: `${theme(
                    "colors.gray.400",
                    colors2.gray[400]
                  )} !important`
                },
                ".dark .apexcharts-canvas .apexcharts-legend-text:not(.apexcharts-inactive-legend):hover": {
                  color: `white !important`
                },
                ".apexcharts-canvas .apexcharts-legend-series": {
                  marginLeft: `${theme("spacing.2", spacing[2])}`,
                  marginRight: `${theme("spacing.2", spacing[2])}`,
                  marginBottom: `${theme(
                    "spacing.1",
                    spacing[1]
                  )} !important`,
                  display: "flex",
                  alignItems: "center"
                },
                ".apexcharts-datalabels-group .apexcharts-text.apexcharts-datalabel-value": {
                  fill: `${theme(
                    "colors.gray.900",
                    colors2.gray[900]
                  )} !important`,
                  fontSize: `${theme("fontSize.3xl")}`,
                  fontWeight: `${theme(
                    "fontWeight.bold",
                    defaultTheme2.fontWeight.bold
                  )}`
                },
                ".dark .apexcharts-canvas .apexcharts-datalabels-group .apexcharts-text.apexcharts-datalabel-value": {
                  fill: `white !important`
                },
                ".apexcharts-canvas .apexcharts-datalabels-group .apexcharts-text.apexcharts-datalabel-label": {
                  fill: `${theme(
                    "colors.gray.500",
                    colors2.gray[500]
                  )} !important`,
                  fontSize: `${theme("fontSize.base")}`,
                  fontWeight: `${theme(
                    "fontWeight.normal",
                    defaultTheme2.fontWeight.normal
                  )}`
                },
                ".dark .apexcharts-canvas .apexcharts-datalabels-group .apexcharts-text.apexcharts-datalabel-label": {
                  fill: `${theme(
                    "colors.gray.400",
                    colors2.gray[400]
                  )} !important`
                },
                ".apexcharts-canvas .apexcharts-datalabels .apexcharts-text.apexcharts-pie-label": {
                  fontSize: `${theme("fontSize.xs")} !important`,
                  fontWeight: `${theme(
                    "fontWeight.semibold",
                    defaultTheme2.fontWeight.semibold
                  )} !important`,
                  textShadow: `${theme(
                    "boxShadow.none",
                    boxShadow.none
                  )} !important`,
                  filter: `none !important`
                },
                ".apexcharts-gridline, .apexcharts-xcrosshairs, .apexcharts-ycrosshairs": {
                  stroke: `${theme(
                    "colors.gray.200",
                    colors2.gray[200]
                  )} !important`
                },
                ".dark .apexcharts-gridline, .dark .apexcharts-xcrosshairs, .dark .apexcharts-ycrosshairs": {
                  stroke: `${theme(
                    "colors.gray.700",
                    colors2.gray[700]
                  )} !important`
                }
              });
            }
          };
        },
        function(options = {}) {
          const {
            charts = false,
            datatables = false,
            forms: forms2 = true,
            tooltips = true,
            wysiwyg = false
          } = options;
          const safelist = [
            "z-40",
            "w-64",
            "w-1/2",
            "rounded-l-lg",
            "rounded-r-lg",
            "rounded-s-lg",
            "rounded-e-lg",
            "bg-gray-200",
            "grid-cols-4",
            "grid-cols-7",
            "h-6",
            "leading-6",
            "h-9",
            "leading-9",
            "shadow-lg",
            "!bg-gray-50",
            "dark:!bg-gray-700",
            "selectedCell"
          ];
          if (charts) {
            safelist.push({ pattern: /^apexcharts-.*$/ });
          }
          if (charts) {
            safelist.push({ pattern: /^datatable-.*$/ });
          }
          return {
            safelist,
            darkMode: "class",
            // or 'media' or 'class',
            theme: {
              extend: {
                height: {
                  modal: "calc(100% - 2rem)"
                },
                boxShadow: {
                  "sm-light": "0 2px 5px 0px rgba(255, 255, 255, 0.08)"
                },
                colors: {
                  transparent: "transparent",
                  white: "#ffffff",
                  black: "#000000",
                  gray: {
                    50: "#F9FAFB",
                    100: "#F3F4F6",
                    200: "#E5E7EB",
                    300: "#D1D5DB",
                    400: "#9CA3AF",
                    500: "#6B7280",
                    600: "#4B5563",
                    700: "#374151",
                    800: "#1F2937",
                    900: "#111827"
                  },
                  red: {
                    50: "#FDF2F2",
                    100: "#FDE8E8",
                    200: "#FBD5D5",
                    300: "#F8B4B4",
                    400: "#F98080",
                    500: "#F05252",
                    600: "#E02424",
                    700: "#C81E1E",
                    800: "#9B1C1C",
                    900: "#771D1D"
                  },
                  orange: {
                    50: "#FFF8F1",
                    100: "#FEECDC",
                    200: "#FCD9BD",
                    300: "#FDBA8C",
                    400: "#FF8A4C",
                    500: "#FF5A1F",
                    600: "#D03801",
                    700: "#B43403",
                    800: "#8A2C0D",
                    900: "#771D1D"
                  },
                  yellow: {
                    50: "#FDFDEA",
                    100: "#FDF6B2",
                    200: "#FCE96A",
                    300: "#FACA15",
                    400: "#E3A008",
                    500: "#C27803",
                    600: "#9F580A",
                    700: "#8E4B10",
                    800: "#723B13",
                    900: "#633112"
                  },
                  green: {
                    50: "#F3FAF7",
                    100: "#DEF7EC",
                    200: "#BCF0DA",
                    300: "#84E1BC",
                    400: "#31C48D",
                    500: "#0E9F6E",
                    600: "#057A55",
                    700: "#046C4E",
                    800: "#03543F",
                    900: "#014737"
                  },
                  teal: {
                    50: "#EDFAFA",
                    100: "#D5F5F6",
                    200: "#AFECEF",
                    300: "#7EDCE2",
                    400: "#16BDCA",
                    500: "#0694A2",
                    600: "#047481",
                    700: "#036672",
                    800: "#05505C",
                    900: "#014451"
                  },
                  blue: {
                    50: "#EBF5FF",
                    100: "#E1EFFE",
                    200: "#C3DDFD",
                    300: "#A4CAFE",
                    400: "#76A9FA",
                    500: "#3F83F8",
                    600: "#1C64F2",
                    700: "#1A56DB",
                    800: "#1E429F",
                    900: "#233876"
                  },
                  indigo: {
                    50: "#F0F5FF",
                    100: "#E5EDFF",
                    200: "#CDDBFE",
                    300: "#B4C6FC",
                    400: "#8DA2FB",
                    500: "#6875F5",
                    600: "#5850EC",
                    700: "#5145CD",
                    800: "#42389D",
                    900: "#362F78"
                  },
                  purple: {
                    50: "#F6F5FF",
                    100: "#EDEBFE",
                    200: "#DCD7FE",
                    300: "#CABFFD",
                    400: "#AC94FA",
                    500: "#9061F9",
                    600: "#7E3AF2",
                    700: "#6C2BD9",
                    800: "#5521B5",
                    900: "#4A1D96"
                  },
                  pink: {
                    50: "#FDF2F8",
                    100: "#FCE8F3",
                    200: "#FAD1E8",
                    300: "#F8B4D9",
                    400: "#F17EB8",
                    500: "#E74694",
                    600: "#D61F69",
                    700: "#BF125D",
                    800: "#99154B",
                    900: "#751A3D"
                  }
                }
              }
            }
          };
        }
      );
      return plugin_1;
    }
    var pluginExports = requirePlugin();
    const flowbitePlugin = /* @__PURE__ */ getDefaultExportFromCjs(pluginExports);
    const tailwindConfigFile = {
      content: [
        "./vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php",
        "./storage/framework/views/*.php",
        "./resources/views/**/*.blade.php",
        "./resources/**/*.blade.php",
        "./resources/**/*.js",
        "./resources/**/*.ts",
        "./resources/**/*.tsx"
      ],
      theme: {
        extend: {
          keyframes: {
            "infinite-scroll": {
              "0%": { transform: "translateX(0)" },
              "100%": { transform: "translateX(calc(-50% - 1rem))" }
            },
            "infinite-scroll-partner": {
              "0%": { transform: "translateX(0)" },
              "100%": { transform: "translateX(calc(-50% - 1rem))" }
            }
          },
          animation: {
            "infinite-scroll": "infinite-scroll 40s linear infinite",
            "infinite-scroll-partner": "infinite-scroll-partner 25s linear infinite"
          },
          fontFamily: {
            sans: ["Figtree", ...defaultTheme.fontFamily.sans]
          },
          borderRadius: {
            lg: "var(--radius)",
            md: "calc(var(--radius) - 2px)",
            sm: "calc(var(--radius) - 4px)"
          },
          colors: {
            gray: {
              50: "#F9FAFB",
              100: "#F3F4F6",
              200: "#E5E7EB",
              300: "#BFC4CD",
              400: "#9CA3AF",
              500: "#6B7280",
              600: "#4B5563",
              700: "#374151",
              800: "#1F2937",
              900: "#111827",
              950: "#030712"
            },
            violet: {
              50: "#F1EEFF",
              100: "#E6E1FF",
              200: "#D2CBFF",
              300: "#B7ACFF",
              400: "#9C8CFF",
              500: "#8470FF",
              600: "#755FF8",
              700: "#5D47DE",
              800: "#4634B1",
              900: "#2F227C",
              950: "#1C1357"
            },
            sky: {
              50: "#E3F3FF",
              100: "#D1ECFF",
              200: "#B6E1FF",
              300: "#A0D7FF",
              400: "#7BC8FF",
              500: "#67BFFF",
              600: "#56B1F3",
              700: "#3193DA",
              800: "#1C71AE",
              900: "#124D79",
              950: "#0B324F"
            },
            green: {
              50: "#D2FFE2",
              100: "#B1FDCD",
              200: "#8BF0B0",
              300: "#67E294",
              400: "#4BD37D",
              500: "#3EC972",
              600: "#34BD68",
              700: "#239F52",
              800: "#15773A",
              900: "#0F5429",
              950: "#0A3F1E",
              1e3: "#2FEA9B",
              1100: "#7FDD53"
            },
            red: {
              50: "#FFE8E8",
              100: "#FFD1D1",
              200: "#FFB2B2",
              300: "#FF9494",
              400: "#FF7474",
              500: "#FF5656",
              600: "#FA4949",
              700: "#E63939",
              800: "#C52727",
              900: "#941818",
              950: "#600F0F"
            },
            yellow: {
              50: "#FFF2C9",
              100: "#FFE7A0",
              200: "#FFE081",
              300: "#FFD968",
              400: "#F7CD4C",
              500: "#F0BB33",
              600: "#DFAD2B",
              700: "#BC9021",
              800: "#816316",
              900: "#4F3D0E",
              950: "#342809"
            },
            fontFamily: {
              inter: ["Inter", "sans-serif"]
            },
            fontSize: {
              xs: ["0.75rem", { lineHeight: "1.5" }],
              sm: ["0.875rem", { lineHeight: "1.5715" }],
              base: [
                "1rem",
                { lineHeight: "1.5", letterSpacing: "-0.01em" }
              ],
              lg: [
                "1.125rem",
                { lineHeight: "1.5", letterSpacing: "-0.01em" }
              ],
              xl: [
                "1.25rem",
                { lineHeight: "1.5", letterSpacing: "-0.01em" }
              ],
              "2xl": [
                "1.5rem",
                { lineHeight: "1.33", letterSpacing: "-0.01em" }
              ],
              "3xl": [
                "1.88rem",
                { lineHeight: "1.33", letterSpacing: "-0.01em" }
              ],
              "4xl": [
                "2.25rem",
                { lineHeight: "1.25", letterSpacing: "-0.02em" }
              ],
              "5xl": [
                "3rem",
                { lineHeight: "1.25", letterSpacing: "-0.02em" }
              ],
              "6xl": [
                "3.75rem",
                { lineHeight: "1.2", letterSpacing: "-0.02em" }
              ]
            },
            screens: {
              xs: "480px"
            },
            borderWidth: {
              3: "3px"
            },
            minWidth: {
              36: "9rem",
              44: "11rem",
              56: "14rem",
              60: "15rem",
              72: "18rem",
              80: "20rem"
            },
            maxWidth: {
              "8xl": "88rem",
              "9xl": "96rem"
            },
            zIndex: {
              60: "60"
            },
            background: "hsl(var(--background))",
            foreground: "hsl(var(--foreground))",
            card: {
              DEFAULT: "hsl(var(--card))",
              foreground: "hsl(var(--card-foreground))"
            },
            popover: {
              DEFAULT: "hsl(var(--popover))",
              foreground: "hsl(var(--popover-foreground))"
            },
            primary: {
              DEFAULT: "hsl(var(--primary))",
              foreground: "hsl(var(--primary-foreground))"
            },
            secondary: {
              DEFAULT: "hsl(var(--secondary))",
              foreground: "hsl(var(--secondary-foreground))"
            },
            muted: {
              DEFAULT: "hsl(var(--muted))",
              foreground: "hsl(var(--muted-foreground))"
            },
            accent: {
              DEFAULT: "hsl(var(--accent))",
              foreground: "hsl(var(--accent-foreground))"
            },
            destructive: {
              DEFAULT: "hsl(var(--destructive))",
              foreground: "hsl(var(--destructive-foreground))"
            },
            border: "hsl(var(--border))",
            input: "hsl(var(--input))",
            ring: "hsl(var(--ring))",
            chart: {
              1: "hsl(var(--chart-1))",
              2: "hsl(var(--chart-2))",
              3: "hsl(var(--chart-3))",
              4: "hsl(var(--chart-4))",
              5: "hsl(var(--chart-5))"
            }
          },
          backgroundImage: {
            "button-bg": "url('/public/buttonBg.svg')"
          }
        }
      },
      plugins: [forms, tailwindcssAnimate, flowbitePlugin]
    };
    const tailwindConfig = () => {
      return resolveConfig(tailwindConfigFile);
    };
    const hexToRGB = (h) => {
      let r = 0;
      let g = 0;
      let b = 0;
      if (h.length === 4) {
        r = `0x${h[1]}${h[1]}`;
        g = `0x${h[2]}${h[2]}`;
        b = `0x${h[3]}${h[3]}`;
      } else if (h.length === 7) {
        r = `0x${h[1]}${h[2]}`;
        g = `0x${h[3]}${h[4]}`;
        b = `0x${h[5]}${h[6]}`;
      }
      return `${+r},${+g},${+b}`;
    };
    Chart.register(plugin_tooltip);
    Chart.defaults.font.family = '"Inter", sans-serif';
    Chart.defaults.font.weight = 500;
    Chart.defaults.plugins.tooltip.borderWidth = 1;
    Chart.defaults.plugins.tooltip.displayColors = false;
    Chart.defaults.plugins.tooltip.mode = "nearest";
    Chart.defaults.plugins.tooltip.intersect = false;
    Chart.defaults.plugins.tooltip.position = "nearest";
    Chart.defaults.plugins.tooltip.caretSize = 0;
    Chart.defaults.plugins.tooltip.caretPadding = 20;
    Chart.defaults.plugins.tooltip.cornerRadius = 8;
    Chart.defaults.plugins.tooltip.padding = 8;
    const chartAreaGradient = (ctx, chartArea, colorStops) => {
      if (!ctx || !chartArea || !colorStops || colorStops.length === 0) {
        const transparentGradient = ctx ? ctx.createLinearGradient(0, 0, 0, 0) : new CanvasGradient();
        transparentGradient.addColorStop(0, "transparent");
        return transparentGradient;
      }
      const gradient = ctx.createLinearGradient(
        0,
        chartArea.bottom,
        0,
        chartArea.top
      );
      colorStops.forEach(({ stop, color: color2 }) => {
        gradient.addColorStop(stop, color2);
      });
      return gradient;
    };
    const chartColors = {
      textColor: {
        light: tailwindConfig().theme.colors.gray[400],
        dark: tailwindConfig().theme.colors.gray[500]
      },
      gridColor: {
        light: tailwindConfig().theme.colors.gray[100],
        dark: `rgba(${hexToRGB(tailwindConfig().theme.colors.gray[700])}, 0.6)`
      },
      backdropColor: {
        light: tailwindConfig().theme.colors.white,
        dark: tailwindConfig().theme.colors.gray[800]
      },
      tooltipTitleColor: {
        light: tailwindConfig().theme.colors.gray[800],
        dark: tailwindConfig().theme.colors.gray[100]
      },
      tooltipBodyColor: {
        light: tailwindConfig().theme.colors.gray[500],
        dark: tailwindConfig().theme.colors.gray[400]
      },
      tooltipBgColor: {
        light: tailwindConfig().theme.colors.white,
        dark: tailwindConfig().theme.colors.gray[700]
      },
      tooltipBorderColor: {
        light: tailwindConfig().theme.colors.gray[200],
        dark: tailwindConfig().theme.colors.gray[600]
      }
    };
    const useResizeObserver = () => {
      const [dimensions, setDimensions] = reactExports.useState({ width: 0, height: 0 });
      const containerRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        const resizeObserver = new ResizeObserver((entries) => {
          if (entries[0]) {
            const { width, height } = entries[0].contentRect;
            setDimensions({ width, height });
          }
        });
        if (containerRef.current) {
          resizeObserver.observe(containerRef.current);
        }
        return () => {
          if (containerRef.current) {
            resizeObserver.unobserve(containerRef.current);
          }
        };
      }, []);
      return [containerRef, dimensions];
    };
    function commonjsRequire(path) {
      throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    //! moment.js
    //! version : 2.30.1
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback2) {
      hookCallback = callback2;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;
        for (k in obj) {
          if (hasOwnProp(obj, k)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
      var res = [], i, arrLen = arr.length;
      for (i = 0; i < arrLen; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }
      if (hasOwnProp(b, "toString")) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, "valueOf")) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }
      return m._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t = Object(this), len = t.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m) {
      var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
      if (isNowValid) {
        flags = getParsingFlags(m);
        parsedParts = some.call(flags.parsedDateParts, function(i) {
          return i != null;
        });
        isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
      }
      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
      return m._isValid;
    }
    function createInvalid(flags) {
      var m = createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }
      return m;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i = 0; i < momentPropertiesLen; i++) {
          prop = momentProperties[i];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = /* @__PURE__ */ new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i, key, argLen = arguments.length;
          for (i = 0; i < argLen; i++) {
            arg = "";
            if (typeof arguments[i] === "object") {
              arg += "\n[" + i + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set(config) {
      var prop, i;
      for (i in config) {
        if (hasOwnProp(config, i)) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this["_" + i] = prop;
          }
        }
      }
      this._config = config;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          res[prop] = extend({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback2) {
      var func = callback2;
      if (typeof callback2 === "string") {
        func = function() {
          return this[callback2]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array = format2.match(formattingTokens), i, length;
      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }
      return function(mom) {
        var output = "", i2;
        for (i2 = 0; i2 < length; i2++) {
          output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
        }
        return output;
      };
    }
    function formatMoment(m, format2) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m);
    }
    function expandFormat(format2, locale2) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {
      D: "date",
      dates: "date",
      date: "date",
      d: "day",
      days: "day",
      day: "day",
      e: "weekday",
      weekdays: "weekday",
      weekday: "weekday",
      E: "isoWeekday",
      isoweekdays: "isoWeekday",
      isoweekday: "isoWeekday",
      DDD: "dayOfYear",
      dayofyears: "dayOfYear",
      dayofyear: "dayOfYear",
      h: "hour",
      hours: "hour",
      hour: "hour",
      ms: "millisecond",
      milliseconds: "millisecond",
      millisecond: "millisecond",
      m: "minute",
      minutes: "minute",
      minute: "minute",
      M: "month",
      months: "month",
      month: "month",
      Q: "quarter",
      quarters: "quarter",
      quarter: "quarter",
      s: "second",
      seconds: "second",
      second: "second",
      gg: "weekYear",
      weekyears: "weekYear",
      weekyear: "weekYear",
      GG: "isoWeekYear",
      isoweekyears: "isoWeekYear",
      isoweekyear: "isoWeekYear",
      w: "week",
      weeks: "week",
      week: "week",
      W: "isoWeek",
      isoweeks: "isoWeek",
      isoweek: "isoWeek",
      y: "year",
      years: "year",
      year: "year"
    };
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {
      date: 9,
      day: 11,
      weekday: 11,
      isoWeekday: 11,
      dayOfYear: 4,
      hour: 13,
      millisecond: 16,
      minute: 14,
      month: 8,
      quarter: 7,
      second: 15,
      weekYear: 1,
      isoWeekYear: 1,
      week: 5,
      isoWeek: 5,
      year: 1
    };
    function getPrioritizedUnits(unitsObj) {
      var units = [], u;
      for (u in unitsObj) {
        if (hasOwnProp(unitsObj, u)) {
          units.push({ unit: u, priority: priorities[u] });
        }
      }
      units.sort(function(a, b) {
        return a.priority - b.priority;
      });
      return units;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
    regexes = {};
    function addRegexToken(token2, regex, strictRegex) {
      regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token2, config) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return regexEscape(
        s.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    var tokens = {};
    function addParseToken(token2, callback2) {
      var i, func = callback2, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback2)) {
        func = function(input, array) {
          array[callback2] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i = 0; i < tokenLen; i++) {
        tokens[token2[i]] = func;
      }
    }
    function addWeekParseToken(token2, callback2) {
      addParseToken(token2, function(input, array, config, token3) {
        config._w = config._w || {};
        callback2(input, config._w, config, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config._a, config, token2);
      }
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    addFormatToken("Y", 0, 0, function() {
      var y = this.year();
      return y <= 9999 ? zeroFill(y, 4) : "+" + y;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }
    function get(mom, unit) {
      if (!mom.isValid()) {
        return NaN;
      }
      var d = mom._d, isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
        case "Seconds":
          return isUTC ? d.getUTCSeconds() : d.getSeconds();
        case "Minutes":
          return isUTC ? d.getUTCMinutes() : d.getMinutes();
        case "Hours":
          return isUTC ? d.getUTCHours() : d.getHours();
        case "Date":
          return isUTC ? d.getUTCDate() : d.getDate();
        case "Day":
          return isUTC ? d.getUTCDay() : d.getDay();
        case "Month":
          return isUTC ? d.getUTCMonth() : d.getMonth();
        case "FullYear":
          return isUTC ? d.getUTCFullYear() : d.getFullYear();
        default:
          return NaN;
      }
    }
    function set$1(mom, unit, value) {
      var d, isUTC, year, month, date;
      if (!mom.isValid() || isNaN(value)) {
        return;
      }
      d = mom._d;
      isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
        case "Seconds":
          return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
        case "Minutes":
          return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
        case "Hours":
          return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
        case "Date":
          return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
        // case 'Day': // Not real
        //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
        // case 'Month': // Not used because we need to pass two variables
        //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
        case "FullYear":
          break;
        // See below ...
        default:
          return;
      }
      year = value;
      month = mom.month();
      date = mom.date();
      date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
      void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
        for (i = 0; i < prioritizedLen; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value);
        }
      }
      return this;
    }
    function mod(n, x) {
      return (n % x + x) % x;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addRegexToken("M", match1to2, match1to2NoLeadingZero);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m, format2) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months["standalone"];
      }
      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
    }
    function localeMonthsShort(m, format2) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i, ii, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
          mom = createUTC([2e3, i]);
          this._shortMonthsParse[i] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i, mom, regex;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i]) {
          regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value) {
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === "string") {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (!isNumber(value)) {
            return mom;
          }
        }
      }
      var month = value, date = mom.date();
      date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
      void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        shortP = regexEscape(this.monthsShort(mom, ""));
        longP = regexEscape(this.months(mom, ""));
        shortPieces.push(shortP);
        longPieces.push(longP);
        mixedPieces.push(longP);
        mixedPieces.push(shortP);
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    function createDate(y, m, d, h, M, s, ms) {
      var date;
      if (y < 100 && y >= 0) {
        date = new Date(y + 400, m, d, h, M, s, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }
      return date;
    }
    function createUTCDate(y) {
      var date, args;
      if (y < 100 && y >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addRegexToken("w", match1to2, match1to2NoLeadingZero);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2, match1to2NoLeadingZero);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format2) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }
    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i = 0; i < 7; ++i) {
          mom = createUTC([2e3, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i, mom, regex;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i]) {
          regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = get(this, "Day");
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2, match1to2HasZero);
    addRegexToken("h", match1to2, match1to2NoLeadingZero);
    addRegexToken("k", match1to2, match1to2NoLeadingZero);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i, minl = Math.min(arr1.length, arr2.length);
      for (i = 0; i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
          return i;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names2) {
      var i = 0, j, next, locale2, split;
      while (i < names2.length) {
        split = normalizeLocale(names2[i]).split("-");
        j = split.length;
        next = normalizeLocale(names2[i + 1]);
        next = next ? next.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name) {
      return !!(name && name.match("^[^/\\\\]*$"));
    }
    function loadLocale(name) {
      var oldLocale = null, aliasedRequire;
      if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = commonjsRequire;
          aliasedRequire("./locale/" + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {
          locales[name] = null;
        }
      }
      return locales[name];
    }
    function getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, config) {
      if (config !== null) {
        var locale2, parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale2 = loadLocale(config.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }
              localeFamilies[config.parentLocale].push({
                name,
                config
              });
              return null;
            }
          }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));
        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function(x) {
            defineLocale(x.name, x.config);
          });
        }
        getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function updateLocale(name, config) {
      if (config != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name] != null && locales[name].parentLocale != null) {
          locales[name].set(mergeConfigs(locales[name]._config, config));
        } else {
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          if (tmpLocale == null) {
            config.abbr = name;
          }
          locale2 = new Locale(config);
          locale2.parentLocale = locales[name];
          locales[name] = locale2;
        }
        getSetGlobalLocale(name);
      } else {
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
            if (name === getSetGlobalLocale()) {
              getSetGlobalLocale(name);
            }
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }
      return locales[name];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m) {
      var overflow, a = m._a;
      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m).overflow = overflow;
      }
      return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config) {
      var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match) {
        getParsingFlags(config).iso = true;
        for (i = 0, l = isoDatesLen; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match[3]) {
          for (i = 0, l = isoTimesLen; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              timeFormat = (match[2] || " ") + isoTimes[i][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = "Z";
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s) {
      return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
      }
    }
    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
      if (match) {
        parsedArray = extractFromRFC2822Strings(
          match[4],
          match[3],
          match[2],
          match[5],
          match[6],
          match[7]
        );
        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }
        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = /* @__PURE__ */ new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      configFromRFC2822(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      if (config._strict) {
        config._isValid = false;
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
      if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(
          w.GG,
          config._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
        week = defaults(w.w, curWeek.week);
        if (w.d != null) {
          weekday = w.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          weekday = w.e + dow;
          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config) {
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i = 0; i < tokenLen; i++) {
        token2 = tokens2[i];
        parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(
            string.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = void 0;
      }
      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      config._a[HOUR] = meridiemFixWrap(
        config._locale,
        config._a[HOUR],
        config._meridiem
      );
      era = getParsingFlags(config).era;
      if (era !== null) {
        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
      if (configfLen === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = /* @__PURE__ */ new Date(NaN);
        return;
      }
      for (i = 0; i < configfLen; i++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
      config._a = map(
        [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i, format2 = config._f;
      config._locale = config._locale || getLocale(config._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format2)) {
        configFromStringAndArray(config);
      } else if (format2) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }
      if (!isValid(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = void 0;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale2;
      c._i = input;
      c._f = format2;
      c._strict = strict;
      return createFromConfig(c);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m) {
      var key, unitHasDecimal = false, i, orderLen = ordering.length;
      for (key in m) {
        if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }
      for (i = 0; i < orderLen; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
      minutes2 * 6e4 + // 1000 * 60
      hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
      for (i = 0; i < len; i++) {
        if (toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
      var matches = (string || "").match(matcher), chunk, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk = matches[matches.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m) {
      return -Math.round(m._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c = {}, other;
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match = aspNetRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign2,
          h: toInt(match[HOUR]) * sign2,
          m: toInt(match[MINUTE]) * sign2,
          s: toInt(match[SECOND]) * sign2,
          ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
          // the millisecond decimal point is included in the match
        };
      } else if (match = isoRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign2),
          M: parseIso(match[3], sign2),
          w: parseIso(match[4], sign2),
          d: parseIso(match[5], sign2),
          h: parseIso(match[6], sign2),
          m: parseIso(match[7], sign2),
          s: parseIso(match[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
        diffRes = momentsDifference(
          createLocal(duration.from),
          createLocal(duration.to)
        );
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name,
            "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i, property, propertyLen = properties.length;
      for (i = 0; i < propertyLen; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i, property;
      for (i = 0; i < properties.length; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now2))
      );
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        // 1000
        case "minute":
          output = (this - that) / 6e4;
          break;
        // 1000 * 60
        case "hour":
          output = (this - that) / 36e5;
          break;
        // 1000 * 60 * 60
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        // 1000 * 60 * 60 * 24, negate dst
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        // 1000 * 60 * 60 * 24 * 7, negate dst
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      if (a.date() < b.date()) {
        return -monthDiff(b, a);
      }
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(
          m,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
        }
      }
      return formatMoment(
        m,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
      if (y < 100 && y >= 0) {
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }
    function utcStartOfDate(y, m, d) {
      if (y < 100 && y >= 0) {
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray() {
      var m = this;
      return [
        m.year(),
        m.month(),
        m.date(),
        m.hour(),
        m.minute(),
        m.second(),
        m.millisecond()
      ];
    }
    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m, format2) {
      var i, l, date, eras = this._eras || getLocale("en")._eras;
      for (i = 0, l = eras.length; i < l; ++i) {
        switch (typeof eras[i].since) {
          case "string":
            date = hooks(eras[i].since).startOf("day");
            eras[i].since = date.valueOf();
            break;
        }
        switch (typeof eras[i].until) {
          case "undefined":
            eras[i].until = Infinity;
            break;
          case "string":
            date = hooks(eras[i].until).startOf("day").valueOf();
            eras[i].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i, l, eras = this.eras(), name, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i = 0, l = eras.length; i < l; ++i) {
        name = eras[i].name.toUpperCase();
        abbr = eras[i].abbr.toUpperCase();
        narrow = eras[i].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i];
              }
              break;
            case "NNNN":
              if (name === eraName) {
                return eras[i];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i];
              }
              break;
          }
        } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].name;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].narrow;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].abbr;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i, l, dir, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        dir = eras[i].since <= eras[i].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
          return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        erasName = regexEscape(eras[i].name);
        erasAbbr = regexEscape(eras[i].abbr);
        erasNarrow = regexEscape(eras[i].narrow);
        namePieces.push(erasName);
        abbrPieces.push(erasAbbr);
        narrowPieces.push(erasNarrow);
        mixedPieces.push(erasName);
        mixedPieces.push(erasAbbr);
        mixedPieces.push(erasNarrow);
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday() + this.localeData()._week.dow,
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addRegexToken("D", match1to2, match1to2NoLeadingZero);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addRegexToken("m", match1to2, match1to2HasZero);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addRegexToken("s", match1to2, match1to2HasZero);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
      return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format2, index2, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index2);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index2, field) {
      if (isNumber(format2)) {
        index2 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index2 != null) {
        return get$1(format2, index2, field, "month");
      }
      var i, out = [];
      for (i = 0; i < 12; i++) {
        out[i] = get$1(format2, i, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index2, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index2 = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
      if (index2 != null) {
        return get$1(format2, (index2 + shift) % 7, field, "day");
      }
      for (i = 0; i < 7; i++) {
        out[i] = get$1(format2, (i + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index2) {
      return listMonthsImpl(format2, index2, "months");
    }
    function listMonthsShort(format2, index2) {
      return listMonthsImpl(format2, index2, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          // Math.floor prevents floating point math errors here
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
    function clone$1() {
      return createDuration(this);
    }
    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
      return function() {
        return this.isValid() ? this._data[name] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale2;
      return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.30.1";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    /*!
      * chartjs-adapter-moment v1.0.1
      * https://www.chartjs.org
      * (c) 2022 chartjs-adapter-moment Contributors
      * Released under the MIT license
      */
    const FORMATS = {
      datetime: "MMM D, YYYY, h:mm:ss a",
      millisecond: "h:mm:ss.SSS a",
      second: "h:mm:ss a",
      minute: "h:mm a",
      hour: "hA",
      day: "MMM D",
      week: "ll",
      month: "MMM YYYY",
      quarter: "[Q]Q - YYYY",
      year: "YYYY"
    };
    adapters._date.override(typeof hooks === "function" ? {
      _id: "moment",
      // DEBUG ONLY
      formats: function() {
        return FORMATS;
      },
      parse: function(value, format2) {
        if (typeof value === "string" && typeof format2 === "string") {
          value = hooks(value, format2);
        } else if (!(value instanceof hooks)) {
          value = hooks(value);
        }
        return value.isValid() ? value.valueOf() : null;
      },
      format: function(time, format2) {
        return hooks(time).format(format2);
      },
      add: function(time, amount, unit) {
        return hooks(time).add(amount, unit).valueOf();
      },
      diff: function(max2, min2, unit) {
        return hooks(max2).diff(hooks(min2), unit);
      },
      startOf: function(time, unit, weekday) {
        time = hooks(time);
        if (unit === "isoWeek") {
          weekday = Math.trunc(Math.min(Math.max(0, weekday), 6));
          return time.isoWeekday(weekday).startOf("day").valueOf();
        }
        return time.startOf(unit).valueOf();
      },
      endOf: function(time, unit) {
        return hooks(time).endOf(unit).valueOf();
      }
    } : {});
    Chart.register(
      LineController,
      LineElement,
      index,
      PointElement,
      LinearScale,
      TimeScale,
      plugin_tooltip
    );
    function LineChart({ data }) {
      const [chart, setChart] = reactExports.useState(null);
      const canvasRef = reactExports.useRef(null);
      const { currentTheme } = useThemeProvider();
      const darkMode = currentTheme === "dark";
      const { tooltipBodyColor, tooltipBgColor, tooltipBorderColor } = chartColors;
      const [containerRef, dimensions] = useResizeObserver();
      reactExports.useEffect(() => {
        const ctx = canvasRef.current;
        if (!ctx) return;
        const formattedData = {
          labels: data.labels.map(
            (label) => hooks(label, "MM-YYYY").toDate()
          ),
          datasets: data.datasets.map((dataset) => ({
            ...dataset,
            data: dataset.data.map((value, index2) => ({
              x: hooks(data.labels[index2], "MM-YYYY").toDate(),
              y: value
            }))
          }))
        };
        const newChart = new Chart(ctx, {
          type: "line",
          data: formattedData,
          options: {
            responsive: true,
            layout: {
              padding: 20
            },
            scales: {
              y: {
                display: true,
                beginAtZero: true,
                grid: {
                  display: false
                },
                ticks: {
                  callback: function(value) {
                    if (Number.isInteger(value)) {
                      return value;
                    }
                    return null;
                  }
                }
              },
              x: {
                type: "time",
                time: {
                  unit: "month",
                  tooltipFormat: "MM-YYYY",
                  displayFormats: {
                    month: "MM-YYYY"
                  }
                },
                grid: {
                  display: true
                },
                ticks: {
                  maxRotation: 0,
                  minRotation: 0,
                  major: {
                    enabled: true
                  },
                  callback: function(value, index2, values) {
                    return new Date(value).toLocaleDateString(
                      "en-US",
                      {
                        month: "short",
                        year: "numeric"
                      }
                    );
                  }
                }
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  title: () => "",
                  // Disable tooltip title
                  label: (context) => {
                    const value = context.parsed.y;
                    return value.toString();
                  }
                },
                bodyColor: darkMode ? tooltipBodyColor.dark : tooltipBodyColor.light,
                backgroundColor: darkMode ? tooltipBgColor.dark : tooltipBgColor.light,
                borderColor: darkMode ? tooltipBorderColor.dark : tooltipBorderColor.light
              },
              legend: {
                display: false
              }
            },
            interaction: {
              intersect: false,
              mode: "nearest"
            },
            maintainAspectRatio: false,
            resizeDelay: 200
          }
        });
        setChart(newChart);
        return () => newChart.destroy();
      }, [darkMode, data, tooltipBgColor, tooltipBodyColor, tooltipBorderColor]);
      reactExports.useEffect(() => {
        if (chart) {
          chart.resize();
        }
      }, [dimensions, chart]);
      return /* @__PURE__ */ React.createElement("div", { ref: containerRef, className: "w-full h-full" }, /* @__PURE__ */ React.createElement("canvas", { ref: canvasRef }));
    }
    function DashboardCard({ data }) {
      const chartData = {
        labels: Object.keys(data.activity),
        datasets: [
          {
            data: Object.values(data.activity),
            fill: true,
            backgroundColor: function(context) {
              const chart = context.chart;
              const { ctx, chartArea } = chart;
              return chartAreaGradient(ctx, chartArea, [
                {
                  stop: 0,
                  color: `rgba(${hexToRGB(
                    tailwindConfig().theme.colors.violet[500]
                  )}, 0)`
                },
                {
                  stop: 1,
                  color: `rgba(${hexToRGB(
                    tailwindConfig().theme.colors.violet[500]
                  )}, 0.2)`
                }
              ]);
            },
            borderColor: tailwindConfig().theme.colors.violet[500],
            borderWidth: 2,
            pointRadius: 0,
            pointHoverRadius: 3,
            pointBackgroundColor: tailwindConfig().theme.colors.violet[500],
            pointHoverBackgroundColor: tailwindConfig().theme.colors.violet[500],
            pointBorderWidth: 0,
            pointHoverBorderWidth: 0,
            clip: 20,
            tension: 0
          }
        ]
      };
      return /* @__PURE__ */ React.createElement("div", { className: "flex flex-col col-span-full sm:col-span-1 bg-white dark:bg-gray-800 shadow-sm rounded-3xl h-full" }, /* @__PURE__ */ React.createElement("div", { className: "px-5 pt-5" }, /* @__PURE__ */ React.createElement("header", { className: "flex justify-between items-start" }, /* @__PURE__ */ React.createElement("h2", { className: "text-sm font-semibold text-gray-800 dark:text-gray-100 mb-2" }, "Activity")), /* @__PURE__ */ React.createElement("div", { className: "flex items-start" })), /* @__PURE__ */ React.createElement("div", { className: "grow h-full pb-4" }, /* @__PURE__ */ React.createElement(LineChart, { data: chartData })));
    }
    const App = ({ data }) => {
      return /* @__PURE__ */ React.createElement("div", { className: "flex flex-col w-full h-screen overflow-y-auto bg-gray-100 p-4" }, /* @__PURE__ */ React.createElement(Dropdown, { data: data.listClass }), /* @__PURE__ */ React.createElement(Box, { sx: { flexGrow: 1 } }, /* @__PURE__ */ React.createElement(Grid2, { container: true, spacing: 2, alignItems: "stretch" }, /* @__PURE__ */ React.createElement(Grid2, { container: true, size: { xs: 12, md: 6 } }, /* @__PURE__ */ React.createElement(
        Grid2,
        {
          size: { xs: 12, sm: 12 },
          height: "100%",
          width: "100%"
        },
        /* @__PURE__ */ React.createElement(
          Card,
          {
            className: data.firstClass.class_name,
            token: data.firstClass.token
          }
        )
      )), /* @__PURE__ */ React.createElement(Grid2, { size: { xs: 12, md: 6 } }, /* @__PURE__ */ React.createElement(DashboardCard, { data: data.currentKnowledge })), /* @__PURE__ */ React.createElement(Grid2, { size: { xs: 12, md: 6 } }, /* @__PURE__ */ React.createElement(
        TopicsList,
        {
          title: "Weakest Topics",
          topics: data.weakestTopics
        }
      )), /* @__PURE__ */ React.createElement(Grid2, { size: { xs: 12, md: 6 } }, /* @__PURE__ */ React.createElement(
        TopicsList,
        {
          title: "Strongest Topics",
          topics: data.strongestTopics
        }
      )), /* @__PURE__ */ React.createElement(Grid2, { size: { xs: 12, md: 6 } }, /* @__PURE__ */ React.createElement(
        Leaderboard,
        {
          title: "Top first 5",
          leaders: data.topFirst5
        }
      )), /* @__PURE__ */ React.createElement(Grid2, { size: { xs: 12, md: 6 } }, /* @__PURE__ */ React.createElement(
        Leaderboard,
        {
          title: "Worst last 5",
          leaders: data.topLast5
        }
      )))));
    };
    const Dashboard = ({ initialData: initialData2 }) => {
      const [data, setData] = reactExports.useState(initialData2);
      return /* @__PURE__ */ React.createElement("div", { className: "flex w-full h-screen overflow-hidden" }, /* @__PURE__ */ React.createElement(Sidebar, { user: data.dataUserLogin }), /* @__PURE__ */ React.createElement("div", { className: "relative flex flex-col flex-1 overflow-x-hidden" }, /* @__PURE__ */ React.createElement("main", { className: "w-full" }, /* @__PURE__ */ React.createElement(App, { data }))));
    };
    const ssrData = (_b = document.getElementById("app")) == null ? void 0 : _b.getAttribute("data-ssr");
    const initialData = ssrData ? JSON.parse(ssrData) : {};
    if (document.getElementById("app")) {
      ReactDOM.createRoot(document.getElementById("app")).render(
        /* @__PURE__ */ React.createElement(React.StrictMode, null, /* @__PURE__ */ React.createElement(BrowserRouter, null, /* @__PURE__ */ React.createElement(Dashboard, { initialData })))
      );
    }
  }
});
export default require_Dashboard_007();
